# 第一行代码重点笔记



## 四大组件

活动（Activity）：看到的东西

服务（Service）：后台运行

广播接收器（Broadcast Receiver）：允许你的应用接收来自各处的广播消息，比如电话、短信等，你的应用也可以向外发出广播消息

内容提供器（Content Provider）：为应用程序提供了可能，比如读取系统电话薄中的联系人





Package name 表示项目的包名，Android 系统就是通过包名来区别不同应用程序的





## 分析第一个Android 程序

1、.gradle 和 .idea

Android Studio 自动生成的一些文件



2、app

项目中的代码、资源等内容几乎都是放置在这个目录下面

- build：编译时自动生成的文件

- libs：第三方 Jar 包

- AndroidManifest.xml：整个 Android 项目的配置文件，在程序中定义的所有四大组件都需要在这个文件里注册，另外还可以在这个文件中给应用程序添加权限声明

- proguard-rules.pro：用于指定项目代码的混淆规则，当代码开发完成后打成安装包文件，如果不希望代码被别人破解，通常会将代码进行混淆，从而让破解者难以阅读

- res：drawable 开头的文件夹都是用来放图片的，mipmap 开头的文件夹都是用来放应用图标的，values 开头的文件夹都是用来放字符串、样式、颜色等配置的，layout 文件夹是用来放布局文件的

- build.gradle：

  ```java
  //应用了插件，一般有两种值可以选 com.android.application 表示一个应用程序模块，com.android.library 表示这是一个库模块。区别在于应用程序模块可以直接运行，库模块只能作为代码库依附于别的应用程序来运行
  apply plugin: 'com.android.application'
  
  //配置项目的各种属性
  android {
      //项目的编译版本
      compileSdkVersion 27
  
  	//项目更多细节的配置
      defaultConfig {
          //用于指定项目的包名
          applicationId "com.waibao.team.cityexpressforsend"
          //用于指定项目最低兼容的 Android 系统版本
          minSdkVersion 16
  
  		//系统将为应用程序启用一些最新的功能和特性
          targetSdkVersion 27
          //项目的版本号
          versionCode 138
          //项目的版本名
          versionName "1.3.8"
      }
  
      //用于指定生成安装文件的相关配置
      buildTypes {
          debug {
              minifyEnabled false
          }
          release {
              //用于指定是否对项目的代码进行混淆
              minifyEnabled true
              //用于指定混淆时使用的规则文件
              //proguard-android.txt 是在 Android SDK 目录下的，proguard-rules.pro 是在当前项目的根目录下的
              proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
          }
      }
  
  }
  
  //指定当前项目所有的依赖关系，通常有三种依赖方式：本地依赖（implementation fileTree）、库依赖（implementation）、远程依赖（implementation project）
  dependencies {
      implementation ...
  }
  
  ```

- 其他文件和外层一样功能



3、build

编译时自动生成的文件



4、gradle

包含了 gradle wrappper 的配置文件，设置里面 Gradle 里包含了缓存目录



5、.gitignore

用来将指定的目录或文件排除在版本控制之外的



6、build.gradle

项目全局的 gradle 构建脚本

- repositories：jcenter() 是一个代码仓库，声明了这行配置之后就可以在项目中使用 jcenter 上的开源项目
- classpath：声明 Gradle 插件来专门构建 Android 项目



7、gradle.properties

全局的 gradle 配置文件，这里配置的属性将会影响到项目中所有的 gradle 编译脚本



8、gradlew 和 gradlew.bat

用来在命令行界面中执行 gradle 命令的，其中 gradlew 是在 Linux 或 Mac 系统中使用的，gradlew.bat 是在 Windows 中使用的



9、***.iml

iml 文件是所有 IntelliJ IDEA 项目都会自动生成的一个文件



10、local.properties

用于指定本机中的 Android SDK 路径



11、settings.gradle

用于指定项目中所有引入的模块





## 使用 Android  的日志工具 Log

Android中的工具类是 Log (android.util.Log)

Log.v()：打印最琐碎、意义最小的日志信息

Log.d()：打印一些调试信息，调试程序和分析问题应该有帮助的

Log.i()：打印一些比较重要的数据，分析用户行为数据

Log.w()：打印一些警告信息，warn

Log.e()：打印程序中的错误信息，error

**Log.d（）方法中传入了两个参数：第一个参数是 tag ，一般传入当前的类名就好，主要用于对打印信息进行过滤；第二参数是 msg ，即想打印的具体内容**



在 onCreate() 方法外面输入 logt 然后按下 Tab 键就会自动生成一个 TAG 常量

输入 logd，然后按下 Tab 键就会自动补全一条完整的打印语句





## logcat过滤器

- Show only selected application 表示当前选中的程序日志
- Firebase 是谷歌提供的一个分析工具
- No Filters 相当于没有过滤器，会把所有日志都显示出来





## 定制自己的日志工具

早在第一章第四节中我们就已经学过了 Android 日志工具的用法，虽然 Android 中自带的日志工具功能非常强大，但也不能说是完全没有缺点，例如在打印日志的控制方面做得不够好

例如你正在编写一个比较庞大的项目，期间为了方便调试，在代码的很多地方都打印了大量的日志，最近项目已经基本完成了，但是却有一个非常让人头疼的问题，之前用于调试的那些日志，在项目正式上线之后仍然会照常打印，这样不仅会降低程序的运行效率，还有可能将一些机密性的数据泄露出去

难道要一行一行的删掉吗？显然这不是什么好点子，不仅费时费力，而且以后继续维护这个项目的时候可能还需要这些日志，因此，最理想的情况是能够自由地控制日志的打印，当程序处于开发阶段的时候就让日志打印出来，当程序上线之后把日志屏蔽掉

实现这个功能只需要定制一个自己的日志工具就可以轻松完成，比如新建一个 LogUtil

```java
public class LogUtil {
	
	public static final int VERBOSE = 1;
    
    public static final int DEBUG = 2;
    
    public static final int INFO = 3;
    
    public static final int WARN = 4;
    
    public static final int ERROR = 5;
    
    public static final int NOTHING = 6;
    
    public static int level = VERBOSE;
    
    public static void v(String tag, String msg) {
        if (level <= VERBOSE) {
            Log.v(tag, msg);
        }
    }
        
    public static void d(String tag, String msg) {
        if (level <= DEBUG) {
            Log.d(tag, msg);
        }
    }
       
    public static void i(String tag, String msg) {
        if (level <= INFO) {
            Log.i(tag, msg);
        }
    }
    
    public static void w(String tag, String msg) {
        if (level <= WARN) {
            Log.w(tag, msg);
        }
    }
    
    public static void e(String tag, String msg) {
        if (level <= ERROR) {
            Log.e(tag, msg);
        }
    }
	
}
```

首先定义了 VERBOSE 、DEBUG、INFO、WARN、ERROR、NOTHING 这六个整型常量，并且它们对应的值都是递增的，然后又定义一个 level，可以将它的值指定为上面 6 个常量中的任意一个

接下来我们提供了 v()、d()、i()、w()、e() 这 5 个定义方法，其内部分别调用了 Log.v()、Log.d()、Log.i()、Log.w()、Log.e() 这 5 个方法来打印日志，只不过在这些自定义方法中我们都加入了一个 if 判断，只有当 level 的值小于或等于对应日志级别的时候，才能将日志打印出来

这样就把一个自定义的日志工具创建好了，之后在项目里我们可以像使用普通工具一样使用 LogUtil ，比如打印一行 DEBUG 级别的日志：

```java
LogUtil.d("TAG", "debug log");
```

然后我们只需要修改 level 变量的值，就可以自由地控制日志的打印行为了，比如让 level 等于 VERBOSE 就可以把所有的日志都打印出来，让 level 等于 WARN 就可以只打印警告以上级别的日志，让 level 等于 NOTHING 就可以把所有日志都屏蔽掉

使用了这种方法之后，刚才所说的那个问题就不复存在了，你只需要在开发阶段将 level 指定成 VERBOSE，当项目正式上线的时候将 level 指定成 NOTHING 就可以了





## AndroidManifest.xml

```xml
<!--活动中标题栏的内容，启动器（Launcher）中应用程序显示的名称-->
android:label
```

android.intent.action.MAIN 决定应用程序最先启动的 Activity

android.intent.category.LAUNCHER 决定应用程序是否显示在程序列表里

通过实验后，发现 MAIN 与 LAUNCHER 并不是单纯的各管各的事情；我测试的结果是，如果一个应用没有 LAUNCHER则该 apk 仍能安装到设备上，但是在桌面中图标中看不到。如果给那个 Activity 设定了 LAUNCHER，且同时设定了MAIN，则这个 Activity 就可出现在程序图标中；如果没有 MAIN，则不知启动哪个 Activity，故也不会有图标出现。可见，MAIN 指的是点击图标后启动哪个Activity。

当然 Main 可以给多个 Activity 设定，但只设定 MAIN 不设定 LAUNCHER，仍然无法进入 Activity。android.intent.action.MAIN 标记了启动 Application 时先启动那个 Activity，若有多个 android.intent.action.MAIN，则先启动 mainfest 里面第一个出现的 android.intent.action.MAIN





## Activity

Activity 是 Android 系统提供的一个活动基类，我们项目中所有的活动都必须继承它或者它的子类才能拥有活动的特性（AppCompatActivity是Activity的子类）

项目中的任何活动都因该重写 Activity 的 onCreate() 方法

setContentView() 方法来给当前的活动加载一个布局，而在 setContentView() 方法中，我们一般都会传入一个布局文件的 id

项目中添加的任何资源都会在 R 文件中生成一个相应的资源 id

所有的活动都要在 AndroidManifest.xml 中进行注册才能生效；活动的注册声明都要放在 <application> 标签内，这里是通过 <activity> 标签来对活动进行注册的；仅仅是注册了活动程序仍然是不能运行的，需要为程序配置主活动，即在 <activity> 标签的内部加入 <intent-filter> 标签，并在这个标签里添加 <action android:name="android.intent.action.MAIN" /> 和 <category android:name="android.intent.category.LAUNCHER" /> 这两句声明

销毁一个活动可以调用 Activity 类提供了一个 finish() 方法就可以销毁当前的活动了



### Menu

在 res 目录右击新建一个 Directory 命名 menu，右击 menu 新建一个 Menu resource file

<item> 标签就是用来创建具体的某一个菜单项，然后通过 android:id 给这个菜单项制定一个唯一的标识符，通过 android:title 给这个菜单项指定一个名称

```xml
<item
    android:id="@+id/add_item"
    android:title="Add"/>
<item
    android:id ="@+id/remove_item"
    android:title="Remove"/>
```

回到 Activity 中重写 onCreateOptionsMenu() 方法（重写方法可以使用快捷键 Ctrl + O）

```java
@Override
public boolean onCreateOptionsMenu(Menu menu) {
	//通过 getMenuInflater() 方法能够的到 MenuInflater 对象，再调用它的 inflate() 方法就可以给当前活动创建菜单了
	//inflate() 方法接收两个参数，第一个参数：指定一个资源文件来创建菜单，第二个参数：用于指定菜单项将添加到哪一个Menu对象当中
    getMenuInflater().inflate(R.menu.main,menu);
    //返回 true 表示允许创建的菜单显示出来，返回 false 创建的菜单无法显示
    return true;
}
```

仅仅让菜单显示是不够，需要能用，因此还要再定义菜单响应事件，在 Activity 中重写 onOptionsItemSelected() 方法

```java
@Override
public boolean onOptionsItemSelected(MenuItem item) {
    switch (item.getItemId()){
        case R.id.add_item:
            Toast.makeText(this, "You clicked Add", Toast.LENGTH_SHORT).show();
            break;
        case R.id.remove_item:
            Toast.makeText(this, "You clicked Remove", Toast.LENGTH_SHORT).show();
            break;
        default:
    }
    return true;
}
```

 



### Intent

Intent 是 Android 程序中各组件之间进行交互的一种重要方式，它不仅可以指明当前组件想要执行的动作，还可以在不同组件之间传递数据。Intent 一般可被用于启动活动、启动服务以及发送广播等场景

Intent 大致可以分为两种：显示 Intent 和隐式 Intent



#### 显示 Intent

```java
//第一个参数 Context 要求提供一个启动活动的上下文
//第二个参数 Class 则是指定想要启动的目标活动
//通过这个构造函数构建出 Intent 的“意图”，“意图”非常明显，即在 FirstActivity 这个活动基础上打开 SecondActivity 这个活动
Intent intent = new Intent(FirstActivity.this, SecondActivity.class);
//通过 Activity 类中提供的 startActivity() 方法，该方法接收 Intent 参数，来执行这个 Intent
startActivity(intent);
```



#### 隐式 Intent

隐式 Intent 它并不明确指出我们想要启动哪一个活动，而是指定了一些列更为抽象的 action 和 category 等信息，然后交由系统去分析这个 Intent，并帮我们找出合适的活动去启动

通过在 AndroidManifest.xml 里的 <activity> 标签下配置 <intent-filter> 标签的内容，可以指定当前活动能够响应的 action 和 category

```java
<activity android:name=".SecondActivity">
    <intent-filter>
    	//指明当前活动可以响应com.activitytest.ACTION_START 这个 action
        <action android:name="com.example.activitytest.ACTION_START"/>
        //该标签包含了一些附加信息，更加精确地指明了当前的活动能够响应的 Intent 中还可能带有的 category
        //android.intent.category.DEFAULT 是一种默认的 category，在调用的 stattActivity() 方法的时候会自动将这个 category 添加到 Intent 中
        <category android:name="android.intent.category.DEFAULT"/>
        //只有 <action> 和 <category> 中的内容同时能够匹配上 Intent 中指定的 action 和 category 这个活动才能响应该 Intent
    </intent-filter>
</activity>
```

```java
//直接传入 action 即启动该活动，category 则被默认添加了
Intent intent = new Intent("com.example.activitytest.ACTION_START");
startActivity(intent);
```

**每一个 Intent 只能指定一个 action，但却能指定多个 category**

```java
Intent intent = new Intent("com.example.activitytest.ACTION_START");
//调用 Intent 的 addCategory() 方法来添加 category
intent.addCategory("com.example.activitytest.MY_CATEGORY");
startActivity(intent);
```

```java
<activity android:name=".SecondActivity">
    <intent-filter>
        <action android:name="com.example.activitytest.ACTION_START"/>
        <category android:name="android.intent.category.DEFAULT"/>
        <category android:name="com.example.activitytest.MY_CATEGORY"/>//添加一个 category 声明
    </intent-filter>
</activity>
```



#### 更多隐式 Intent 的用法

使用隐式 Intent 我们不仅可以启动自己程序内的活动，还可以启动其他程序的活动

```java
//首先制定了 Intent 的 action 是 Intent.ACTION_VIEW，这是一个 Android 系统内置的动作，其常量值为 android.intent.action.VIEW
Intent intent = new Intent(Intent.ACTION_VIEW);
//通过 Uri.parse() 方法，将一个网址字符串解析成一个 Uri 对象，在调用 setData() 方法将这个 Uri 对象传递进去
//setData()：接收一个 Uri 对象，主要用于指定当前 Intent 正在操作的数据， 而这些数据通常都是以字符串形式传入到 Uri.parse() 方法中解析产生的
intent.setData(Uri.parse("http://www.baidu.com"));
startActivity(intent);
```

我们还可以在 <intent-filter> 标签中在配置一个 <data> 标签，用于更加精确地指定当前活动能够响应什么类型的数据。<data> 标签中主要可以配置一下内容

- android:scheme。用于指定数据的协议部分，如上例中的 http 部分
- android:host。用于指定数据的主机名部分，如上例中的 www.baidu.com 部分
- android:port。用于指定数据的端口部分，一般紧随在主机名之后
- android:path。用于指定主机名和端口之后的部分，如一段网址中那个跟在域名之后的内容
- android:mimeType。用于指定可以处理的数据类型，允许使用通配符的方式进行指定

只有 <data> 标签中指定的内容和 Intent 中携带的 Data 完全一致时，当前活动才能够响应该 Intent 。不过一般在 <data> 标签中都不会指定过多的内容

```java
<activity android:name=".ThirdActivity">
	//配置了当前活动能够响应的 action 和 Intent.ACTION_VIEW 的常量值，而 category 则指定了默认的 category
    <intent-filter>
        <action android:name="android.intent.action.VIEW"/>
        <category android:name="android.intent.category.DEFAULT"/>
        //指定了 http 协议
        <data android:scheme="http"/>
    </intent-filter>
</activity>
```

此时启动 Intent 系统会让你选择是否启动该程序的 ThirdActivity

除了 http 协议外，geo 表示显示地理位置、tel 表示拨打电话

```java
//指定了 Intent 的 action 是 Intent.ACTION_DIAL，这是 Android 系统的内置动作
Intent intent = new Intent(Intent.ACTION_DIAL);
//data 部分指定了协议是 tel ，号码是 10086
intent.setData(Uri.parse("tel:10086"));
startActivity(intent);
```



#### 向下一个活动传递数据

Intent 还可以在启动活动的时候传递数据，Intent 中提供了一系列 putExtra() 方法的重载，可以把我们想要传递的数据暂存在 Intent 中，启动了另一个活动后，只需要把这些数据再从 Intent 中取出就可以了

```java
String data = "Hello SecondActivity";
Intent intent = new Intent(FirstActivity.this, SecondActivity.class);
//putExtra() 方法接收两个参数，第一个参数是键，用于后面从 Intent 中取值，第二个参才是真正要传递的数据
intent.putExtra("extra_data", data);
startActivity(intent);
```

```java
 //通过 getIntent() 方法获取到用于启动 SecondActivity 的 Intent
 Intent intent = getIntent();
 //调用 getStringExtra() 方法传入相应的键值，就可以传递数据
 String data = intent.getStringExtra("extra_data");
```



#### 返回数据给上一个活动

Activity 中还有一个 startActivityForResult() 方法也是用于启动活动的，但这个方法期望在活动销毁的时候能够返回一个结果给上一个活动

startActivityForReasult() 方法接收两个参数，第一个参数还是 Intent，第二个参数是请求码，用于在之后的回调中判断数据的来源

修改 FirstActivity 中按钮的点击事件：

```java
button1.setOnClickListener(new View.OnClickListener(){
    @Override
    public void onClick(View v){
        Intent intent = new Intent(FirstActivity.this, SecondActivity.class);
        //使用了 startActivityForResult() 方法来启动 SecondActivity，请求码只要是一个唯一值可以了，这里传入了1
        startActivityForResult(intent, 1);
    }
});
```

在 SecondActivity 中给按钮注册点击事件，并在点击事件中添加返回数据的逻辑：

```java
public class SecondActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.second_layout);
        Button button2 = (Button) findViewById(R.id.button_2);
        button2.setOnClickListener(new View.OnClickListener(){
            @Override
            public void onClick(View v){
                //构建一个 Intent，只用来传递数据，没有指定任何的“意图”
                Intent intent = new Intent();
                //putExtra() 方法接收两个参数，第一个参数是键，用于后面从 Intent 中取值，第二个参才是真正要传递的数据
                intent.putExtra("data_return", "Hello FirstActivity");
                //调用 setResult() 方法，是专门用于向上一个活动返回数据的。setResult() 方法接收两个参数，第一个参数用于向上一个活动返回处理结果，一般只使用 RESULT_OK 或 RESULT_CANCELED 这两个值，第二个参数则把带有数据的 Intent 传递回去，然后调用了 finish() 方法来销毁当前活动
                setResult(RESULT_OK, intent);
                finish();
            }
        });
    }
}
```

由于使用 startActivityForResult() 方法来启动 SecondActivity 的，在 SecondActivity 被销毁之后会回调上一个活动的onActivityResult() 方法，因此我们需要在 FirstActivity 中重写这个方法来得到返回的数据

```java
@Override
//onActivityResult() 方法带有三个参数，第一个参数 requestCode，即我们在启动时传入的请求码，第二个参数 resultCode，即我们在返回数据时传入的处理结果，第三个参数 data，即携带着返回数据的 Intent
protected void onActivityResult(int requestCode, int resultCode, Intent data){
    switch(requestCode){
        case 1:
            if(resultCode == RESULT_OK){
                //调用 getStringExtra() 方法传入相应的键值，就可以传递数据
                String returnedData = data.getStringExtra("data_return");
                Log.d("FirstActivity", returnedData);
            }
            break;
        default:
    }
}
```

由于在一个活动中有可能调用 startActivityForReasult() 方法去启动很多不同的活动，每一个活动在返回的数据都会回调到 onActivityForResult() 这个方法中，因此首先检查 requestCode 的值来判断数据来源，确定数据时从 SecondActivity 返回的之后，再通过 resultCode 的值来判断处理结果是否成功，最后从 data 中取值并打印出来

如果用户通过按下 Back 键回到 FirstActivity，这样数据没法返回，但可以通过在 SecondActivity 中重写 onBackPressed() 方法来解决这个问题：

```java
@Override
public void onBackPressed(){
    Intent intent = new Intent();
    intent.putExtra("data_return", "Hello FirstActivity");
    setResult(RESULT_OK, intent);
    finish();
}
```



### 活动的生命周期



#### 返回栈

Android 的活动可以层叠的，我们每启动一个新的活动，就会覆盖在原活动之上，然后点击 Back 键会销毁最上面的活动，下面的一个活动就会重新显示出来

其实 Android 是使用任务（Task）来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈也被称作返回栈（Back Stack）。栈是一种后进先出的数据结构，系统总会显示处于栈顶的活动给用户





#### 活动状态

运行状态：活动位于返回栈的栈顶

暂停状态：活动不再处于栈顶位置，但仍然可见，因为并不是每一个活动都会占满整个屏幕的，比如对话框形式的活动只会占用屏幕中间的部分区域

停止状态：活动不在处于栈顶位置，并且完全不可见的时候

销毁状态：当一个活动从返回栈中移除



#### 活动的生存周期

Activity 类中定义了7个回调方法，覆盖了生命周期的每一个环节

- onCreate()：它会在活动第一次被创建的时候调用，应该在这个方法中完成活动的初始化操作，比如加载布局、绑定事件等
- onStart()：在活动有不可见变为可见的时候调用，对资源进行加载
- onResume()：整个活动准备恰好和用户进行交互的时候调用。此时的活动一定位于返回栈的栈顶，并且处于运行状态
- onPause()：在系统准备去启动或者恢复另一个活动的时候调用。我们通常会在这个方法中将一些消耗CPU的资源释放掉，以及保存一些关键数据，但这个方法执行的速度一定要快，不然会影响到行的栈顶活动的使用
- onStop()：在活动完全不可见的时候调用。它和 onPause() 方法的主要区别在于如果启动的新活动是一个对话框式的活动，那么 onPause() 方法会得到执行，而 onStop() 方法并不会执行，对资源进行释放，从而保证处于停止状态的活动不会占用过多的内存
- onDestroy()：在活动被销毁之前调用，之后活动的状态将变为销毁状态，释放内存的操作
- onReastart()：在活动由停止状态变为运行状态之前调用，也就是活动被重新启动了



以上7个方法除了 onStart() 方法，其他的都是两脸相对的，从而又可以将活动氛围3中生命周期

- 完整生存期：活动在 onCreate() 和 onDestroy() 方法之间所经历的
- 可见生存期：活动在 onStart() 和 onStop() 方法之间所经历的，在可见生存周期内，活动对于用户总是可见的资源
- 前台生存期：活动在 onResume() 方法和 onPause() 方法之间所经历的，在前台生存期内，活动总是处于运行状态的，此时活动是可以和用户进行交互的

![](E:\Android笔记\第二章笔记图片\微信图片_20181011170500.jpg)



### 活动被回收了怎么办

在活动 A 的基础上启动了活动 B，但是活动 A 的内存被收掉了，再从活动 B 返回活动 A 则并不会执行 onRestart() 方法，而是会执行活动 A 的 onCreate() 方法，因为活动 A 在这种情况下会重新创建一次，但是这样会使得活动 A 中的临时数据和状态被清空

Activity 中还提供了一个 onSaveInstanceState() 回调的方法，这个方法可以保证在活动回收之前一定会被调用，通过这个方法来解决活动被回收时临时数据得不到保存的问题

onSavaInstanceState() 方法会携带一个 Bundle() 类型的参数，Bundle 提供了一系列的方法用于保存数据，比如使用putString() 方法保存字符串，使用 putInt() 方法保存整型数据，以此类推。每个保存方法需要传入两个参数，第一个参数是键，用于后面从 Bundle 中取值，第二个参数是真正要保存的内容

在 MainActivity 中添加如下代码：

```java
@Override
protected void onSaveInstanceState(Bundle outState){
    super.onSaveInstanceState(outState);
    String tempData = "Something you just typed";
    outState.putString("data_key", tempData);
}
```

我们一直使用的 onCreate() 方法其实也有一个 Bundle 类型的参数，这个参数一般情况下都是 null，但是如果在活动被系统回收之前又通过 onSaveInstanceState() 方法来保存数据的话，这个参数就会带有之前所保存的全部数据，我们只需要在通过相应的取值方法将数据取出即可

修改 MainActivity 的 onCreate() 方法：

```java
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    Log.d(TAG, "onCreate");
    setContentView(R.layout.activity_main);
    if(savedInstanceState != null){
        String tempData = savedInstanceState.getString("data_key");
        Log.d(TAG, tempData);
    }
    ......
}
```

使用 Bundle 来保存和取出数据和在使用 Intent 传递数据时也是用的类似的方法

Intent 还可以结合 Bundle 一起用于传递数据，首先可以把需要传递的数据都保存在 Bundle 对象中，然后再将 Bundle 对象存放在 Intent 里，到了目标活动之后先从 Intent 中取出 Bundle，再从 Bundle 中一一取出数据



### 活动的启动模式

实际项目中我们应该根据特定的需求为每个活动指定恰当的启动模式，启动模式一共有四种，分别是 standard、singleTop、singTask 和 singleInstance，可以在 AndroidManifest.xml 中通过给 <avtivity> 标签指定 android:launchMode 属性来选择启动模式



#### standard

standard 是活动默认的启动模式，在不进行显示指定的情况下，所有的活动都会自动使用这种启动模式，在该模式下，每当启动一个新活动，它就会在返回栈中入栈，并处于栈顶的位置，对于使用 standard 模式的活动，系统不会在乎这个活动是否已经在返回栈中存在，每次启动都会创建该活动的一个新实例

```java
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    Log.d("FirstActivity", this.toString());
    setContentView(R.layout.first_layout);
    Button button1 = (Button) findViewById(R.id.button_1);
    button1.setOnClickListener(new View.OnClickListener(){
        @Override
        public void onClick(View v){
            Intent intent = new Intent(FirstActivity.this, FirstActivity.class);
            startActivity(intent);
        }
    });
}
```

从打印信息中我们就可以看出，每点击一次按钮去就会创建出一个新的 FirstActivity 实例，此时返回栈中也会存在3个 FirstActivity 的实例，因此你需要点击3次 Back 键才能退出程序



#### singleTop

当启动模式指定为该模式时，在启动活动时如果发现返回栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例

```java
<activity
    android:name=".FirstActivity"
    //指定 android:launchMode 属性来选择 singleTop 启动模式
    android:launchMode="singleTop"
    android:label="This is FirstActivity">
    <intent-filter>
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />
    </intent-filter>
</activity>
```

不管你点了多少次按钮都不会再有新的打印信息出现，因为目前的 FirstActivity 已经处于返回栈的栈顶，每当想要再启动一个 FirstActivity 时都会直接使用栈顶的活动，因此 FirstActivity 也只会有一个实例，仅按一次 Back 键就可以退出程序

当 FirstActivity 并未处于栈顶位置时，这时再启动 FirstActivity，还是会创建新的实例

修改 FirstActivity 中 onCreate() 方法的代码：

```java
@Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Log.d("FirstActivity", this.toString());
        setContentView(R.layout.first_layout);
        Button button1 = (Button) findViewById(R.id.button_1);
        button1.setOnClickListener(new View.OnClickListener(){
            @Override
            public void onClick(View v){
                Intent intent = new Intent(FirstActivity.this, SecondActivity.class);
                startActivity(intent);
            }
        });
    }
```

修改 SecondActivity 中 onCreate() 方法：

```java
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.second_layout);
    Button button2 = (Button) findViewById(R.id.button_2);
    button2.setOnClickListener(new View.OnClickListener(){
        @Override
        public void onClick(View v){
            Intent intent = new Intent(SecondActivity.this, FirstActivity.class);
            startActivity(intent);
        }
    });
}
```

在 FirstActivity 界面点击进入到 SecondActivity，然后在 SecondActivity 界面点击按钮又重新进入到 FirstActivity，可以看到系统创建了两个不同的 FirstActivity 实例，这是由于在 SecondActivity 中再次启动 FirstActivity，栈顶活动已经变成了 SecondActivity，因此会创建一个新的 FirstActivity 实例。现在按下 Back 键就返回到 SecondActivity，再次按下 Back 键返回到 FirstActivity，再次按下 Back 键才会退出程序



#### singleTask

当启动模式指定为 SingleTask，每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已将存在则直接使用该实例，并把这个活动之上的所有活动统统出栈，如果没有发现就会创建一个新的活动实例

修改 AndroidManifest.xml 中 FirstActivity 的启动模式：

```java
<activity
    android:name=".FirstActivity"
    android:launchMode="singleTask"
    android:label="This is FirstActivity">
    <intent-filter>
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />
    </intent-filter>
</activity>
```

在 FirstActivity 中添加 onRestart() 方法，并打印日志：

```java
@Override
protected void onRestart(){
    super.onRestart();
    Log.d("FirstActivity", "onRestart");
}
```

在 SecondActivity 中添加 onDestroy() 方法，并打印日志：

```java
@Override
protected void onDestory(){
    super.onDestroy();
    Log.d("SecondActivity", "onDestroy");
}
```

在 SecondActivity 中启动 FirstActivity 时，会发现返回栈中已经存在一个 FirstActivity 重新成为了栈顶活动的实例，并且是在 SecondActivity 的下面，于是 SecondActivity 会从返回栈中出栈，而 FirstActivity 重新成为了栈顶活动，因此 FirstActivity 的 onRestart() 方法和 SecondActivity 的 onDestroy() 方法会得到执行，现在返回栈中只剩下一个 FirstActivity 实例了，按一下 Back 键就可以退出程序



#### singleInstance

指定为 singleInstance 模式的活动会启用一个新的返回栈来管理这个活动（其实如果 singleTask 模式指定了不同的 taskAffinity，也会启动一个新的返回栈）

如果我们的程序中有一个活动是允许其他程序调用的，想实现其他程序和我们的程序可以共享这个活动的实例，使用前面3种模式是肯定做不到的，因为每个应用程序都会有自己的返回栈，同一个活动在不同的返回栈中入栈时必然是创建了新的实例，而在 singleInstance 这种模式下会有一个单独的返回栈来管理这个活动，不管是哪个应用程序来访问这个活动，都共用的同一个返回栈，也就解决了共享实例的问题

修改 AndroidManifest.xml 中 SecondActivity 的启动模式：

```java
<activity android:name=".SecondActivity"
    android:launchMode="singleInstance">
    <intent-filter>
        <action android:name="com.example.activitytest.ACTION_START" />
        <category android:name="android.intent.category.DEFAULT" />
        <category android:name="com.example.activitytest.MY_CATEGORY" />
    </intent-filter>
</activity>
```

修改 FirstActivity 中 onCreate() 方法：

```java
@Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        //在 onCreate() 方法中打印了当前返回栈的id
        Log.d("FirstActivity", "Task id is " + getTaskId());
        setContentView(R.layout.first_layout);
        Button button1 = (Button) findViewById(R.id.button_1);
        button1.setOnClickListener(new View.OnClickListener(){
            @Override
            public void onClick(View v){
                Intent intent = new Intent(FirstActivity.this, SecondActivity.class);
                startActivity(intent);
            }
        });
    }
```

修改 SecondActivity 中 onCreate() 方法：

```java
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    //同样在 onCreate() 方法中打印了当前返回栈的id
    Log.d("SecondActivity", "Task id is " + getTaskId());
    setContentView(R.layout.second_layout);
    Button button2 = (Button) findViewById(R.id.button_2);
    button2.setOnClickListener(new View.OnClickListener(){
        @Override
        public void onClick(View v){
            //修改按钮点击事件的代码，用于启动 ThidActivity
            Intent intent = new Intent(SecondActivity.this, ThirdActivity.class);
            startActivity(intent);
        }
    });
}
```

修改 ThirdActivity 中 onCreate() 方法：

```java
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    //同样在 onCrete() 方法中打印了当前返回栈的id
    Log.d("ThirdActivity", "Task id is " + getTaskId());
    setContentView(R.layout.third_layout);
}
```

重新进入程序，在 FirstActivity 界面点击按钮进入到 SecondActivity，然后在 SecondActivity 界面点击按钮进入到 ThirdActivity

可以看到，SecondActivity 的 Task id 确实不同于 FirstActivity 和 ThirdActivity，这说明 SecondActivity 确实存放在一个单独的返回栈里， 而且这个栈只有 SecondActivity 这一个活动

按下 Back 键返回，ThirdActivity 直接返回到了 FirstActivity，再按 Back 键返回到 SecondActivity，最后再按 Back 键退出程序，即在 FirstActivity、ThirdActivity 返回栈中退到返回栈无栈顶活动，则会跳转显示另一个返回栈中的栈顶活动



### 知晓当前是在哪一个活动

在包右击新建一个 Java Class 命名为 BaseActivity，注意这里的 BaseActivity 和普通活动的创建方式不一样，因为我们不需让 BaseActivity 在 AndroidManifest.xml 中注册，所以创建一个普通的 Java 类可以了，然后再让 BaseActivity 继承自 AppCompatActivity，并重写 onCreate() 方法

```java
public class BaseActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState){
        super.onCreate(savedInstanceState);
        Log.d("BaseActivity", getClass().getSimpleName());
    }
}
```

接下来让项目中的其他 Activity 都继承自 BaseActivity，由于 BaseActivity 继承自 AppCompatActivity，所以所有继承自 BaseActivity 的 Activity 现有功能并不受影响，它们仍然完全继承了 Activity 中的所有特性

现在每当我们进入到一个活动的界面，该活动的类名就会被打印出来，这样我们就可以知晓当前界面对应的是哪一个活动了



### 随时随地退出程序

如果手机停留在 ThirdActivity，需要点击3次 Back 键才会退出程序，按 Home 键只是把程序挂起，并没有退出程序。一个注销或者退出的功能只需要用一个专门的集合类对所有的活动进行管理就好了

新建一个 ActivityCollector 类作为活动管理器

```java
public class ActivityCollector {
    //通过 List 来暂存活动
    public static List<Activity> activities = new ArrayList<>();
	
    //提供了一个 addActivity() 方法用于向 List 中添加一个活动
    public static void addActivity(Activity activity){
        activities.add(activity);
    }

    //提供了一个 removeActivity() 方法用于从 List 中移出活动
    public static void removeActivity(Activity activity){
        activities.remove(activity);
    }

    //提供一个 finishAll() 方法用于将 List 中存储的活动全部销毁掉
    public static void finishAll(){
        for(Activity activity : activities){
            if(!activity.isFinishing()){
                activity.finish();
            }
        }
        activities.clear();
    }
}
```

修改 BaseActivity 中的代码

```java
public class BaseActivity extends AppCompatActivity {
    //调用了 addActivity() 方法，表明将当前正在创建的活动添加到活动管理器里
    @Override
    protected void onCreate(Bundle savedInstanceState){
        super.onCreate(savedInstanceState);
        Log.d("BaseActivity", getClass().getSimpleName());
        ActivityCollector.addActivity(this);
    }
    //重写 onDestroy() 方法，并调用 ActivityCollection 的 removeActivity() 方法，表明将一个马上要销毁的活动从活动管理器里移除
    @Override
    protected void onDestory(){
        super.onDestroy();
        ActivityCollector.removeActivity(this);
    }
}
```

从此以后，不管你想在什么地方退出程序，只需要调用 ActivityCollector.finishAll() 方法就可以了

例如在 ThirdActivity 界面想通过点击按钮直接退出程序，只需要将代码改成

```java
public class ThirdActivity extends BaseActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Log.d("ThirdActivity", "Task id is " + getTaskId());
        setContentView(R.layout.third_layout);
        Button button3 = (Button) findViewById(R.id.button_3);
        button3.setOnClickListener(new View.OnClickListener(){
            @Override
            public void onClick(View v){
                ActivityCollector.finishAll();
            }
        });
    }
}
```

当然你还可以在销毁活动的代码后面再加上杀掉当前进程的代码，以保证程序完全退出，杀掉进程的代码如下：

```java
android.os.Process.killProcess(android.os.Process.myPid());
```

killProcess() 方法用于杀掉一个进程，他接受一个进程 id 参数，我们可以通过 myPid() 方法来获得当前程序的进程 id，需注意的是，killProcess() 方法只能用于杀掉当前程序的进程，而我们不能使用这个方法去杀掉其他程序



### 启动活动的最佳写法

启动活动的方法，首先通过 Intent 构建当前的“意图”，然后调用 startActivity() 或 startActivityForResult() 方法将活动启动起来，如果有数据需要从一个活动弄传递到另一个活动，也可以借助 Intent 来完成

假设 SecondActivity 中需要用到两个非常重要的字符串参数，在启动 SecondActivity 的时候必须要传递过来

```java
Intent intent = new Intent(FirstActivity..this, SecondActivity.class);
intent.putExtra("param1", "data1");
intent.putExtra("param2", "data2");
startActivity(intent);
```

这样写是完全正确的，不管是语法上还是规范上，有个问题就是 SecondActivity 并不是有你开发的，但现在你负责的部分需要有启动 SecondActivity 这个功能，而你却不清楚启动这个活动需要传递哪些数据 ，这是有两种方法，意识你自己去阅读 SecondActivity 中的代码，而是询问负责编写 SecondActivity 的同事，很麻烦

修改 SecondActivity 中的代码就可以轻松解决上面的窘境

```java
public class SecondActivity extents BaseActivity{
    public static void actionStart(Context context, String data1, String data2){
        Intent intent = new Intent(context, SecondActivity.class);
        intent.putExtra("param1", "data1");
        intent.putExtra("param2", "data2");
        startActivity(intent);
    }
    ......
}
```

在这个方法中完成了 Intent 的构建，另外所有 SecondActivity 中需要的数据都是通过 actionStart() 方法的参数传递过来的，然后把它们存储到 Intent 中，最后调用 startActivity() 方法启动 Second

这样写的好处是一目了然， SecondActivity 所需要的数据在方法参数中全部体现出来了，你可以非常清晰地知道启动 SecondActivity 需要传递哪些数据，另外，这样写还简化了启动活动的代码，现在只需要一行代码就可以启动 SecondActivity

```java
button1.setOnClickListener(new View.OnClickListener(){
    @Override
    public void onClick(View v){
		SecondActivity.actionStart(FirstActicity.this, "data1", "data2");
	}
});
```





## 常用控件

Android 控件的使用规律，用法基本上都很相似：给控件定义一个 id，在指定控件的宽度和高度，然后再适当加入一些控件特有的属性就差不多了



### TextView

它主要用于在界面上显示一段文本信息

```java
//指定文字的对齐方式
android:gravity
//指定文字的大小（Android 中字体大小使用 sp 作为单位）
android:textSize
//指定文字的颜色
android:textColor
```



### Button

```java
//系统会对 Button 中的所有英文字母自动进行大写转换
android:text
//可以使用以下配置来禁用这一默认特性
android:textAllCaps
```

接下来我们可以 MAinActivity 中为 Button 的点击事件注册一个监听器

```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button = (Button) findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener(){
           public void onClick(View v){
               //在此处添加逻辑
           } 
        });
    }
}
```

每当点击按钮式，就会执行监听器中的 onClick() 方法，我么你只需要在这个方法中加入待处理的逻辑就行了，如果不喜欢匿名内部类的方式来注册监听器，也可以使用实现接口的方式来进行注册

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener{

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button = (Button) findViewById(R.id.button);
        button.setOnClickListener(this);
    }
    @Override
    public void onClick(View v){
        switch (v.getId()){
            case R.id.button:
                //在此处添加逻辑
                break;
            default;
                break;
        }
    }
}
```



### EditText

它允许用户在控件例输入和编辑内容，并可以砸程序中对这些内容进行处理

```java
//使用了 android:hint 属性指定了一段提示性的文本，当用户输入了任何内容，这些提示性的文字就会消失
android:hint
//通过 android:maxLines 指定了 EditText 的最大行数为两行，这样单输入的内容超过两行是，文本就会向上滚动，而 EditText 则不会再继续拉伸
android:maxLines="2"
```

结合使用 EditText 也 Button 来完成一些功能，修改 MainActivity 中的代码

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener{

    private EditText editText;
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button = (Button) findViewById(R.id.button);
        //通过 findCiewById() 方法得到 EditText 的实例
        editText = (EditText) findViewById(R.id.edit_text); 
        button.setOnClickListener(this);
    }
    @Override
    public void onClick(View v){
        switch (v.getId()){
            case R.id.button:
                //在按钮的点击事件里调用 EditText 的 getText() 方法获取到输入的内容，再调用 toString() 方法转换成字符串，最后还是老方法使用 Toast 将输入的内容显示出来
                String inputText = editText.getText().toString();
                Toast.makeText(MainActivity.this, inputText,
                        Toast.LENGTH_SHORT).show();
                break;
            default:
                break;
        }
    }
}
```



### ImageView

ImageView 是用于在界面上展示图片的一个控件，它可以让我们的程序界面变得更加丰富多彩

```java
//给 ImageView 指定一张图片
android:src
```

修改 MainActivity 的代码

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener{

    private EditText editText;

    private ImageView imageView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button = (Button) findViewById(R.id.button);
        editText = (EditText) findViewById(R.id.edit_text);
        imageView = (ImageView) findViewById(R.id.image_view);
        button.setOnClickListener(this);
    }
    @Override
    public void onClick(View v){
        switch (v.getId()){
            case R.id.button:
                //在点击按钮事件里，通过调用 ImageView 的 setImageResource() 方法将显示的图片改成 img_2
                imageView.setImageResource(R.drawable.img_2);
                String inputText = editText.getText().toString();
                Toast.makeText(MainActivity.this, inputText,
                        Toast.LENGTH_SHORT).show();
                break;
            default:
                break;
        }
    }
}
```



### ProgressBar

ProgressBar 用于在界面上显示一个进度条，表示我们的程序正在加载一些数据



Android 控件的可见属性，所有的 Android 控件都有这个属性，可以通过 android:visibility 进行制定，可选值有3种：

- visible（表示控件是可见的，这个只是默认值，不指定 android:visibility 时，控件都是可见的）
- invisible（表示控件不可见的，但是它仍然占据着原来的位置和大小，可以理解成控件编程透明状态了） 
- gone（表示控件不仅不可见，而且不再占用任何屏幕空间）
- 此外还可以通过代码来设置控件的可见性，使用 setVisibililty() 方法，可以传入 View.VISIBLE、View.INVISIBLE 和 View.GONE 这三种值



修改 MAinActivity 中的代码

```JAVA
public class MainActivity extends AppCompatActivity implements View.OnClickListener{

    private EditText editText;

    private ImageView imageView;
    
    private ProgressBar progressBar;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button = (Button) findViewById(R.id.button);
        editText = (EditText) findViewById(R.id.edit_text);
        imageView = (ImageView) findViewById(R.id.image_view);
        progressBar = (ProgressBar) findViewById(R.id.progress_bar); 
        button.setOnClickListener(this);
    }
    @Override
    public void onClick(View v){
        switch (v.getId()){
            case R.id.button:
                //通过 getVisibility() 方法来判断 ProgressBar 是否可见，如果可见就将 ProgressBar 隐藏掉，如果不可见就将 ProgressBar 显示出来
                if(progressBar.getVisibility() == View.GONE){
                    progressBar.setVisibility(View.VISIBLE);
                }else{
                    progressBar.setVisibility(View.GONE);
                }
                break;
            default:
                break;
        }
    }
}
```

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

......

    <ProgressBar
        android:id="@+id/progress_bar"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        //通过 style 属性可以将它指定成水平进度条
        style="?android:attr/progressBarStyleHorizontal"
        //通过 android:max 属性给进度条设置一个最大值
        android:max="100"/>
</LinearLayout>
```

修改 MainActivity 中的代码

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener{
    
......
    
    @Override
    public void onClick(View v){
        switch (v.getId()){
            case R.id.button:
                //在代码中动态地更改进度条的进度
                int progress = progressBar.getProgress();
                progress = progress + 10;
                progressBar.setProgress(progress);
                break;
            default:
                break;
        }
    }
}

```



### AlertDialog

AlertDialog 可以在当前的界面弹出一个对话框，这个对话框是置顶于所有界面元素之上的，能够屏蔽掉其他控件的交互能力，因此 AlertDialog 一般都是用于提示一些非常重要的内容或者警告信息

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener{

......
    
    @Override
    public void onClick(View v){
        switch (v.getId()){
            case R.id.button:
                //通过 AlertDialog.Builder 创建一个 AlertDialog 的实例，然后为这个对话框设置标题、内容、可否用 Back 键关闭对话框等属性
                AlertDialog.Builder dialog = new AlertDialog.Builder(MainActivity.this);
                dialog.setTitle("This is Dialog");
                dialog.setMessage("Something important.");
                dialog.setCancelable(false);
                //为对话框设置确定按钮的点击事件
                dialog.setPositiveButton("OK", new DialogInterface.OnClickListener(){
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                    }
                });
                //设置取消按钮的点击事件
                dialog.setNegativeButton("Cancel", new DialogInterface.OnClickListener(){
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                    }
                });
                //将对话框显示出来
                dialog.show();
                break;
            default:
                break;
        }
    }
}
```



### ProgressDialog

ProgressDialog 和 AlertDialog 有点类似，都可以在界面上弹出一个对话框，都能够屏蔽其他控件的交互能力，不同的是，ProgressDialog 会在对话框中显示一个进度条，一般用于表示当前操作比较耗时，让用户耐心的地等待

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener{

......

    @Override
    public void onClick(View v){
        switch (v.getId()){
            case R.id.button:
                //构建一个 ProgressDialog 对象
                ProgressDialog progressDialog = new ProgressDialog(MainActivity.this);
                //设置标题属性
                progressDialog.setTitle("This is progressDialog");
                //设置内容属性
                progressDialog.setMessage("Loading...");、
                //可否取消属性，如果传入 false 则表示 ProgressDialog 是不能通过 Back 键取消掉的，这时需要代码中做好控制，当数据加载完成后必须要调用 ProgressDialog 的 dismisss() 方法来关闭对话框，否则 ProgressDialog 将会一直存在
                progressDialog.setCancelable(true);
                //调用 show() 方法将 ProgresDialog 显示出来
                progressDialog.show();
                break;
            default:
                break;
        }
    }
}
```



### ListView

ListView 允许用户通过手指上下滑动的方式将屏幕外的数据滚动到屏幕内，同时屏幕上原有的数据则会滚动出屏幕



#### ListView 的简单用法

新建一个 ListViewTest 项目，然后修改 activity_main.xml 中的代码

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <ListView
    	//为 ListView 指定一个 id
        android:id="@+id/list_view"
        //指定宽度都为 match_parent 这样 ListView 就占满了整个布局的空间
        android:layout_width="match_parent"
        android:layout_height="match_parent" />
</LinearLayout>
```

修改 MainActivity 中的代码

```java
public class MainActivity extends AppCompatActivity {

    private String[] data = {"Apple", "Banana", "Orange", "Watermelon",
        "Pear", "Grape", "Pineapple", "Strawberry", "Cherry", "Mango",
        "Apple", "Banana", "Orange", "Watermelon", "Pear", "Grape",
        "Pineapple", "Strawberry", "Cherry", "Mango"};
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        //数组中的数据无法直接传给 ListView，需要借助适配器来完成
        // Android 提供了很多适配器的实现类，ArrayAdapter 可以通过泛型指定要适配的数据类型，然后在构造函数中把要适配的数据传入，ArrayAdapter 有多个构造函数的重载，应根据实际情况选择合适的一种
        //这里将 ArrayAdapter 的泛型指定为 String，然后在 ArrayAdapter 的构造函数中依次传入当前上下文、ListView 子项布局的 id 以及要适配的数据
        //注意，这里使用了 android.R.layout.simple_list_item_1 作为 ListView 子项布局的 id，这是一个 Android 内置的布局文件，里面只有一个 TextView，可用于简单地显示一段文本
        ArrayAdapter<String> adapter = new ArrayAdapter<String>(
                MainActivity.this, android.R.layout.simple_list_item_1, data);
        ListView listView = (ListView) findViewById(R.id.list_view);
        //将构建好的适配器对象传递进去，这样 ListView 和数据之间的关联就建立了
        listView.setAdapter(adapter);
    }
}
```



#### 定制 ListView 界面

显示一段文本的 ListView 内容太过单调，现在对 ListView 的界面进行定制，让它可以显示更加丰富的内容

新建类 Fruit

```java
public class Fruit {
    //name 表示水果的名字
    private String name;
    //iamgeId 表示水果对应图片的资源 id
    private int imageId;
    public Fruit(String name, int imageId){
        this.name = name;
        this.imageId = imageId;
    }
    public String getName(){
        return name;
    }
    public int getImageId(){
        return imageId;
    }
}
```

对 ListView 子项指定一个我们自定义的布局，在 layout 目录下新建 fruit_item.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content">

    //定义一个 ImageView 用于显示水果的图片
    <ImageView
        android:id="@+id/fruit_image"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" />
    
    //定义一个 TextView 用于显示水果的名字
    <TextView
        android:id="@+id/fruit_name"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        //让 TextView 垂直方向上居中显示
        android:layout_gravity="center_vertical"
        android:layout_marginLeft="10dp" />
</LinearLayout>
```

创建一个自定义的适配器，这个适配器继承自 ArrayAdapter，并将泛型指定为 Fruit 类，新建类 FruitAdapter

```java
// FruitAdapter 重写了父类的一组构造函数，用于将上下文、ListView 子项布局的 id 和数据都传递进来
public class FruitAdapter extends ArrayAdapter<Fruit>{
    private int resourceId;
    public FruitAdapter(Context context, int textViewResourceId, List<Fruit> objects){
        super(context, textViewResourceId, objects);
        resourceId = textViewResourceId;
    }
    //重写了 getView() 方法，这个方法在每个子项被滚动到屏幕内的时候会被调用
    @Override
    public View getView(int position, View convertView, ViewGroup parent){
        //通过 getItem() 方法得到当前项的 Fruit 实例，然后使用 LayoutInflater 来作为这个子项加载我们传入的布局
        Fruit fruit = getItem(position);//获取当前项的 Fruit 实例
        //LayoutInflater 的 inflate() 方法接收3个参数，第三个参数指定成 false，表示只让我们在父布局中声明的 layout 属性生效，但不会为这个 View 添加父布局，因为一旦 View 有了父布局之后，它就不能再添加到 ListView 中了
        View view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false);
        //调用 View 的 findViewById() 方法分别获取到 ImageView 和 TextView 的实例，并分别调用它们的 setImageResource() 和 setText() 方法来设置显示的图片和文字，最后将布局返回，这样自定义的适配器就完成了
        ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image);
        TextView fruitName = (TextView) view.findViewById(R.id.fruit_name);
        fruitImage.setImageResource(fruit.getImageId());
        fruitName.setText(fruit.getName());
        return view;
    }
}
```

修改 MainActivity 中的代码

```java
public class MainActivity extends AppCompatActivity {

    private List<Fruit> fruitList = new ArrayList<>();
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initFruits();
        //在 onCreate() 方法中创建了 FruitAdapter 对象，并将 FruitAdapter 作为适配器传递给 ListView
        FruitAdapter adapter = new FruitAdapter(MainActivity.this, R.layout.fruit_item, fruitList);
        ListView listView = (ListView) findViewById(R.id.list_view);
        listView.setAdapter(adapter);
    }
    //添加了一个 initFruit() 方法，用于初始化所有的水果数据
    private void initFruits(){
        //在 Fruit 类中的构造函数中将水果的名字和对应的图片 id 传入，然后把创建好的对象添加到水果列表中，另外我们使用了一个 for 循环将所有的水果都添加了两遍，这是因为如果只添加一边的话，数据量还不足以充满整个屏幕
        for(int i = 0; i < 2; i++){
            Fruit apple = new Fruit("Apple", R.drawable.apple_pic);
            fruitList.add(apple);
            Fruit banana = new Fruit("Banana", R.drawable.banana_pic);
            fruitList.add(banana);
            Fruit orange = new Fruit("Orange", R.drawable.orange_pic);
            fruitList.add(orange);
            Fruit watermelon = new Fruit("Watermelon", R.drawable.watermelon_pic);
            fruitList.add(watermelon);
            Fruit pear = new Fruit("Pear", R.drawable.pear_pic);
            fruitList.add(pear);
            Fruit grape = new Fruit("Grape", R.drawable.grape_pic);
            fruitList.add(grape);
            Fruit pineapple = new Fruit("Pineapple", R.drawable.pineapple_pic);
            fruitList.add(pineapple);
            Fruit strawberry = new Fruit("Strawberry", R.drawable.strawberry_pic);
            fruitList.add(strawberry);
            Fruit cherry = new Fruit("Cherry", R.drawable.cherry_pic);
            fruitList.add(cherry);
            Fruit mango = new Fruit("Mango", R.drawable.mango_pic);
            fruitList.add(mango);
        }
    }
}
```

定制 ListView 界面的任务就完成了，只要修改 fruit_item.xml 中的内容，就可以定制出各种复杂的界面





#### 提升 ListView 的运行效率

在 FruitAdapter 的 getView() 方法中，每次都将布局重新加载了一遍，当 ListView 快速滚动的时候，这就会成为性能的瓶颈

getView() 方法中还有一个 convertView 参数，这个参数用于将之前加载好的布局进行缓存，以便之后可以进行重用

修改 FruitAdapter 中的代码

```java
public class FruitAdapter extends ArrayAdapter<Fruit>{
    private int resourceId;
    public FruitAdapter(Context context, int textViewResourceId, List<Fruit> objects){
        super(context, textViewResourceId, objects);
        resourceId = textViewResourceId;
    }
    @Override
    public View getView(int position, View convertView, ViewGroup parent){
        Fruit fruit = getItem(position);//获取当前项的 Fruit 实例
        //在 getView() 方法中进行了判断，如果 convertView 为 null，则使用 LayoutInflater 去加载布局，如果不为 null 则直接对 convertView 进行重用
        View view;
        if(convertView == null) {
            view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false);
        }else{
            view = convertView;
        }
        ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image);
        TextView fruitName = (TextView) view.findViewById(R.id.fruit_name);
        fruitImage.setImageResource(fruit.getImageId());
        fruitName.setText(fruit.getName());
        return view;
    }
}
```

现在已经不会再重复加载布局，但是每次在 getView() 方法还是会调用 View 的 findViewById() 方法来获取一次控件的实例，我们可以借助一个 ViewHolder 来对这部分性能进行优化

修改 FruitAdapter 中的代码

```java
public class FruitAdapter extends ArrayAdapter<Fruit>{
    private int resourceId;
    
    public FruitAdapter(Context context, int textViewResourceId, List<Fruit> objects){
        super(context, textViewResourceId, objects);
        resourceId = textViewResourceId;
    }
    
    class ViewHolder{
        ImageView fruitImage;
        TextView fruitName;
    }
    
    @Override
    public View getView(int position, View convertView, ViewGroup parent){
        Fruit fruit = getItem(position);//获取当前项的 Fruit 实例
        View view;
        //新增一个内部类 ViewHolder，用于对控件的实例进行缓存
        ViewHolder viewHolder;
        //当 convertView 为 null 时，创建一个 ViewHolder 对象，并将控件的实例都存放在 ViewHolder 里，然后调用 View 的 setTag() 的方法，将 ViewHolder 对象存储在 View 中
        if(convertView == null) {
            view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false);
            viewHolder = new ViewHolder();
            viewHolder.fruitImage = (ImageView) view.findViewById(R.id.fruit_image);
            viewHolder.fruitName = (TextView) view.findViewById(R.id.fruit_name);
            view.setTag(viewHolder);//将 ViewHolder 存储在 View 中
        }else{
            //当 convertView 不为 null 时，调用 View 的 getTag() 方法，把 ViewHolder 重新取出
            view = convertView;
            viewHolder = (ViewHolder) view.getTag();//重新获取 ViewHolder
        }
        viewHolder.fruitImage.setImageResource(fruit.getImageId());
        viewHolder.fruitName.setText(fruit.getName());
        return view;
    }
    
}
```

这样所有控件的实例都缓存在了 ViewHolder 里，就没有必要每次都通过 findViewById() 方法来获取控件的实例了





#### ListView  的点击事件

修改 MAinActivity 中的代码

```java
public class MainActivity extends AppCompatActivity {

    private List<Fruit> fruitList = new ArrayList<>();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initFruits();
        FruitAdapter adapter = new FruitAdapter(MainActivity.this, R.layout.fruit_item, fruitList);
        ListView listView = (ListView) findViewById(R.id.list_view);
        listView.setAdapter(adapter);
        //使用 setOnItemClickListener() 方法为 ListView 注册了一个监听器，当用户点击了 LisView 中的任何一个子项时，就会回调 onItemClick() 方法，该方法中可以通过 position 参数判断出用户点击的是哪一子项，然后获取到相应的水果，并通过 Toast 将水果的名字显示出来
        listView.setOnItemClickListener(new AdapterView.OnItemClickListener(){
            @Override
            public void onItemClick(AdapterView<?> parent, View view, int position, long id){
                Fruit fruit = fruitList.get(position);
                Toast.makeText(MainActivity.this, fruit.getName(), Toast.LENGTH_SHORT).show();
            }
        });
    }
    
    ......
    
}
```





### RecyclerView

ListView 如果不使用一些技巧来提升它的运行效率，那么 ListView 的性能就会非常差，还有 ListView 的拓展性能也不够好，它只能实现数据纵向的滚动效果，如果我们想要实现横向滚动的话，ListView 是做不到的



#### RecyclerView 的基本用法

打开 app/build.gradle 文件

```java
compile 'com.android.support:recyclerview-v7:24.2.1'
```

修改 activity_main.xml 中的代码

```java
//在布局中加入 RecyclerView 控件
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

	//由于 RecyclerView 并不是内置在系统 SDK 当中的，所以需要把完整的包路径写出来
    <android.support.v7.widget.RecyclerView
    	//先为 RecyclerView 指定一个 id
        android:id="@+id/rercycler_view"
        //将宽度高度都设置为 match_parent，这样让 RecyclerView 占满了整个布局空间
        android:layout_width="match_parent"
        android:layout_height="match_parent" />
</LinearLayout>
```

把 ListViewTest 项目中的图片还有 Fruit 类和 fruit_item.xml 复制过来，接下来为 RecyclerView 准备一个适配器，新建 FruitAdapter 类

```java
//新建 FruitAdapter 类，让这个适配器继承自 RecyclerView.Adapter，并将泛型指定为 FruitAdapter.ViewHolder
public class FruitAdapter extends RecyclerView.Adapter<FruitAdapter.ViewHolder> {

    private List<Fruit> mFruitList;
	
    //定义一个内部类，继承自 RecyclerView
    static class ViewHolder extends RecyclerView.ViewHolder{
        ImageView fruitImage;
        TextView fruitName;
		//构造函数中传入一个 View 参数，这个参数通常是 RecyclerView 子项的最外层布局，那么就可以通过 findViewById() 方法来获取到布局中的 ImageView 和 TextView 的实例了
        public ViewHolder(View view){
            super(view);
            fruitImage = (ImageView) view.findViewById(R.id.fruit_image);
            fruitName = (TextView) view.findViewById(R.id.fruit_name);
        }
    }
    
    //把要展示的数据源传进来，并赋值给一个全局变量 mFruitList
    public FruitAdapter(List<Fruit> fruitList){
        mFruitList = fruitList;
    }

    //由于 FruitAdapter 是继承自 RecyclerView.Adapter 的，那么就必须重写 onCreateViewHolder()、onBindViewHolder() 和 getItemCount() 这3个方法
    
    //该方法适用于创建 ViewHolder 实例的，我们在这个方法中将 fruit_item 布局加载进来，然后创建一个 ViewHolder 实例，并把加载出来的布局传入到构造函数当中，最后将 ViewHolder 的实例返回
    @Override
    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fruit_item, parent, false);
        ViewHolder holder = new ViewHolder(view);
        return holder;
    }

    //该方法用于对 RecyclerView 子项的数据进行赋值，会在每个子项被滚动到屏幕内的时候执行，这里通过 position 参数得到当前项的 Fruit 实例，然后再将数据设置到 ViewHolder 的 ImageView 和 TextView 当中即可
    @Override
    public void onBindViewHolder(ViewHolder holder, int position) {
        Fruit fruit = mFruitList.get(position);
        holder.fruitImage.setImageResource(fruit.getImageId());
        holder.fruitName.setText(fruit.getName());
    }

    //该方法用于告诉 RecyclerView 一共有多少子项，直接返回数据的长度
    @Override
    public int getItemCount() {
        return mFruitList.size();
    }
}
```

修改 MainActivity 中的代码

```java
public class MainActivity extends AppCompatActivity {

    private List<Fruit> fruitList = new ArrayList<>();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initFruits();
        //先获取到 RecyclerView 的实例
        RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view);
        //然后创建一个 LinearLayoutManager 对象，并将它设置到 RecyclerView 当中，LayoutManager 用于指定 RecyclerView 的布局方式，这里使用的 LinearLayoutManager 是线性布局的意思，可以实现和 ListView 类似的效果
        LinearLayoutManager layoutManager = new LinearLayoutManager(this);
        recyclerView.setLayoutManager(layoutManager);
        //接下来创建 FruitAdapter 的实例，并将水果数据传入到 FruitAdapter 的构造函数中
        FruitAdapter adapter = new FruitAdapter(fruitList);
        //最后调用 RecyclerView 的 setAdapter() 方法来完成适配器设置，这样 RecyclerView 和数据之间的关联就建立完成了
        recyclerView.setAdapter(adapter);
    }
    
    //使用一个同样的 initFruit() 方法，用于初始化所有的水果数据
    private void initFruits(){
        for(int i = 0; i < 2; i++){
            Fruit apple = new Fruit("Apple", R.drawable.apple_pic);
            fruitList.add(apple);
            Fruit banana = new Fruit("Banana", R.drawable.banana_pic);
            fruitList.add(banana);
            Fruit orange = new Fruit("Orange", R.drawable.orange_pic);
            fruitList.add(orange);
            Fruit watermelon = new Fruit("Watermelon", R.drawable.watermelon_pic);
            fruitList.add(watermelon);
            Fruit pear = new Fruit("Pear", R.drawable.pear_pic);
            fruitList.add(pear);
            Fruit grape = new Fruit("Grape", R.drawable.grape_pic);
            fruitList.add(grape);
            Fruit pineapple = new Fruit("Pineapple", R.drawable.pineapple_pic);
            fruitList.add(pineapple);
            Fruit strawberry = new Fruit("Strawberry", R.drawable.strawberry_pic);
            fruitList.add(strawberry);
            Fruit cherry = new Fruit("Cherry", R.drawable.cherry_pic);
            fruitList.add(cherry);
            Fruit mango = new Fruit("Mango", R.drawable.mango_pic);
            fruitList.add(mango);
        }
    }
}
```



#### 实现横向滚动和瀑布流布局

修改 MainActivity 中的代码

```java
public class MainActivity extends AppCompatActivity {

    private List<Fruit> fruitList = new ArrayList<>();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initFruits();
        RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view);
        LinearLayoutManager layoutManager = new LinearLayoutManager(this);
        //调用 LinearLayoutManager 的 setOrientation() 方法来设置布局的排列方向，默认是纵向排列的，传入 LinearLayoutManager.HROIZONTAL 表示让布局横行排列，这样 RecyclerView 就可以横向滚动了
        layoutManager.setOrientation(LinearLayoutManager.HORIZONTAL);
        recyclerView.setLayoutManager(layoutManager);
        FruitAdapter adapter = new FruitAdapter(fruitList);
        recyclerView.setAdapter(adapter);
    }
	...
}
```

ListView 的布局排列是由自身去管理的，而 RecyclerView 则将这个工作交给了 LayoutManager，LayoutManager 中定制了一套可扩展的布局排列接口，子类只要按照接口的规范来实现，就能定制出各种不同排列方式的布局了

除了 LinearLayoutManager 之外，RecyclerView 还给我们提供了 GridLayoutManager 和 StaggeredGridLayoutManager 这两种内置的布局排列方式，GridLayoutManager 可以用于实现网格布局，StaggeredGridLayoutManager 可以用于实现瀑布流布局

瀑布流布局需要各个子项的高度不一致才能看出明显的效果，修改 MainActivity 中的代码

```java
public class MainActivity extends AppCompatActivity {

    private List<Fruit> fruitList = new ArrayList<>();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initFruits();
        RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view);
        //在 onCreate() 方法中创建了一个 StaggeredGridLayout 的实例，StaggeredGridLayout 的构造函数接受两个参数，第一个参数用于指定布局的列数，传入3表示会把布局分为3列；第二个参数用于指定布局的排列方向，传入 StaggeredGridLayout.VERTICAL 表示会让布局纵向排列
        StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager(3, StaggeredGridLayoutManager.VERTICAL);
        //最后把创建好的实例设置到 RecyclerView 中就可以了
        recyclerView.setLayoutManager(layoutManager);
        FruitAdapter adapter = new FruitAdapter(fruitList);
        recyclerView.setAdapter(adapter);
    }

    private void initFruits(){
        for(int i = 0; i < 2; i++){
            //子项中每个水果的名字都改成调用 getRandomLengthName() 这个方法来生成，这样就能保证各水果名字的长短差距比较大，子项的高度也就各不相同
            Fruit apple = new Fruit(getRandomLengthName("Apple"), R.drawable.apple_pic);
            fruitList.add(apple);
            Fruit banana = new Fruit(getRandomLengthName("Banana"), R.drawable.banana_pic);
            fruitList.add(banana);
            Fruit orange = new Fruit(getRandomLengthName("Orange"), R.drawable.orange_pic);
            fruitList.add(orange);
            Fruit watermelon = new Fruit(getRandomLengthName("Watermelon"), R.drawable.watermelon_pic);
            fruitList.add(watermelon);
            Fruit pear = new Fruit(getRandomLengthName("Pear"), R.drawable.pear_pic);
            fruitList.add(pear);
            Fruit grape = new Fruit(getRandomLengthName("Grape"), R.drawable.grape_pic);
            fruitList.add(grape);
            Fruit pineapple = new Fruit(getRandomLengthName("Pineapple"), R.drawable.pineapple_pic);
            fruitList.add(pineapple);
            Fruit strawberry = new Fruit(getRandomLengthName("Strawberry"), R.drawable.strawberry_pic);
            fruitList.add(strawberry);
            Fruit cherry = new Fruit(getRandomLengthName("Cherry"), R.drawable.cherry_pic);
            fruitList.add(cherry);
            Fruit mango = new Fruit(getRandomLengthName("Mango"), R.drawable.mango_pic);
            fruitList.add(mango);
        }
    }
    
    //该方法使用了 Random 对象来创造一个1~20之间的随机数，然后将参数中传入的字符串随机重复几遍
    private String getRandomLengthName(String name){
        Random random = new Random();
        int length = random.nextInt(20) + 1;
        StringBuilder builder = new StringBuilder();
        for(int i = 0; i < length; i++){
            builder.append(name);
        }
        return builder.toString();
    }
}
```



#### RecyclerView 的点击事件

修改 FruitAdapter 中的代码

```java
public class FruitAdapter extends RecyclerView.Adapter<FruitAdapter.ViewHolder> {

    private List<Fruit> mFruitList;

    static class ViewHolder extends RecyclerView.ViewHolder{
        //在 ViewHolder 中添加了 fruitView 变量来保存子项最外层布局的实例
        View fruitView;
        ImageView fruitImage;
        TextView fruitName;

        public ViewHolder(View view){
            super(view);
            fruitView = view;
            fruitImage = (ImageView) view.findViewById(R.id.fruit_image);
            fruitName = (TextView) view.findViewById(R.id.fruit_name);
        }
    }

    //在 onCreateViewHolder() 方法中注册点击事件，这里分别为最外层布局和 ImageView 都注册了点击事件
    @Override
    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fruit_item, parent, false);
        //在两个点击事件中先获取了用户点击的 position，然后通过 position 拿到相应的 Fruit 实例，再使用Toast 分别弹出两种不同的内容以示区别
        final ViewHolder holder = new ViewHolder(view);
        holder.fruitView.setOnClickListener(new View.OnClickListener(){
            @Override
            public void onClick(View v){
                int position = holder.getAdapterPosition();
                Fruit fruit = mFruitList.get(position);
                Toast.makeText(v.getContext(), "you clicked view" + fruit.getName(), Toast.LENGTH_SHORT).show();
            }
        });
        holder.fruitImage.setOnClickListener(new View.OnClickListener(){
            @Override
            public void onClick(View v){
                int position = holder.getAdapterPosition();
                Fruit fruit = mFruitList.get(position);
                Toast.makeText(v.getContext(), "you clicked image" + fruit.getName(), Toast.LENGTH_SHORT).show();
            }
        });
        return holder;
    }

    ...
        
}
```

由于 TextView 并没有注册点击事件，因此点击文字这个事件会被最外层布局捕获到



```java
//注意！！！数据有更新的时候需要通知适配器刷新显示

//调用了适配器的 notifyItemInserted() 方法，用于通知列表有新的数据插入，这样新增的一条消息才能够在 RecyclerView 中显示
adapter.notifyItemInserted(msgList.size() - 1);//当有新消息时，刷新 RecyclerView 中的而显示

//调用 notifyDataSetChanged() 方法通知适配器数据已经更改
adapter.notifyDataSetChanged();
                    
//调用 scrollToPosion() 方法将显示的数据定位到最后一行，以保证一定可以看到最后发出的一条消息
 msgRecyclerView.scrollToPosition(msgList.size() - 1);//将 RecyclerView 定位到最后一行
```







## 四种布局

布局是一种可用于放置很多控件的容器，它可以按照一定的规律调整内部控件的位置，从而编写出精美的界面，当然布局的内部也可以放置布局，通过多层布局的嵌套就能够完成一些比较复杂的界面实现





### LinearLayout（线性布局）

LinearLayout 又称线性布局，这个布局会将他所包含的控件在线性方向上依次排列

```java
//将 android:orientation 属性值改成了 horizontal，这就意味着要让 LinearLayout 中的控件在水平方向上依次排列
//如果不指定 android:orientation 属性的值，默认的排列方式就是 horizontal
//注意：如果 LinearLayout 的排列方式是 horizontal，内部的控件就绝对不能将宽度指定为 match_parent，因为这样的话单独一个控件就会将整个水平方向占满了，其他的控件就没有可放的位置。同样，如果 LinearLayout 的排列方向是 vertical，内部的控件就不能将高度指定为 match_parent
android:orientation="horizontal"
    

//用于指定文字在控件中的对齐方式
android:gravity


//用于指定控件在布局中的对齐方式
//注意：LinearLayout 的排列方向是 horizontal 时，只有垂直方向上的对齐方式才会生效，因为此时水平方向上的长度是不固定的，每添加一个控件，水平方向上的长度都会改变，因而无法指定该方向上的对齐方式，同理，当 LinearLayout 的排列方向是 vertical 时，只有水平方向上的对齐方式才会生效
android:layout_gravity


//系统会先把 LinearLayout 下所有控件指定的 layout_weight 值相加，得到一个总值，然后每个控件所占大小的比例就是用该控件的 layout_weight 值除以刚才算出的总值
//LinearLayout 特有！！！
android:layout_weight
```





### RelativiLayout（相对布局）

RelativiLayout 又称作相对布局，它可以通过相对定位的方式让控件出现在布局的任何位置

```java
//相对布局定位属性
android:layout_alignParentTop
android:layout_alignParentLeft
android:layout_alignParentRight
android:layout_centerInParent
android:layout_alignParentBottom

//让一个控件位于另一个控件的上方，即 Button 3 的上方
android:layout_above="@id/button3"
    
//让一个控件位于另一个控件的右侧
android:layout_toRightOf="@id/button3"

//让一个控件位于另一个控件的左侧
android:layout_toLeftOf="@id/button3"
    
//让一个控件位于另一个控件的下方
android:layout_below="@id/button3"
```

注意：当一个控件去引用另一个控件的 id 时，该控件一定要定义在引用控件的后面，不然会出现找不到 id 的情况

RelativeLayout 中还有另外一组相对于控件进行定位的属性，android:layout_alignLeft 表示一个控件的左边缘和另一个控件的左边缘对齐，android:layout_alignRight 表示让一个控件的右边缘和另一个控件的右边缘对齐





### FrameLayout（帧布局）

FrameLayout 又称作帧布局，这种布局没有方便的定位方式，所有的控件都会默认摆放在布局的左上角

后面设计的控件会把前面设计的控件覆盖

除了默认效果之外，还可以使用 layout_gravity 属性来指定控件在布局中的对齐方式，这和 LinearLayout 中的用法相似





### 百分比布局

前面 3 种布局都是从 Android 1.0 版本中就开始支持了，其中只有 LinearLayout 支持使用 layout_weight 属性来实现按比例指定控件大小的功能，其他两种布局都不支持。比如说，如果想用 RelativeLayout 来实现让两个按钮平分布局宽度的效果，则是比较困难的

为此，Android 引入了一种全新的布局方式来解决此问题 —— 百分比布局。在这种布局中，我们可以不再使用 wrap_content、match_parent 等方式来指定控件的大小，而是允许直接指定控件在布局中所占的比例，这样就可以轻松实现平分布局甚至是任意比例分割布局的效果了

由于 LinearLayout 本身已经支持按比例指定控件的大小了，因此百分比布局只为 FrameLayout 和 RelativeLayout 进行了功能扩展功能，提供了 PercentFrameLayout 和 PercentRelativeLayout 这两个全新的布局

不同于其前3种布局，百分不布局属于新增布局，为了让新增布局在所有 Android 版本上都能使用，Android 团队将百分比布局定义在了 support 库当中，我们只需要在项目的 build.gradle 中添加百分比布局库的依赖，就能保证百分比布局在 Android 所有系统版本上的兼容性

打开 app/build.gradle，在 dependencies 闭包中添加

```java
compile 'com.android.support:percent:24.2.1'
```

```java
//最外层使用了 PercentFrameLayout，由于百分比布局并不是内置在系统 SDK 当中的，所以需要把完整的包路径写出来，然后还必须定义一个 app 的命名空间，这样才能使用百分比布局的自定义属性
<android.support.percent.PercentFrameLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

//所用 app 前缀的属性就是因为刚才定义了 app 的命名空间，我们一直使用的 android 前缀的属性也是同样的道理
    <Button
        android:id="@+id/button1"
        android:text="Button 1"
        android:layout_gravity="left|top"
        //将各按钮的宽度指定为布局的50%
        app:layout_widthPercent="50%"
        //将各按钮的高度指定为布局的50%
        app:layout_heightPercent="50%"
        />
            
    <Button
        android:id="@+id/button2"
        android:text="Button 2"
        android:layout_gravity="right|top"
        app:layout_widthPercent="50%"
        app:layout_heightPercent="50%"
        />
            
    <Button
        android:id="@+id/button3"
        android:text="Button 3"
        android:layout_gravity="left|bottom"
        app:layout_widthPercent="50%"
        app:layout_heightPercent="50%"
        />
            
    <Button
        android:id="@+id/button4"
        android:text="Button 4"
        android:layout_gravity="right|bottom"
        app:layout_widthPercent="50%"
        app:layout_heightPercent="50%"
        />
            
</android.support.percent.PercentFrameLayout>
```





## 自定义控件

![](E:\Android笔记\第三章笔记图片\微信图片_20181015213153.jpg)

我们所用的所有控件都是直接或间接继承自 View 的，所用的所有布局都是直接或间接继承自 ViewGroup 的，View 是 Android 中最基本的一种 UI 控件，它可以在屏幕上绘制一块矩形区域，并能响应这块区域的各种事件，因此，我们使用的各种控件其实就是在 View 的基础之上有添加了各自特有的功能，而 ViewGroup 则是一种特殊的 View，它可以包含很多子 ViewGroup，是一个用于放置控件和布局的容器

```java
//用于为布局或控件指定一个背景，可以使用颜色或图片来进行填充
android:background

//指定控件在上下左右方向上偏移的距离
android:layout_margin

//单独指定控件在某个方向上偏移的距离
android:layout_marginLeft
```



### 引入布局

新建一个布局 title.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    //用于为布局或控件制定一个背景，可以使用颜色或图片来进行填充
    android:background="@drawable/title_bg">

    <Button
        android:id="@+id/title_back"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        //指定控件在上下左右方向上偏移的距离
        android:layout_margin="5dp"
        android:background="@drawable/back_bg"
        android:text="Back"
        android:textColor="#fff"
        />
    <TextView
        android:id="@+id/title_text"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:layout_weight="1"
        android:gravity="center"
        android:text="Title Text"
        android:textColor="#fff"
        android:textSize="24sp"
        />
    <Button
        android:id="@+id/title_edit"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:layout_margin="5dp"
        android:background="@drawable/edit_bg"
        android:text="Edit"
        android:textColor="#fff"
        />
</LinearLayout>
```

修改 activity_main.xml 中的代码

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

	//只需要通过一行 include  语句将标题栏布局引入进来就可以了
    <include layout="@layout/title" />
        
</LinearLayout>
```

在 MainActivity 中将系统自带的标题隐藏掉

```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        //调用 getSupportActionBar() 方法来获得 ActionBar 的实例，然后再调用 ActionBar 的 hide() 方法将标题隐藏起来
        ActionBar actionbar = getSupportActionBar();
        if(actionbar != null){
            actionbar.hide();
        }
    }
}
```

使用这种方式，不管有多少需要添加标题栏，只需要一行 include 语句就行了



### 创建自定义控件

为了避免每个活动中为这些布局功能都是相同的控件能够响应相同的事件而去单独编写一次事件的注册代码

新建一个 TitleLayout 类

```java
public class  TitleLayout extends LinearLayout {
    //重写了 LinearLayout 中带有两个参数的构造函数，在布局中引入 TitleLayout 控件就会调用这个函数
    public TitleLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
        //在构造函数中对标题栏布局进行动态加载
        //通过 LayoutInflater 的 from() 方法可以构建出一个 LayoutInflater 对象，然后调用 inflate() 方法就可以动态加载一个布局文件，inflate() 方法接受两个参数，第一个参数是要加载的布局文件的 id，这里我们传入 R.layout.title，第二个参数是给加载好的布局再添加一个父布局，这里我们想要指定为 TitleLayout，于是直接传入 this
        LayoutInflater.from(context).inflate(R.layout.title, this);
    }
}
```

现在已经创建好自定义控件，然后需要在布局文件中添加这个自定义控件，修改 activity_main.xml 中的代码

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

//添加自定义控件和添加普通控件的方式基本是一样的，只不过在添加自定义控件的时候，需要指明控件的完整类名，包名在这里是不可以省略
    <com.example.uilayouttest.TitleLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"/>
        
</LinearLayout>
```

为标题栏中的按钮注册点击事件，修改 TitleLayout 中的代码

```java
public class  TitleLayout extends LinearLayout {
    public TitleLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
        LayoutInflater.from(context).inflate(R.layout.title, this);
        //通过 findViewById() 方法得到按钮的实例
        Button titleBack = (Button) findViewById(R.id.title_back);
        Button titleEdit = (Button) findViewById(R.id.title_edit);
        //调用 setOnClickListener() 方法给两个按钮注册了点击事件，当点击返回按钮时销毁掉当前的活动，当点击编辑按钮时弹出一段文本
        titleBack.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                ((Activity)getContext()).finish();
            }
        });
        titleEdit.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                Toast.makeText(getContext(), "You clicked Edit button",
                        Toast.LENGTH_SHORT).show();
            }
        });
    }
}
```



### Nine-Patch 图片

Nine-Patch 图片是一种被特殊处理过的 png 图片，能够制定哪些区域可以被拉伸、哪些区域不可以

在 Android Studio 中对任意一张 png 图片右击 -> Create 9-patch file，即可穿件 Nine-Patch 图片

上边框和左边框绘制的部分表示当图片需要拉伸时就拉伸黑点标记的区域

下边框和右边框绘制的部分表示内容会被放置的区域

使用鼠标在图片的边缘拖动就可以进行绘制，按住 shift 键拖动可进行擦除



## 编写界面的最佳实践

在 app/build.gradle 当中添加依赖库

```java
dependencies {
    implementation 'com.android.support:recyclerview-v7:24.2.1'
}
```

修改 activity_main.xml 中的代码

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="#d8e0e8">

	//在主页面中放置了一个 RecyclerView 用于显示聊天的消息内容
    <android.support.v7.widget.RecyclerView
        android:id="@+id/msg_recycler_view"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"/>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

		//放置了一个 EditText 用于输入消息
        <EditText
            android:id="@+id/input_text"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:hint="Tyoe something here"
            android:maxLines="2"/>

		//放置了一个 Button 用于发送消息
        <Button
            android:id="@+id/send"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Send"/>

    </LinearLayout>

</LinearLayout>
```

定义消息的实体类，新建 Msg

```java
public class Msg {
    //表示这是一条收到的消息
    public static final int TYPE_RECEIVED = 0;

    //表示这是一条发出的消息
    public static final int TYPE_SEND = 1;

    // content 表示消息的内容
    private String content;

    // type 表示消息的类型
    private int type;

    public Msg(String content, int type){
        this.content = content;
        this.type = type;
    }

    public String getContent(){
        return content;
    }

    public int getType(){
        return type;
    }
}
```

编写 RecyclerView 子项的布局，新建 msg_item.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:padding="10dp">

	//收到的消息居左对齐
    <LinearLayout
        android:id="@+id/left_msg"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="left"
        android:background="@drawable/message_left">

        <TextView
            android:id="@+id/left_msg"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:layout_margin="10dp"
            android:textColor="#fff"/>

    </LinearLayout>

	//发出的消息居右对齐
    <LinearLayout
        android:id="@+id/right_layout"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="right"
        android:background="@drawable/message_right">
        
        <TextView
            android:id="@+id/right_msg"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:layout_margin="10dp"/>

    </LinearLayout>

</LinearLayout>
```

创建 RecyclerView 的适配器类，新建类 MsgAdapter

```java
public class MsgAdapter extends RecyclerView.Adapter<MsgAdapter.ViewHolder> {

    private List<Msg> mMsgList;

    static class ViewHolder extends RecyclerView.ViewHolder{

        LinearLayout leftLayout;

        LinearLayout rightLayout;

        TextView leftMsg;

        TextView rightMsg;

        public ViewHolder(View view){
            super(view);
            leftLayout = (LinearLayout) view.findViewById(R.id.left_layout);
            rightLayout = (LinearLayout) view.findViewById(R.id.right_layout);
            leftMsg = (TextView) view.findViewById(R.id.left_msg);
            rightMsg = (TextView) view.findViewById(R.id.right_msg);
        }
    }

    public MsgAdapter(List<Msg> msgList){
        mMsgList = msgList;
    }

    @Override
    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType){
        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.msg_item, parent,false);
        return new ViewHolder(view);
    }

    @Override
    public void onBindViewHolder(ViewHolder holder, int position){
        Msg msg = mMsgList.get(position);
        if(msg.getType() == Msg.TYPE_RECEIVED){
            //如果是收到的消息，则先是左边的消息布局，将右边的消息布局隐藏
            holder.leftLayout.setVisibility(View.VISIBLE);
            holder.rightLayout.setVisibility(View.GONE);
            holder.leftMsg.setText(msg.getContent());
        }else if(msg.getType() == Msg.TYPE_SEND){
            //如果是发出的消息，则显示右边的消息布局，将左边的消息布局隐藏
            holder.rightLayout.setVisibility(View.VISIBLE);
            holder.leftLayout.setVisibility(View.GONE);
            holder.rightMsg.setText(msg.getContent());
        }
    }

    @Override
    public int getItemCount(){
        return mMsgList.size();
    }
}
```

修改 MainActivity 中的代码

```java
public class MainActivity extends AppCompatActivity {

    private List<Msg> msgList = new ArrayList<>();

    private EditText inputText;

    private Button send;

    private RecyclerView msgRecyclerView;

    private MsgAdapter adapter;

    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initMsgs();//初始化消息数据
        inputText = (EditText) findViewById(R.id.input_text);
        send = (Button) findViewById(R.id.send);
        msgRecyclerView = (RecyclerView) findViewById(R.id.msg_recycler_view);
        LinearLayoutManager layoutManager = new LinearLayoutManager(this);
        msgRecyclerView.setLayoutManager(layoutManager);
        adapter = new MsgAdapter(msgList);
        msgRecyclerView.setAdapter(adapter);
        //在发送按钮的单机时间里获取了 EditText 中的内容，如果内容不为空字符串则创建出一个新的 Msg 对象，并把它添加到 msgList 列表中去
        send.setOnClickListener(new View.OnClickListener(){       
            @Override
            public void onClick(View v){
                String content = inputText.getText().toString();
                if(!"".equals(content)){
                    Msg msg = new Msg(content, Msg.TYPE_SEND);
                    msgList.add(msg);
                    
                    //调用了适配器的 notifyItemInserted() 方法，用于通知列表有新的数据插入，这样新增的一条消息才能够在 RecyclerView 中显示
                    adapter.notifyItemInserted(msgList.size() - 1);//当有新消息时，刷新 RecyclerView 中的而显示
                    
                    //调用 scrollToPosion() 方法将显示的数据定位到最后一行，以保证一定可以看到最后发出的一条消息
                    msgRecyclerView.scrollToPosition(msgList.size() - 1);//将 RecyclerView 定位到最后一行
                    
                    inputText.setText("");//清空输入框中的内容
                }
            }
        });
    }
    // initMsgs() 方法中先初始化几条数据用于在 RecyclerView 中显示
    private void initMsgs(){
        Msg msg1 = new Msg("Hello guy.", Msg.TYPE_RECEIVED);
        msgList.add(msg1);
        Msg msg2 = new Msg("Hello. Who is that?", Msg.TYPE_SEND);
        msgList.add(msg2);
        Msg msg3 = new Msg("This is Tom. Nice talking to you.", Msg.TYPE_RECEIVED);
        msgList.add(msg3);
    }

}
```



## Fragment

碎片（Fragment）是一种可以嵌入在活动中的 UI 片段，它能让程序更加合理和充分地利用大屏幕有的空间，和活动很像，同样都能包含布局，同样都有自己的生命周期



### 碎片的简单用法

新建一个左侧碎片布局 left_fragment.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

	//放置了一个按钮，并让它水平居中显示
    <Button
        android:id="@+id/button"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"
        android:text="Button"
        />

</LinearLayout>
```

新建右侧碎片布局 right_fragment.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    //将布局背景设置成了绿色
    android:background="#00ff00"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

	//放置了一个 TextView 用于显示一段文本，水平居中显示
    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"
        android:textSize="20dp"
        android:text="This is right fragment"
        />

</LinearLayout>
```

新建一个 LeftFragment 类

```java
public class LeftFragment extends Fragment {
    //仅仅重写了 Fragment 的 onCcreateView() 方法，然后在这个方法中通过 LayoutInflater 的 inflate() 方法将刚才定义的 left_fragment 布局动态加载进来
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle saveInstanceState){
        View view = inflater.inflate(R.layout.left_fragment, container, false);
        return view;
    }
}
```

新建一个 RightFragment

```java
public class RightFragment extends Fragment {
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle saveInstanceState){
        View view = inflater.inflate(R.layout.right_fragment, container, false);
        return view;
    }
}
```

修改 activity_main.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

	//使用了 <fragment> 标签在布局中添加碎片，通过 android:name 属性来显式指明要添加的碎片类名，注意一定要将类的包名也加上
    <fragment
        android:id="@+id/left_fragment"
        android:name="com.example.fragmenttest.LeftFragment"
        android:layout_width="0dp"
        android:layout_height="match_parent"
        android:layout_weight="1"
        />

    <fragment
        android:id="@+id/right_fragment"
        android:name="com.example.fragmenttest.RightFragment"
        android:layout_width="0dp"
        android:layout_height="match_parent"
        android:layout_weight="1"
        />

</LinearLayout>
```



### 动态添加布局

新建 another_right_fragment.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:background="#ffff00"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"
        android:textSize="20sp"
        android:text="This is another right fragment"
        />

</LinearLayout>
```

该布局文件的代码和 right_fragment.xml 中的代码基本相同，只是将背景色改成黄色，并将显示的文字进行修改

新建 AnotherRightFragment 作为另一个右侧碎片

```java
public class AnotherRightFragment extends Fragment {
    //在 onCreateView() 方法中加载了刚刚创建的 another_right_fragment 布局
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState){
        View view = inflater.inflate(R.layout.another_right_fragment, container, false);
        return view;
    }
}
```

让它动态地添加到活动当中，修改 activity_main.xml 

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <fragment
        android:id="@+id/left_fragment"
        android:name="com.example.fragmenttest.LeftFragment"
        android:layout_width="0dp"
        android:layout_height="match_parent"
        android:layout_weight="1"
        />

    //将右侧碎片替换成了一个 FrameLayout，这是 Android 中最简单的一种布局，所有的控件默认都会摆放在布局的左上角
    <FrameLayout
        android:id="@+id/right_layout"
        android:layout_width="0dp"
        android:layout_height="match_parent"
        android:layout_weight="1">
    </FrameLayout>

</LinearLayout>
```

在代码中向 FrameLayout 里添加内容，从而实现动态添加碎片的功能，修改 MainActivity

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener{

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        //给左侧按钮注册一个点击事件，然后调用 replaceFragment() 方法动态添加了 RightFragment 这个碎片，当点击左侧碎片中的按钮时，又会调用 replaceFragment() 方法将右侧碎片替换成 AnotherRightFragment
        Button button = (Button) findViewById(R.id.button);
        button.setOnClickListener(this);
        replaceFragment(new RightFragment());
    }

    @Override
    public void onClick(View v){
        switch(v.getId()){
            case R.id.button:
                replaceFragment(new AnotherRightFragment());
                break;
            default:
                break;
        }
    }

    private void replaceFragment(Fragment fragment){
        FragmentManager fragmentManager = getSupportFragmentManager();
        FragmentTransaction transaction = fragmentManager.beginTransaction();
        transaction.replace(R.id.right_layout, fragment);
        transaction.commit();
    }
}
```

动态添加碎片主要

- 创建待添加的碎片实例
- 获取 FragmentManager，在活动中可以直接通过调用 getSupportFragmentManage() 方法得到
- 开启一个事务，通过调用 beginTransaction() 方法开启
- 向容器内添加或替换碎片，一般使用 replace() 方法实现，需要传入容器的 id 和待添加的碎片实例
- 提交事务，调用 commit() 方法来完成



### 在碎片中模拟返回栈

模仿类似于返回栈的效果，按下 Back 键可以回到上一个碎片，FragmentTransaction 中提供了一个 addToBackStack() 方法，可以用于将一个事务添加到返回栈中，修改 MainActivity 

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener{

......

    private void replaceFragment(Fragment fragment){
        FragmentManager fragmentManager = getSupportFragmentManager();
        FragmentTransaction transaction = fragmentManager.beginTransaction();
        transaction.replace(R.id.right_layout, fragment);
    	//在事务提交之前调用 FragmentTransaction 的 addToBackStack() 方法，它可以接受一个名字用于描述返回栈的状态，一般传入 null 即可
        transaction.addToBackStack(null);
        transaction.commit();
    }
}
```



### 碎片和活动之间进行通信

碎片和活动都是各自存在于一个独立的类当中的，它们之间并没有那么明显的方式来直接进行通信

为了方便碎片和活动之间进行通信，FragmentManager 提供了一个类似于 findViewById() 的方法，专门用于从布局文件中获取碎片的实例，代码如下所示：

```java
RightFragment rightFragment = (RightFragment) getSupportFragmentManager().findFragmentById(R.id.right_fragment);
```

调用 FragmentManager 的 findFragmentById() 方法，可以在活动中得到相应的碎片实例， 然后就可以调用碎片里的方法

每个碎片中都可以调用 getActivity() 方法来得到和当前碎片相关联的活动实例，代码如下：

```java
MainActivity activity = (MainActivity) getActivity();
```

另外，当碎片中需要使用 Context 对象时，也可以使用 getActivity() 方法，因为获取到的活动本身即是一个 Context 对象

碎片和碎片之间的通信：首先在一个碎片中可以得到与它相关联的活动，然后再通过活动去获取另外一个碎片的实例



### 碎片的生命周期

- 运行状态：当一个碎片是可见的，并且它所关联的活动正处于运行状态时，该碎片也处于运行状态
- 暂停状态：当一个活动进入暂停状态时（由于另一个未占满屏幕的活动被添加到了栈顶），与它相关的可见碎片就会进入到暂停状态
- 停止状态：当一个活动进入停止状态时，与它相关联的碎片就会进入到停止状态，或者通过调用 FragmentTransaction 的 remove() 、replace() 方法将碎片从活动中移除，但如果在事务提交之前调用 addToBackStack() 方法，这时的碎片也会进入到停止状态。总的来说，进入停止状态的碎片对用户来说是完全不可见的，有可能会被系统回收
- 销毁状态：碎片总是依附于活动而存在的，因此当活动被销毁时，与它相关联的碎片就会进入到销毁状态。或者通过调用 FragmentTransaction 的 remove() 、replace() 方法将碎片从活动中移除，但在事务提交之前没有调用 addToBackStack() 方法，这时的碎片也会进入到销毁状态
- onAttach()：当碎片和活动建立关联的时候调用
- onCreateView()：为碎片创建视图（加载布局）时调用
- onActivityCreated()：确保与碎片相关联的活动一定已经创建完毕的时候调用
- onDestroyView()：当与碎片关联的视图被移除的时候调用
- onDetach()：当碎片和活动解除关联的时候调用

![微信图片_20190815192229](E:\Android笔记\学习图片\微信图片_20190815192229.jpg)

碎片中你也可以通过 onSaveInstanceState() 方法来保存数据，因为进入停止状态的碎片有可能在系统内存不足的时候被回收，保存下来的数据在 onCreate() 、onCreateView() 和 onActivityCreated() 这三个方法中你都可以重新得到，他们都含有一个 Bundle 类型的 saveInstanceState 参数



### 动态加载布局的技巧

让程序根据设备的分辨率或屏幕大小在运行时来决定加载哪个布局



#### 使用限定符

借助限定符（Qualifiers）可以用来实现在运行时判断程序是应该是使用双页模式还是单页模式

修改 FragmentTest 项目中的 activity_main.xml 

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <fragment
        android:id="@+id/left_fragment"
        android:name="com.example.fragmenttest.LeftFragment"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />

</LinearLayout>
```

将多余的代码都删掉，只留下左侧碎片，并让它充满整个父布局

在 res 目录下新建 layout-main 文件夹，在该文件夹下新建一个布局也叫做 activity_main.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <fragment
        android:id="@+id/legt_fragment"
        android:name="com.example.fragmenttest.LeftFragment"
        android:layout_width="0dp"
        android:layout_height="match_parent"
        android:layout_weight="1" />

    <fragment
        android:id="@+id/right_fragment"
        android:name="com.example.fragmenttest.RightFragment"
        android:layout_width="0dp"
        android:layout_height="match_parent"
        android:layout_weight="3" />

</LinearLayout>
```

layout / activity_main.xml 只包含了一个碎片，即单页模式

layout-large / activity_main.xml 包含了两个碎片，即双页模式

其中 large 就是一个限定符，那些屏幕被认为是 large 的设备就是自动加载 layout-large 文件夹下的布局，而小屏幕的设备则还是会加载 layout 文件夹下的布局

将 MainActivity 中 replaceFragment() 方法里的代码注释掉，分别在平板模拟器和手机模拟器上运行程序，实现了程序在运行时动态加载布局的功能



#### 使用最小宽度限定符

最小宽度限定符允许我们对屏幕的宽度指定一个最小值（以 dp 为单位），然后以这个最小值为临界点，屏幕宽度大于这个值的设备就加载一个布局，屏幕宽度小于这个值的设备就加载另一个布局

在 res 目录下新建 layout-sw600dp 文件夹，然后在这个文件夹下新建 activity_main.xml 布局

当屏幕宽度大于等于 600 dp 的设备时，会加载 layout-sw600dp / activity_main.xml 布局，当程序运行在屏幕宽度小于 600 dp 的设备上时，则仍然加载 layout / activity_main 布局



### 碎片的最佳实践

新建一个 FragmentBestPractice 项目

在 app / build.gradle 中添加依赖库

```java
dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    implementation 'com.android.support:appcompat-v7:28.0.0'
    implementation 'com.android.support.constraint:constraint-layout:1.1.3'
    testImplementation 'junit:junit:4.12'
    //添加依赖库
    implementation 'com.android.support:recyclerview-v7:24.2.1'
    androidTestImplementation 'com.android.support.test:runner:1.0.2'
    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
}
```

新建一个新闻实体类，News

```java
public class News {

    private String title;

    private String content;

    public String getTitle(){
        return title;
    }

    public void setTitle(String title){
        this.title = title;
    }

    public String getContent(){
        return content;
    }

    public void setContent(String content){
        this.content = content;
    }
}
```

该类 title 字段表示新闻标题，content 字段表示新闻内容

新建布局文件 news_content_frag.xml

```java
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <LinearLayout
        android:id="@+id/visibility_layout"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="vertical"
        android:visibility="invisible">

        <TextView
            android:id="@+id/news_title"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:gravity="center"
            android:padding="10dp"
            android:textSize="20sp"/>

        <View
            android:layout_width="match_parent"
            android:layout_height="1dp"
            android:background="#000"/>

        <TextView
            android:id="@+id/news_content"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_weight="1"
            android:padding="15dp"
            android:textSize="18sp"/>

    </LinearLayout>

    <View
        android:layout_width="1dp"
        android:layout_height="match_parent"
        android:layout_alignParentLeft="true"
        android:background="#000"/>

</RelativeLayout>
```

新闻内容主要分为两个部分，头部显示新闻标题，正文部分显示新闻内容，中间使用一条细线来分割，细线利用了 View  来实现，将 View 高度设为 1dp ，再通过 backgroun 属性设置为黑色

新建一个 NewContentFragment 类

```java
public class NewsContentFragment extends Fragment {

    private View view;

    //首先在 onCreateView() 方法里加载了 new_content_frag 布局
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState){
        view = inflater.inflate(R.layout.news_content_frag, container, false);
        return view;
    }

    //提供 refresh() 方法，该方法用于将新闻的标题和内容显示在界面上
    public void refresh(String newsTitle, String newsContent){
        View visibilityLayout = view.findViewById(R.id.visibility_layout);
        visibilityLayout.setVisibility(View.VISIBLE);
        //通过 findViewById() 方法分别获取到新闻标题和内容的控件，然后将方法传递进来的参数设置进去
        TextView newsTitleText = (TextView) view.findViewById(R.id.news_title);
        TextView newsContentText = (TextView) view.findViewById(R.id.news_content);
        newsTitleText.setText(newsTitle);//刷新新闻的标题
        newsContentText.setText(newsContent);//刷新新闻的内容
    }

}
```

以上把新闻内容的碎片和布局都创建好了，但是他们都是在双页模式下使用的，现在创建一个在单页模式下使用的活动，右击 com.example.fragmentbestpractice 包 -> New -> Activity -> Empty Activity，新建一个 NewContentActivity，并将布局名指定成 news_content， 修改里面的代码

```
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent" >

    <fragment
        android:id="@+id/news_content_fragment"
        android:name="com.example.fragmentbestpractice.NewsContentFragment"
        android:layout_width="match_parent"
        android:layout_height="match_parent"

</LinearLayout>
```

修改 NewsContentActivity

```java
public class NewsContentActivity extends AppCompatActivity {

    public static void actionStart(Context context, String newsTitle, String newsContent){
        Intent intent = new Intent(context,NewsContentActivity.class);
        intent.putExtra("news_title", newsTitle);
        intent.putExtra("news_content", newsContent);
        context.startActivity(intent);
    }

    //在 onCreate() 方法中通过 Intent 获取到了传入的新闻标题和新闻内容
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.news_content);
        String newsTitle = getIntent().getStringExtra("news_title");//获取传入的新闻标题
        String newsContent = getIntent().getStringExtra("news_content");//获取传入的内容
        //调用 FragmentManager 的 findFragmentById() 方法得到了 NewsContentFragment 的实例，接着调用了它的 refresh() 方法，将新闻的标题和内容传入这样就可以把这些数据显示出来
        NewsContentFragment newsContentFragment = (NewsContentFragment) getSupportFragmentManager().findFragmentById(R.id.news_content_fragment);
        newsContentFragment.refresh(newsTitle, newsContent);//刷新 NewsContentFragment 界面
    }
    
}
```

新建 news_title_frag.xml 布局，用于显示新闻列表的布局

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical" 
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    
    <android.support.v7.widget.RecyclerView
        android:id="@+id/news_title_recycler_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent">
    </android.support.v7.widget.RecyclerView>

</LinearLayout>
```

该布局只有一个用于显示新闻列表的 RecyclerView，要用到 RecyclerView 就少不了子项的布局，新建 news_item.xml 作为 RecyclerView 子项的布局

```java
<TextView xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/news_title"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    //android:maxLines 让这个 TextView 只能单行显示
    android:maxLines="1"
    //android:ellipsize 用于设定当文本内容超出空间宽度时，文本的缩略方式，这里指定 end 表示在尾部进行缩略
    android:ellipsize="end"
    android:textSize="18sp"
    //android:padding 表示给控件周围加上补白
    android:paddingLeft="10dp"
    android:paddingRight="10dp"
    android:paddingTop="15dp"
    android:paddingBottom="15dp"
    >
</TextView>
```

新建 NewsTitleFragment 作为展示新闻列表的碎片

```java
public class NewsTitleFragment extends Fragment {
    
    private boolean isTwoPane;
    
    //在 onCreateView() 方法中加载了 news_title_frag 布局
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState){
        View view = inflater.inflate(R.layout.news_title_frag, container, false);
        return view;
    }
    
    //在 onActivityCreated() 方法中能否找到一个 id 为 news_content_layout 的 View 来判断当前是双页模式还是单页模式，我们需要让这个 id 只在双页模式中出现
    @Override
    public void onActivityCreated(Bundle savedInstanceState){
        super.onActivityCreated(savedInstanceState);
        if(getActivity().findViewById(R.id.news_content_layout) != null){
            isTwoPane = true;//可以找到 news_content_layout 布局时，为双页模式
        }else{
            isTwoPane = false;//找不到 news_content_layout 布局时，为单页模式
        }
    }
    
}
```

修改 activity_main.xml

```java
//在单页模式下只会加载一个新闻标题的碎片
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/news_title_layout"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <fragment
        android:id="@+id/news_title_fragment"
        android:name="com.example.fragmentbestpractice.NewsTitleFragment"
        android:layout_width="match_parent"
        android:layout_height="match_parent"/>
    
</FrameLayout>
```

新建 layout-sw600dp 文件夹，在该文件夹下新建 activity_main.xml 文件

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <fragment
        android:id="@+id/news_title_fragment"
        android:name="com.example.fragmentbestpractice.NewsTitleFragment"
        android:layout_width="0dp"
        android:layout_height="match_parent"
        android:layout_weight="1" />

    <FrameLayout
        android:id="@+id/news_content_layout"
        android:layout_width="0dp"
        android:layout_height="match_parent"
        android:layout_weight="3">

        <fragment
            android:id="@+id/news_content_fragment"
            android:name="com.example.fragmentbestpractice.NewsContentFragment"
            android:layout_width="match_parent"
            android:layout_height="match_parent" />
        
    </FrameLayout>

</LinearLayout>
```

在双页模式下我们同事引入了两个碎片，并将新闻内容的碎片放在了一个 FrameLayout 布局下，而这个布局的 id 正是 news_content_layout。因此能够找到这个 id 的时候就是双页模式，否则为单页模式

在 NewsTitleFragment 中新建一个内部类 NewsAdapter 来作为 RecyclerView 的适配器

```java
public class NewsTitleFragment extends Fragment {

    private boolean isTwoPane;
    
    ...
        
    //将适配器携程一个内部类，好处是可以直接访问 NewTitleFragment 的变量
    class NewsAdapter extends RecyclerView.Adapter<NewsAdapter.ViewHolder>{

        private List<News> mNewsList;

        class ViewHolder extends RecyclerView.ViewHolder{

            TextView newsTitleText;

            public ViewHolder(View view){
                super(view);
                newsTitleText = (TextView) view.findViewById(R.id.news_title);
            }

        }

        public NewsAdapter(List<News> newsList){
            mNewsList = newsList;
        }

        @Override
        public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType){
            View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.news_title_frag, parent, false);
            final ViewHolder holder = new ViewHolder(view);
            view.setOnClickListener(new View.OnClickListener(){
                @Override
                public void onClick(View v){
                    //首先获取到点击项的 News 实例，然后通过 isTwoPane 变量来判断当前是单页还是双页模式，如果是单页模式，就启动一个新的活动去显示新闻内容，如果是双页模式，则更新内容碎片里的数据
                    News news = mNewsList.get(holder.getAdapterPosition());
                    if(isTwoPane){
                        //如果是双页模式，则刷新 NewcontentFragment 中的内容
                        NewsContentFragment newsContentFragment = (NewsContentFragment) getFragmentManager().findFragmentById(R.id.news_content_fragment);
                        newsContentFragment.refresh(news.getTitle(), news.getContent());
                    }else{
                        //如果是单页模式，则直接启动 NewContentActivity
                        NewsContentActivity.actionStart(getActivity(), news.getTitle(), news.getContent());
                    }
                }
            });
            return holder;
        }

        @Override
        public void onBindViewHolder(ViewHolder holder, int position){
            News news = mNewsList.get(position);
            holder.newsTitleText.setText(news.getTitle());
        }

        @Override
        public int getItemCount(){
            return mNewsList.size();
        }

    }

}
    
```

向 RecyclerView 中填充数据，修改 NewTitleFragment

```java
public class NewsTitleFragment extends Fragment {

    private boolean isTwoPane;

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState){
        View view = inflater.inflate(R.layout.news_title_frag, container, false);
        RecyclerView newsTitleRecycleView = (RecyclerView) view.findViewById(R.id.news_title_recycler_view);
        LinearLayoutManager layoutManager = new LinearLayoutManager(getActivity());
        newsTitleRecycleView.setLayoutManager(layoutManager);
        //调用 getNews() 方法来初始化50条模拟新闻数据
        NewsAdapter adapter = new NewsAdapter(getNews());
        newsTitleRecycleView.setAdapter(adapter);
        return view;
    }

    private List<News> getNews(){
        List<News> newsList = new ArrayList<>();
            for(int i = 1; i <= 50; i++) {
                News news = new News();
                news.setTitle("This is news titile " + i);
                //使用了 getRandomLengthContent() 方法来随机生成新闻内容额长度，以保证每条新闻的内容差距比较大
                news.setContent(getRandomLengthContent("This is news content " + i + "."));
                newsList.add(news);
            }
            return newsList;
        }

    private String getRandomLengthContent(String content){
        Random random = new Random();
        int length =random.nextInt(20) + 1;
        StringBuilder builder = new StringBuilder();
        for(int i = 0; i < length; i++){
            builder.append(content);
        }
        return builder.toString();
    }

...

}
```





## Broadcasts

Android 中的广播主要可以分为两种类型：标准广播和有序广播

- 标准广播（Normal broadcasts）：是一种完全异步执行的广播，在广播发出之后，所有的广播接收器几乎都会在同一时刻接收到这条广播消息，因此它们之间没有任何先后顺序可言。这种广播的效率会比较高，但同时也意味着它是无法被截断的
- 有序广播（Ordered broadcasts）则是一种同步执行的广播，在广播发出之后，同一时刻只会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递。所以此时的广播接收器是有先后顺序的，优先级高的广播接收器就可以先收到广播消息，并且前面的广播接收器还可以截断正在传递的广播，这样后面的广播接收器就无法收到广播消息了

广播接收器可以自由地对自己感兴趣的广播进行注册，这样当有相应的广播发出时，广播接收器能够收到该广播，并在内部处理相应的逻辑

注册广播的方式有：

1. 在 AndroidMainfest.xml 中注册（静态注册)
2. 在代码中注册（动态注册）

创建广播接收器：只需要新建一个类，让它继承 BroadcastReceiver ，并重写父类的 onReceive() 方法就行，这样当有广播到来，该方法就会执行，具体的逻辑就可以在这个方法中处理





### 动态注册监听网络变化

新建一个 BroadcastTest 项目，修改 MAinActivity 

```java
public class MainActivity extends AppCompatActivity {
    
    private IntentFilter intentFilter;
    
    private NetworkChangeReceiver networkChangeReceiver;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        //创建了一个 IntentFilter 实例，并给它添加了一个值为 android.net.conn.CONNECTIVITY_CHANGE 的 action，因为网络状态发生变化时，系统发出的正是这一条 android.net.conn.CONNECTIVITY_CHANGE 的广播，我们的广播接收器想要监听什么广播，就在这里添加相应的 action
        intentFilter = new IntentFilter();
        intentFilter.addAction("android.net.conn.CONNECTIVITY_CHANGE");
        //创建 NetworkChangeReceiver 实例，调用 registerReceiver() 方法将 IntentFilter 实例和 NetworkChangeReceiver 实例都传了进去，这样 NetworkChangeReceiver 就会收到所有值为 android.net.conn.CONNECTIVITY_CHANGE 的广播，也实现了监听网络变化的功能
        networkChangeReceiver = new NetworkChangeReceiver();
        registerReceiver(networkChangeReceiver, intentFilter);
    }
    
    //动态注册的广播接收器一定都要取消注册才行，这里我们是在 onDestroy() 方法中调用 unregisterReceiver() 方法来实现的
    @Override
    protected void onDestroy(){
        super.onDestroy();
        unregisterReceiver(networkChangeReceiver);
    }
    
    //定义一个内部类 NetworkChangeReceiver，这个类是继承 BroadcastReceiver，并重写父类的 onReceive() 方法，这样当网络状态发生变化时，onReceive() 方法就会得到执行，这里只是简单地使用 Toast 提示了一段文本信息
    class  NetworkChangeReceiver extends BroadcastReceiver{
        
        @Override
        public void onReceive(Context context, Intent intent){
            Toast.makeText(context, "network changes", Toast.LENGTH_SHORT).show();
        }
            
    }
    
}
```

优化使之准确告诉用户当前是有网络还是没有网络，修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {
    
...
    
    class  NetworkChangeReceiver extends BroadcastReceiver{
        
        @Override
        public void onReceive(Context context, Intent intent){
            //首先通过 getSystemService(）方法得到了 ConnectivityManager 的实例，这是一个系统服务类，专门用于管理网络连接的，调用它的 getActiveNetworkInfo() 方法来得到 NetworkInfo 的实例，接着调用 NetworkInfo 的 isAvailable() 方法判断当前是否有网络
            ConnectivityManager connectionManager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);
            NetworkInfo networkInfo = connectionManager.getActiveNetworkInfo();
            if (networkInfo != null && networkInfo.isAvailable()) {
                Toast.makeText(context, "network is available", Toast.LENGTH_SHORT).show();
            } else {
            Toast.makeText(context, "network is unavailable", Toast.LENGTH_SHORT).show();
        }
            
    }
    
}
```

这里访问系统的网络状态需要声明来打开权限，打开 AndroidManifest.xml 

```java
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.broadcasttest">

    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />

    ...

</manifest>
```



### 静态注册实现开机启动

动态注册的广播接收器可以自由地注册与注销，在灵活性方面有很大的优势，但是它存在一个缺点，即必须在程序启动之后才能接收到广播，因为注册的逻辑是写在 onCreate() 方法中，所以需要使用静态注册的方式让程序在未启动的情况下就能收到广播

右击 com.example.broadcasttest 包 -> New -> Other -> Broadcast Receiver，经广播接收器命名为 BootCompleteReceiver，Exported 实型表示是否允许这个广播接收器接受本程序以外的广播，Enabled 属性表示是否启用这个广播接收器，勾选这两个属性

修改 BootCompleteReceiver 

```java
public class BootCompleteReceiver extends BroadcastReceiver {

    //在 onCreate() 方法中使用 Toast 弹出一段提示信息
    @Override
    public void onReceive(Context context, Intent intent) {
        Toast.makeText(context, "Boot Complete", Toast.LENGTH_SHORT).show();
    }
}
```

静态的广播接收器一定要在 AndroidManifest.xml 文件中注册才能使用，我们使用 Android Studio 的快捷方式创建的广播接收器，注册这一步已经自动完成了

```java
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.broadcasttest">

    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        // <application> 标签内出现了一个恶心的标签 <receiver> 所有的广播接收器都是在这里进行注册的。它的用法和 <activity> 标签非常相似，也是通过 android:name 来指定具体注册哪一个广播接收器，而 enabled 和 exproted 属性则是根据我们刚才勾选的状态自动生成的
        <receiver
            android:name=".BootCompleteReceiver"
            android:enabled="true"
            android:exported="true">
        </receiver>
</manifest>
```

继续修改 AndroidManifest.xml 

```java
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.broadcasttest">

    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    //监听系统开机广播需要权限，使用 <uses-permission> 标签里添加了一条 android.permission.RECEIVE_BOOT_COMPLETED 权限
    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        <receiver
            android:name=".BootCompleteReceiver"
            android:enabled="true"
            android:exported="true">
            //Android 系统启动完成后会发出一条值为 android.intent.action.BOOT_COMPLETED 的广播，因此在 <intent-filter> 标签里添加了响应的 action
            <intent-filter>
                <action android:name="android.intent.action.BOOT_COMPLETED" />
            </intent-filter>
        </receiver>
    </application>
</manifest>
```

真正的项目使用广播接收器的时候是在里面 onReceive() 编写自己的逻辑，注意不要再 onReceive() 方法中添加过多的逻辑或者进行任何耗时操作，因为广播接收器不允许开启线程的，当 onReceive() 方法运行较长时间而没有结束，程序就会报错，因此广播接收器更多的是扮演一种打开程序其他组件的角色，比如创建一条状态栏通知，或者启动一个服务等



### 发送自定义广播



#### 发送标准广播

在发广播之前需要定义一个广播接收器来准备接收此广播，不然发出去也白发

新建一个 MyBroadcastReceiver 来做广播接收器

```java
public class MyBroadcastReceiver extends BroadcastReceiver {

    //当 MyBroadcastReceiver 收到自定义广播时，就会弹出 "received in MyBroadcastReceiver" 的提示
    @Override
    public void onReceive(Context context, Intent intent){
        Toast.makeText(context, "received in MyBroadcastReceiver", Toast.LENGTH_SHORT).show();
    }

}
```

在 AndroidManifest.xml 中修改这个广播接收器

```java
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.broadcasttest">
	...
    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        ...
        <receiver
            android:name=".MyBroadcastReceiver"
            android:enabled="true"
            android:exported="true">
            //让 MyBroadcastReceiver 接收一条值为 com.example.broadcaststtest.MY_BROADCAST 的广播，因此待会再发送广播的时候我们需要发送出这样的一条广播
            <intent-filter>
                <action android:name="com.example.broadcaststtest.MY_BROADCAST" />
            </intent-filter>
        </receiver>
    </application>
</manifest>
```

修改 activity_main.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

	//在布局文件中定义了一个按钮，用于作为发送广播的触发点
    <Button
        android:id="@+id/button"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Send Broadcast" />

</LinearLayout>
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {
  	...
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        //在按钮点击时间里面加入了发送定义的广播逻辑
        Button button = (Button) findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener(){
            @Override
            public void onClick(View v){
                //首先构建出一个 Intent 对象，并把要发送的广播传入，然后调用 Context 的 sendBroadcast() 方法将广播发送出去，这样监听 com.example.broadcasttest.MY_BROADCAST 这条广播消息的广播接收器就会收到消息
                Intent intent = new Intent("com.example.broadcasttest.MY_BROADCAST");
                sendBroadcast(intent);
            }
        });
        ...
    }
    ...
}
```

广播是使用 Intent 进行传递的，因此还可以在 Intent 中携带一些数据传递给广播接收器



#### 发送有序广播

广播是一种可以跨进程的通信方式，因此我们应用程序内发出的广播其他的应用程序应该也是可以收到的。验证这一点，新建 BroadcastTest2 项目，接着定义一个广播接收器，用于接收上一小节的自定义广播，新建 AnotherBroadcastReceiver

```java
public class AnotherBroadcastReceiver extends BroadcastReceiver {

    //在广播接收器的 onReceive() 方法中弹出了一段文本信息
    @Override
    public void onReceive(Context context, Intent intent) {
        Toast.makeText(context, "received in AnotherBroadcastReceiver", Toast.LENGTH_SHORT).show();
    }
}
```

在 AndroidManifes.xml 中修改广播接收器

```java
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    package="com.example.broadcasttest2">

    <application
		...
        <receiver
            android:name=".AnotherBroadcastReceiver"
            android:enabled="true"
            android:exported="true">
            <intent-filter>
            	//同样接收 com.example.broadcasttest.MY_BROADCAST 这条广播
                <action android:name="com.example.broadcasttest.MY_BROADCAST" />
            </intent-filter>
        </receiver>
    </application>
</manifest>
```

返回点击发送广播的按钮，会出现两次 Toast，证明了该程序发出的广播是可以被其他应用程序找到的

回到 BroadcastTest 项目，修改 MainActivity 

```java
public class MainActivity extends AppCompatActivity {
	...
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button = (Button) findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener(){
            @Override
            public void onClick(View v){
                Intent intent = new Intent("com.example.broadcasttest.MY_BROADCAST");
                //将 sendBroadcast() 方法改成 sendOrderedBroadcast() 方法，第一个参数仍是 intent，第二个参数是一个与权限相关的字符，这里传入 null 就行
                sendOrderedBroadcast(intent, null);
            }
        });
        intentFilter = new IntentFilter();
        intentFilter.addAction("android.net.conn.CONNECTIVITY_CHANGE");
        networkChangeReceiver = new NetworkChangeReceiver();
        registerReceiver(networkChangeReceiver, intentFilter);
    }
}
```

这时的广播接收器是有先后顺序的，而且前面的广播还可以将广播截断以阻止其继续传播

修改 AndroidManifest.xml 

```java
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    package="com.example.broadcasttest">
		...
        <receiver
            android:name=".MyBroadcastReceiver"
            android:enabled="true"
            android:exported="true">
            //通过 android:priority 属性给广播接收器设置了优先级，优先级比较高的广播接收器就可以先收到广播
            <intent-filter android:priority="100">
                <action android:name="com.example.broadcasttest.MY_BROADCAST" />
            </intent-filter>
        </receiver>
    </application>
</manifest>
```

修改 MyBroadcastReceiver 选择是否允许广播继续传递

```java
public class MyBroadcastReceiver extends BroadcastReceiver {

    @Override
    public void onReceive(Context context, Intent intent){
        Toast.makeText(context, "received in MyBroadcastReceiver", Toast.LENGTH_SHORT).show();
        //在 onReceive() 方法中调用了 abortBroadcast() 方法，表示将这条广播截断了，后面的广播接收器无法在接收到这条广播了
        abortBroadcast();
   }

}
```



#### 使用本地广播

前面我们发送和接收的广播全部属于系统全局广播，即发出的广播可以被其他任何应用程序接收到，并且我们可以接收到来自于其他任何应用程序的广播，这样很容易引起安全性的问题。例如发送一些关键性数据的广播可能被其他应用程序所截获，或者其他的程序不停地向我们的广播接收器里发送各种垃圾广播

Android 引入了一套本地广播机制，使用这个机制发出的广播只能够在应用程序的内部进行传递，并且广播接收器也只能接收来自本应用程序发出的广播

本地广播主要就是使用了一个 LocalBroadcastManager 来对广播进行管理，并提供了发送广播和注册广播接收器的方法

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {
    
    private IntentFilter intentFilter;

    private LocalReceiver localReceiver;

    private LocalBroadcastManager localBroadcastManager;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        //首先通过 LocalBroadcastManager 的 getInstance() 方法得到它的实例
        localBroadcastManager = LocalBroadcastManager.getInstance(this);//获取实例
        Button button = (Button) findViewById(R.id.button);
        //在按钮的点击事件里发出一条 com.example.broadcasttest.LOCAL_BROADCAST 广播
        button.setOnClickListener(new View.OnClickListener(){
            @Override
            public void onClick(View v){
                Intent intent = new Intent("com.example.broadcasttest.LOCAL_BROADCAST");
                //发送广播的时候调用 LocalBroadcastManager 的 sendBroadcast() 方法
                localBroadcastManager.sendBroadcast(intent);//发送本地广播
            }
        });
        intentFilter = new IntentFilter();
        intentFilter.addAction("com.example.broadcasttest.LOCAL_BROADCAST");
        localReceiver = new LocalReceiver();
        //在注册广播接收器的时候调用 LocalBroadcastManager 的 registerReceiver() 方法
        localBroadcastManager.registerReceiver(localReceiver, intentFilter);//注册本地广播监听器
    }
    
    @Override
    protected void onDestroy(){
        super.onDestroy();
        localBroadcastManager.unregisterReceiver(localReceiver);
    }
    
    //在 LocalReceiver 里接收这条广播
    class LocalReceiver extends BroadcastReceiver{
        
        @Override
        public void onReceive(Context context, Intent intent){
            Toast.makeText(context, "received local broadcast", Toast.LENGTH_SHORT).show();
        }
    }
    
}
```

 本地广播是无法通过静态注册的方式来接收的，因为静态注册就是为了让程序在未启动的情况下也能收到广播，而发送本地广播时，我们的程序肯定已经是启动了，因此也完全不需要使用静态注册的功能

本地广播的几点优势：

- 可以明确地知道正在发送的广播不会离开我们的程序，因此不必担心机密数据泄露
- 其他的程序无法将广播发送到我们程序的内部，因此不需要当心会有安全漏洞的隐患
- 发送本地广播比发送系统全局广播将会更加高效



### 广播的最佳实践

新建一个 BroadcastBestPractice 项目，新建一个 ActivityCollector 类用于管理所有的活动

```java
public class ActivityCollector {
    
    public static List<Activity> activities = new ArrayList<>();
    
    public static void addActivity(Activity activity){
        activities.add(activity);
    }
    
    public static void removeActivity(Activity activity){
        activities.remove(activity);
    }
    
    public static void finishAll(){
        for (Activity activity : activities){
            if(!activity.isFinishing()){
                activity.finish();
            }
        }
        activities.clear();
    }
    
}
```

创建 BaseActivity 类作为所有活动的父类

```java
public class BaseActivity extends AppCompatActivity {
    
    @Override
    public void onCreate(Bundle savedInstanceState){
        super.onCreate(savedInstanceState);
        ActivityCollector.addActivity(this);
    }
    
    @Override
    protected void onDestroy(){
        super.onDestroy();
        ActivityCollector.removeActivity(this);
    }
    
}
```

首先需要创建一个登陆界面的活动，新建 LoginActivity，并让 Android Studio 帮我们自动生成相应的布局文件，然后编辑 activity_login.xml

```java
//使用 LinearLayout 编写出一个登陆布局，最外层是一个纵向的 LinearLayout，里面包含了3行直接子元素，第一行是一个横向 LinearLayout，用于输入账号信息；第二行也是一个横向的 LinearLayout，用于输入密码信息；第三行是一个登陆按钮
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <LinearLayout
        android:orientation="horizontal"
        android:layout_width="match_parent"
        android:layout_height="60dp">
        <TextView
            android:layout_width="90dp"
            android:layout_height="wrap_content"
            android:layout_gravity="center_vertical"
            android:textSize="18sp"
            android:text="Account:" />
        <EditText
            android:id="@+id/account"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:layout_gravity="center_vertical" />
    </LinearLayout>
    
    <LinearLayout
        android:orientation="horizontal"
        android:layout_width="match_parent"
        android:layout_height="60dp">
        <TextView
            android:layout_width="90dp"
            android:layout_height="wrap_content"
            android:layout_gravity="center_vertical"
            android:textSize="18sp"
            android:text="Password" />
        <EditText
            android:id="@+id/password"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:layout_gravity="center_vertical"
            android:inputType="textPassword" />
    </LinearLayout>
    
    <Button
        android:id="@+id/login"
        android:layout_width="match_parent"
        android:layout_height="60dp"
        android:text="Login" />
    
</LinearLayout>
```

修改 LoginActivity

```java
//首先将 LoginActivity 的继承结构改成继承自 BaseActivity
public class LoginActivity extends BaseActivity{

    private EditText accountEdit;
    
    private EditText passwordEdit;
    
    private Button login;
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_login);
        //然后调用 findViewById() 方法分别获取到账号输入框、密码输入框以及登陆按钮的实例
        accountEdit = (EditText) findViewById(R.id.account);
        passwordEdit = (EditText) findViewById(R.id.password);
        login = (Button) findViewById(R.id.login);
        //在登陆按钮的点击事件里面对输入的账号和密码进行判断
        login.setOnClickListener(new View.OnClickListener(){
            @Override
            public void onClick(View v){
                String account = accountEdit.getText().toString();
                String password = passwordEdit.getText().toString();
                //如果账号是 admin 且 密码是 123456，就认为登陆成功，跳转到 MainActivity，因此可以将 MAinActivity 理解为是登陆成功后进入的程序主界面
                if(account.equals("admin") && password.equals("123456")){
                    Intent intent = new Intent(LoginActivity.this, MainActivity.class);
                    startActivity(intent);
                    finish();
                } else {
                    Toast.makeText(LoginActivity.this, "account or password is invalid", Toast.LENGTH_SHORT).show();
                }
            }
        });
    }
}
```

在主界面 MainActivity 加入强制下线的功能，修改 activity_main.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <Button
        android:id="@+id/force_offline"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Send force offline broadcast" />

</LinearLayout>
```

修改 MainActivity

```java
public class MainActivity extends BaseActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button forceOffline = (Button) findViewById(R.id.force_offline);
        forceOffline.setOnClickListener(new View.OnClickListener() {
            //在按钮点击事件里发送了一条广播，广播的值为 com.example.broadcastbestpractice.FORCE_OFFLINE，这条广播就是用于通知程序强制用户下线的
            @Override
            public void onClick(View v) {
                Intent intent = new Intent("com.example.broadcastbestpractice.FORCE_OFFLINE");
                sendBroadcast(intent);
            }
        });
    }
}
```

强制用户下线的逻辑并不是写在 MainActivity 里的，而是应该写在接受这条广播的接收器里面，这样强制下线的功能就不会依附在任何的界面，不管是在程序的任何地方，只需要发送出这一条广播就可以完成强制下线的操作

如果创建的是一个静态注册的广播接收器，是没有办法在 onReceive() 方法里弹出对话框这样的 UI 控件的，也不可能在每个活动中都去注册一个动态的广播接收器。所以只需要在 BaseActivity 中动态注册一个广播接收器就可以了，因为所有的活动都是继承 BaseActivity

修改 BaseActivity

```java
public class BaseActivity extends AppCompatActivity {

    private ForceOfflineReceiver receiver;

    @Override
    protected void onCreate(Bundle savedInstanceState){
        super.onCreate(savedInstanceState);
        ActivityCollector.addActivity(this);
    }

    @Override
    protected void onResume(){
        super.onResume();
        //注册 ForceOfflineReceiver
        IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction("com.example.broadcastbestpractice.FORCE_OFFLINE");
        receiver = new ForceOfflineReceiver();
        registerReceiver(receiver, intentFilter);
    }

    @Override
    protected void onPause(){
        super.onPause();
        if(receiver != null){
            unregisterReceiver(receiver);
            receiver = null;
        }
    }

    @Override
    protected void onDestroy(){
        super.onDestroy();
        //取消 ForceOfflineReceiver
        ActivityCollector.removeActivity(this);
    }

    class ForceOfflineReceiver extends BroadcastReceiver{
        //onReceive() 
        @Override
        public void onReceive(final Context context, Intent intent){
            AlertDialog.Builder builder = new AlertDialog.Builder(context);
            builder.setTitle("Warning");
            builder.setMessage("You are forced to be offline.Please try to login again.");
            //调用 setCancelable() 方法将对话框设为不可取消
            builder.setCancelable(false);
            //使用 setPositiveButton() 方法来给对话框注册确定按钮，当用户点击了确定的按钮，就调用 ActivityCollector 的 finishAll() 方法来销毁所有活动，并重新启动 LoginActivity
            builder.setPositiveButton("OK", new DialogInterface.OnClickListener() {
                @Override
                public void onClick(DialogInterface dialog, int which) {
                    ActivityCollector.finishAll();//销毁所有活动
                    Intent i = new Intent(context, LoginActivity.class);
                    context.startActivity(i);//重新启动LoginActivity
                }
            });
            builder.show();
        }
    }

}
```

修改 AndroidManifest.xml 

```java
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.broadcastbestpractice">
    
    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        <activity
            android:name=".LoginActivity">
            //将主活动设置为 LoginActivity 而不再是 MainActivity
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        <activity android:name=".MainActivity">
        </activity>
    </application>

</manifest>
```







## 数据存储

Android 系统中主要提供了 3 种用于简单地实现数据持久化功能，即文件存储、SharedPreferences 存储以及数据库存储





### 文件存储

文件存储是 Android 中最基本的一种数据存储方式，它不对存储的内容进行任何格式化处理，所有的数据都是原封不动地保存到文件中，因而比较适合用于存储一些简单地文本数据或二进制数据，如果想要使用文件存储的方法来保存一些较为复杂的文本数据，就需要定义一套自己的格式规范，这样可以方便之后将数据从文件中重新解析出来



#### 将数据存储到文件中

Context 类中提供了一个 openFileOutput() 方法，可以用于将数据存储到指定的文件中，该方法接收两个参数，第一个参数是文件名，在文件创建的时候使用的就是这个名称，注意这里的文件名不可以包含路径，因为所有的文件都是默认存储到  /data/data/<package name>/files/  目录下的。第二个参数是文件的操作模式，主要有两种模式可以选，MODE_PRIVATE 和 MODE_APPEND。其中，MODE_PRIVATE 表示当指定同样文件名的时候，所写入的内容将会覆盖原文件中的内容，而 MODE_APPEND 则表示如果该文件已存在，就往文件里面追加内容，不存在就创建新文件

openFileOutput() 方法返回的是一个 FileOutputStream 对象（输出流），得到这个对象之后就可以使用 Java 流的方式将数据写入到文件中了

创建 FilePersistenceTest 项目，修改 activity_main.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    //在布局中加入了一个 EditText 用于输入文本内容
    <EditText
        android:id="@+id/edit"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="Type something here"/>

</LinearLayout>
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    private EditText edit;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        //在 onCreate() 中获取 EditText 实例
        edit = (EditText) findViewById(R.id.edit);
    }

    //重写 onDestroy()，保证在活动销毁之前调用这个方法
    @Override
    protected void onDestroy(){
        super.onDestroy();
        //获取 EditText 中的内容
        String inputText = edit.getText().toString();
        //调用 save() 方法把输入的内容存储到文件中，文件命名为 data
        sava(inputText);
    }

    //输出流
    public void sava(String inputText){
        FileOutputStream out = null;
        BufferedWriter writer = null;
        try{
            
            //openFileOutput() 方法，可以用于将数据存储到指定的文件中，该方法接收两个参数
            //第一个参数是文件名，在文件创建的时候使用的就是这个名称，注意这里的文件名不可以包含路径，因为所有的文件都是默认存储到  /data/data/<package name>/files/  目录下的。
            //第二个参数是文件的操作模式，主要有两种模式可以选，MODE_PRIVATE 和 MODE_APPEND。其中，MODE_PRIVATE 表示当指定同样文件名的时候，所写入的内容将会覆盖原文件中的内容，而 MODE_APPEND 则表示如果该文件已存在，就往文件里面追加内容，不存在就创建新文件
            
            //openFileOutput() 方法返回的是一个 FileOutputStream 对象，得到这个对象之后就可以使用 Java 流的方式将数据写入到文件中了
            out = openFileOutput("data", Context.MODE_PRIVATE);
            //借助 FileOutputStream 对象构建出一个 OutputStreamWriter 对象，在借助这个对象构建出一个 BufferedWriter 对象，这样就可以通过 BufferedWriter 来讲文本内容写入到文件中
            writer = new BufferedWriter(new OutputStreamWriter(out));
            writer.write(inputText);
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (writer != null){
                    writer.close();
                }
            } catch (IOException e){
                e.printStackTrace();
            }
        }
    }

}
```

借助 Android Device Monitor 工具来查看，进入 File Explorer 标签页，找到  /data/data/com.example.filepersistencetest/files/ 目录，可以看到生成一个 data 文件



#### 从文件中读取数据

Context 类中还提供了一个 openFileInput() 方法，用于从文件中读取数据，它只接收一个参数，即要读取的文件名，然后系统自动到 /data/data/com.example.filepersistencetest/files/ 目录下去加载这个文件，并返回一个 FileInputStream 对象，得到这个对象后再通过 Java 流的方式就可以将数据读取出来

首先通过 openFileInput() 方法获取到了一个 FileInputStream 对象（输入流），然后借助它有构建了一个 InputStreamReader 对象，接着再使用 InputStreamReader 构建出一个 BufferedReader 对象，这样就可以通过 BufferedReader 进行一行行地读取，把文件中所有的文本内容读取出来，并存放在一个 StringBuilder 对象中，最后将读取到的内容返回即可

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    private EditText edit;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        edit = (EditText) findViewById(R.id.edit);
        //在 onCreate() 方法中调用 load() 方法来读取文件中存储的文本内容
        String inputText = load();
        //如果读到的内容不为 null，就调用 EdiText 的 setText() 方法将内容填充到 EditText 里，并调用 setSelection() 方法将输入光标移动到文本的末尾位置以便于急需输入，然后弹出一句还原成功
        
        //对于非空判断的时候使用了 TextUtils.isEmpty() 方法，它可以一次性进行两种空值的判断，当传入的字符串等于 null 或者等于空字符串的时候，这个方法都会返回 true，从而使得我们不需要先单独判断这两种空值在使用逻辑运算符连接起来
        if (!TextUtils.isEmpty(inputText)){
            edit.setText(inputText);
            edit.setSelection(inputText.length());
            Toast.makeText(this, "Restoring successedd", Toast.LENGTH_SHORT).show();
        }
    }

	...

    //输入流
    public String load(){
        FileInputStream in = null;
        BufferedReader reader = null;
        StringBuilder content = new StringBuilder();
        try {
            //openFileInput() 方法，用于从文件中读取数据，它只接收一个参数，即要读取的文件名，然后系统自动到 /data/data/com.example.filepersistencetest/files/ 目录下去加载这个文件，并返回一个 FileInputStream 对象
            in = openFileInput("data");
            //借助 FileInputStream 构建了一个 InputStreamReader 对象，接着再使用 InputStreamReader 构建出一个 BufferedReader 对象，这样就可以通过 BufferedReader 进行一行行地读取，把文件中所有的文本内容读取出来，并存放在一个 StringBuilder 对象中，最后将读取到的内容返回即可
            reader = new BufferedReader(new InputStreamReader(in));
            String line = "";
            while((line = reader.readLine()) != null){
                content.append(line);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException e){
                    e.printStackTrace();
                }
            }
        }
        return content.toString();
    }

}
```

核心技术是使用 Context 类提供的 openFileInput() 和 openFileoutput() 方法，之后就是利用 Java 的各种流来进行读写操作





### SharedPreferences

SharedPreferences 是使用键值对的方式来存储数据的，当保存一条数据的时候，需要给这条数据提供一个对应的键值对，这样在读取数据的时候就可以通过这个键把相应的值取出来，而且 SharedPreferences 还支持多种不同数据类型存储，如果存储的数据类型是整型，那么读取出来的数据也是整型的；如果存储的数据是一个字符串，那么读取出来的数据仍然是字符串



#### 将数据存储到 SharedPreferences

使用 SharedPreferences  来存储数据，首先需要获取到 SharedPreferences  对象，Android 主要提供了 3 种方法用于得到 SharedPreferences  对象

- Context 类中的 getSharedPreferences() 方法

此方法接收两个参数，第一个参数用于指定 SharedPreferences 文件的名称，如果指定的文件不存在则会创建一个，SharedPreferences  文件都是存放在 /data/data/<package name>/shared_prefs/ 目录下的，第二个参数是用于指定操作模式，目前只有 MODE_PRIVATE 这一种模式可选，他是默认的操作模式，和直接传入 0 效果相同，表示只有当前的应用程序才可以对 SharedPreferences  文件进行读写

- Activity 类中的 getPreferences() 方法

该方法和 Context 中的 getSharedPreferences() 方法很相似，不过它只接收一个操作模式参数，因为使用这个方法时会将当前活动的类名作为 SharedPreferences  的文件名

- PreferenceManager 类中的 getDefaultSharedPreferences 

这是一个静态方法，接收一个 Context 参数，自动使用当前应用程序的包名作为前缀来命名 SharedPreferences  文件，得到了 SharedPreferences  对象之后就可以向 SharedPreferences  文件中存储数据了

新建 SharedPreferencesTest 项目，修改 activity_main.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

	//简单地放置一个按钮，用于将一些数据存储到 SharedPreferences 文件当中
    <Button
        android:id="@+id/save_data"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Save data"
        />
    
</LinearLayout>
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button saveData = (Button) findViewById(R.id.save_data);
        //给按钮注册一个点击事件，然后在点击事件中通过 getSharedPreferences() 方法指定 SharedPreferences 的文件名为 data，并得到了 SharedPreferences.Editor 对象，接着向这个对象添加了 3 条不同类型的数据，最后调用 apply 方法进行提交从而完成数据存储的操作
        saveData.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                //调用 SharedPreferences 对象的 edit() 方法来获取一个 SharedPreferences.Editor 对象
                SharedPreferences.Editor editor = getSharedPreferences("data", MODE_PRIVATE).edit();
                //向 SharedPreferences.Editor 中添加数据
                editor.putString("name", "Tom");
                editor.putInt("age", 28);
                editor.putBoolean("married", false);
                //调用 apply 方法进行提交从而完成数据存储的操作
                editor.apply();
            }
        });
    }
}
```

借助 File Explorer 来进行查看，进入 /data/data/sharedpreferencestest/shared_prefs/ 目录下，生成一个 data.xml 文件

SharedPreferences 文件是使用 XML 格式来对数据进行管理的



#### 从 SharedPreferences  中读取数据

SharedPreferences 对象中提供了一系列 get 方法，用于对存储的数据进行读取，每种 get 方法都对应了 SharedPreferences.Editor 的一种 put 方法

这些 get 方法都接受两个参数，第一个参数是键，传入存储数据时使用的键就可以得到相应的值了；第二个参数是默认值，即表示当传入的键找不到对应的值时会以什么样的默认值进行返回

修改 activity_main.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <Button
        android:id="@+id/save_data"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Save data"
        />

    //增加一个还原数据的按钮，通过点击这个按钮来从 SharedPreferences 文件中读取数据
    <Button
        android:id="@+id/restore_data"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Restore data"
        />

</LinearLayout>
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        
        ...
        
        Button restoreData = (Button) findViewById(R.id.restore_data);
        restoreData.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                //首先通过 getSharedPreferences() 方法得到了 SharedPreferences 对象
                SharedPreferences pref = getSharedPreferences("data", MODE_PRIVATE);
                //调用了不同的 get 方法，第一个参数是键，传入存储数据时使用的键就可以得到相应的值了；第二个参数是默认值，即表示当传入的键找不到对应的值时会以什么样的默认值进行返回
                String name = pref.getString("name", "");
                int age = pref.getInt("age", 0);
                boolean married = pref.getBoolean("married", false);
                //最后通过 Log 将这些值打印出来
                Log.d("MainActivity", "name is " + name);
                Log.d("MainActivity", "age is " + age);
                Log.d("MainActivity", "married is " + married);
            }
        });
    }
}
```



#### 实现记住密码功能

打开 BroadcastTest，修改 activity_login.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

	...

    <LinearLayout
        android:orientation="horizontal"
        android:layout_width="match_parent"
        android:layout_height="wrap_content">
        //新控件 CheckBox，这是一个复选框控件，用户可以通过点击的方式进行选中取消
        <CheckBox
            android:id="@+id/remember_pass"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content" />
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textSize="18sp"
            android:text="Remember psaaword" />

    </LinearLayout>

    <Button
        android:id="@+id/login"
        android:layout_width="match_parent"
        android:layout_height="60dp"
        android:text="Login" />

</LinearLayout>
```

修改 LoginActivity

```java
public class LoginActivity extends BaseActivity{

    private SharedPreferences pref;

    private SharedPreferences.Editor editor;

    private EditText accountEdit;

    private EditText passwordEdit;

    private Button login;

    private CheckBox rememberPass;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_login);
        //获取 SharedPreferences 对象
        pref = PreferenceManager.getDefaultSharedPreferences(this);
        accountEdit = (EditText) findViewById(R.id.account);
        passwordEdit = (EditText) findViewById(R.id.password);
        rememberPass = (CheckBox) findViewById(R.id.remember_pass)
        login = (Button) findViewById(R.id.login);
        //调用 get 方法去获取 remember_password 这个键对应的值，一开始不存在对应的值，所以会使用默认值是 false，这样什么都不会发生
        boolean isRemember = pref.getBoolean("remember_password", false);
        if (isRemember) {
            //将账号和密码都设置到文本框中
            String account = pref.getString("account", "");
            String password = pref.getString("password", "");
            accountEdit.setText(account);
            passwordEdit.setText(password);
            rememberPass.setChecked(true);
        }
        login.setOnClickListener(new View.OnClickListener(){
            @Override
            public void onClick(View v){
                String account = accountEdit.getText().toString();
                String password = passwordEdit.getText().toString();
                //如果账号是 admin 且 密码是 123456，就认为登陆成功
                if(account.equals("admin") && password.equals("123456")){
                    editor = pref.edit();
                    //登录成功后，调用 CheckBox 的 isChecked() 方法来检查复选框是否被选中，如果选中了则表示用户想要记住密码，这时将 remember_password 设为 true，然后把 account 和 password 对应的值都存到 SharedPreferences 文件当中并提交。如果没用被选中，则调用 clear() 方法将 SharedPreferences 文件中的数据全部清除掉
                    if (rememberPass.isChecked()) {//检查复选框是否选中
                        editor.putBoolean("remember_password", true);
                        editor.putString("account", account);
                        editor.putString("password", password);
                    } else {
                        editor.clear();
                    }
                    editor.apply();
                    Intent intent = new Intent(LoginActivity.this, MainActivity.class);
                    startActivity(intent);
                    finish();
                } else {
                    Toast.makeText(LoginActivity.this, "account or password is invalid", Toast.LENGTH_SHORT).show();
                }
            }
        });
    }
}
```

此时密码以明文的形式存储在 SharedPreferences 文件中，正式的项目里需要结合一定的加密算法来对密码进行保护才行



### SQLite 数据库存储

SQLite 是一款轻量级的 Android 内置的关系型数据库，它的运算速度非常快，占用资源很少，通常只需要几百 KB 的内存就足够了，它不仅支持标准的 SQL 语法，还遵循数据库的 ACID 事务，其又比一般的数据库简单得多，它甚至不用设置用户名和密码就可以使用，Android 把这个数据库嵌入到了系统当中



#### 创建数据库

Android 为了让我们能够更加方便地管理数据库，专门提供了一个 SQLiteOpenHelper 帮助类，借助这个类就可以非常简单地对数据库进行创建和升级

SQLiteOpenHelper 是一个抽象类，想要使用它的话就需要创建一个自己的帮助类去继承它。SQLiteOpenHelper 中有两个抽象方法，分别是 onCreate() 和 onUpgrade()，我们必须在自己的帮助类里面重写这两个方法，然后分别在这两个方法中去实现创建、升级数据库的逻辑

SQLiteOpenHelper 还有两个非常重要的实例方法：getReadableDatabase() 和 getWritableDatabase()，这两个方法都可以创建或打开一个现有的数据库（如果数据库已存在则直接打开，否则创建新的数据库），并返回一个可对数据库进行读写操作的对象。不同的是当数据库不可写入的时候（如磁盘空间已满），getReadableDatabase() 方法返回的对象将以只读的方式去打开数据库，而 getWritableDatabase() 方法则将出现异常

SQLiteOpenHelper 中有两个构造方法可供重写，一般使用参数少一点的那个构造方法即可，这个构造方法中接收 4 个参数，第一个参数是 Context，必须要有它才能对数据库进行操作；第二个参数是数据库名，创建数据库时使用的就是这里指定的名称；第三个参数允许我们在查询数据的时候返回一个自定义的 Cursor，一般都是传入 null；第四个参数表示当前数据库的版本号，可用于对数据库进行升级操作，构建出 SQLiteOpenHelper 实例后，在调用它的 getReadableDatabase() 或 getWritableDatabase() 方法就能够创建数据库了，数据库文件会放在 /data/data/<package name>/database/ 目录下，此时重写的 onCreate() 方法也会得到执行，所以通常会在这里去处理一些创建表的逻辑

新建一个 DatabaseTest 项目，新建 MyDatabaseHelper 继承自 SQLiteOpenHelper

```java
public class MyDatabaseHelper extends SQLiteOpenHelper {
    
    //把建表语句定义成了一个字符串常量
    public static final String CREATE_BOOK = "create table Book ( "
            + "id integer primary key autoincrement, "
            + "author text, "
            + "price real, "
            + "pages integer, "
            + "name text) ";
    
    private Context mContext;
    
    //SQLiteOpenHelper 中有两个构造方法可供重写，一般使用参数少一点的那个构造方法即可，这个构造方法中接收 4 个参数，第一个参数是 Context，必须要有它才能对数据库进行操作；第二个参数是数据库名，创建数据库时使用的就是这里指定的名称；第三个参数允许我们在查询数据的时候返回一个自定义的 Cursor，一般都是传入 null；第四个参数表示当前数据库的版本号，可用于对数据库进行升级操作，构建出 SQLiteOpenHelper 实例后，在调用它的 getReadableDatabase() 或 getWritableDatabase() 方法就能够创建数据库了，数据库文件会放在 /data/data/<package name>/database/ 目录下，此时重写的 onCreate() 方法也会得到执行，所以通常会在这里去处理一些创建表的逻辑
    public MyDatabaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version){
        super(context, name, factory, version);
        mContext = context;
    }
    
    //在 onCreate() 方法中又调用了 SQLiteDatabase 的 execSQL() 方法去执行这条建表语句，并弹出一个 Toast 提示创建成功，这样保证数据库创建完成的时候还能成功创建 Book 表
    @Override
    public void onCreate(SQLiteDatabase db){
        db.execSQL(CREATE_BOOK);
        Toast.makeText(mContext, "Create succeeded", Toast.LENGTH_SHORT).show();
    }
    
    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion){
    }
    
}
```

修改 activity_main.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

	//加入一个按钮，用于创建数据库
    <Button
        android:id="@+id/create_database"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Create database" />

</LinearLayout>
```

修改 MainActivity 

```java
public class MainActivity extends AppCompatActivity {

    private MyDatabaseHelper dbHelper;
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        //在 onCreate() 方法中构建了一个 MyDatabaseHelper 对象，并且通过构造函数的参数将数据库名指定为 BookStore.db，版本号指定为 1
        dbHelper = new MyDatabaseHelper(this, "BookStore.db", null, 1);
        //在 createDatabase 按钮的点击事件里调用了 getWritableDatabase() 方法
        Button createDatabase = (Button) findViewById(R.id.create_database);
        createDatabase.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                dbHelper.getWritableDatabase();
            }
        });
    }
}
```

第一次点击 Create databse 按钮时，就会检测到当前程序中并没有 BOOKStore.db 这个数据库，于是会创建数据库并调用 MyDatabaseHelper 中的 onCreate() 方法，这样 Book 表也得到了创建，然后弹出一个 Toast 提示创建成功，再次点击按钮，会发现此时已经存在了 BookStore.db 数据库了，因此不会再创建一次，所以不会再有 Toast 弹出

使用 File Explorer 只能看到 databases 目录下出现一个 BookStore.db 文件，Book 表是无法通过 File Explorer 看到的，因此我们换成使用 adb shell 来对数据库和表的创建情况进行检查

adb 是 Android SDK 中自带的一个调试工具，该工具可以直接对连接在电脑上的手机或模拟器进行调试操作，让放在 sdk 的 platform-tools 目录下，在命令行中使用这个工具，需要把他的路径配置到环境变量里

输入 adb shell 出现 # 是超级管理员的意思是，也就是说现在你可以访问模拟器中的一切数据，如果命令行上是 $，那么表示你是普通管理员，输入 su 命令切换成超级管理员

使用 cd 命令进入到 /data/data/com.example.databasetest/databases/ 目录下，并使用 ls 命令查看到该目录里的文件

这个目录下出现了两个数据库文件，一个是我们创建的 BookStore.db 文件，另一个是 BookStore.db-journal 则是为了让数据库能够支持事务而产生的临时日志文件，通常情况下这个文件大小都是 0 字节

键入 sqlite3，后面加上数据库名即可打开数据库

打开数据库后就可以对数据库中的表进行管理，键入 .table 来查看数据库中有哪些表

其中有两张表， android_metadata 表是每个数据库中都会自动生成的，不用管它，另一张表 Book 就是我们在 MyDatabaseHelper 中创建的

通过 .schema 命令来查看检表语句

最后键入 .exit 或 .quit 命令可以退出数据库编辑，再键入 exit 命令就可以退出设备控制台



#### 升级数据库

onUpgrade() 方法适用于对数据库进行升级的

修改 MyDatabaseHelper

```java
public class MyDatabaseHelper extends SQLiteOpenHelper {

    public static final String CREATE_BOOK = "create table Book ( "
            + "id integer primary key autoincrement, "
            + "author text, "
            + "price real, "
            + "pages integer, "
            + "name text)";

	//再添加一张 Category 的表
    public static final String CREATE_CATEGORY = "create table Category ( "
            + "id integer primary key autoincrement, "
            + "category_name text, "
            + "category_code integer)";

    private Context mContext;

    public MyDatabaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version){
        super(context, name, factory, version);
        mContext = context;
    }

    @Override
    public void onCreate(SQLiteDatabase db){
        db.execSQL(CREATE_BOOK);
        db.execSQL(CREATE_CATEGORY);
        Toast.makeText(mContext, "Create succeeded", Toast.LENGTH_SHORT).show();
    }

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion){
    }

}
```

运行后再点击按钮，不会弹出 Toast，运行 adb 工具再检查一下，Category 确实没有创建成功，因为 BookStore.db 数据库已经存在，之后无论再怎么点击按钮，MyDatabaseHelper 中的 onCreate() 方法都不会再次执行，因此新添加的表也就无法得到创建

一种方法是卸载程序，再重新运行，这是 BookStore.db 数据库不存在，再点击按钮就会执行 MyDatabaseHelper 中的 onCreate() 方法就会执行，做法和极端，可以运用 SQLiteOpenHelper 的升级功能轻松的解决这个问题

修改 MyDatabaseHelper 

```java
public class MyDatabaseHelper extends SQLiteOpenHelper {

    public static final String CREATE_BOOK = "create table Book ( "
            + "id integer primary key autoincrement, "
            + "author text, "
            + "price real, "
            + "pages integer, "
            + "name text)";

    public static final String CREATE_CATEGORY = "create table Category ( "
            + "id integer primary key autoincrement, "
            + "category_name text, "
            + "category_code integer)";

    private Context mContext;

    public MyDatabaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version){
        super(context, name, factory, version);
        mContext = context;
    }

    @Override
    public void onCreate(SQLiteDatabase db){
        db.execSQL(CREATE_BOOK);
        db.execSQL(CREATE_CATEGORY);
        Toast.makeText(mContext, "Create succeeded", Toast.LENGTH_SHORT).show();
    }

    // onUpgrade() 方法中执行了两条 DROP 语句，如果发现数据库中已经存在 Book 表或 Category 表，就将这两张表删除，再调用 onCreate() 方法，因为如果不删除数据库中存在了表，那么就会直接报错
    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion){
        db.execSQL("drop table if exists Book");
        db.execSQL("drop table if exists Category");
        onCreate(db);
    }

}
```

修改 SQLiteOpenHelper 的构造函数第四个参数，数据库的版本号，现在只要传入比 1 大的数就可以让 onUpgrade() 方法得到执行，修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    private MyDatabaseHelper dbHelper;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        //将数据库版本号指定为 2，表示我们对数据库进行了升级
        dbHelper = new MyDatabaseHelper(this, "BookStore.db", null, 2);
        Button createDatabase = (Button) findViewById(R.id.create_database);
        createDatabase.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                dbHelper.getWritableDatabase();
            }
        });
    }
}
```

重新运行程序后点击按钮出现了 Toast 提示创建成功，可通过 adb 进行验证表确实建立了



#### 添加数据

对数据进行的操作无非有四种（CRUD），C 代表添加（Create），R 代表查询（Retrieve），U 代表更新（Update），D 代表删除（Delete），SQL语言添加数据使用 insert，查询数据使用 select，更新数据使用 update，删除数据用 delete

Android 提供了一系列的辅助性方法，使得不用去编写 SQL 语句也能完成所有的 CRUD 操作

调用 SQLiteOpenHelper 的 getReadableDatabase() 或 getWritableDatabase() 方法可以用于创建和升级数据库，不仅如此，这两个方法还都会返回一个 SQLiteDatabase 对象，借助这个对象就可以数据进行 CRUD 操作

向数据库的表中添加数据，SQLiteDatabase 中提供了一个 insert() 方法，它接收 3 个参数，第一个参数是表名，指定向那张表添加数据；第二个参数用于在未指定添加数据的情况下给某些可为空的列自动赋值 null，一般我们都用不到这个功能，直接传入 null 即可；第三个参数是一个 ContentValues 对象，它提供一系列的 put() 方法重载，用于向 ContentValues 中添加数据，只需要将表中的每个列名以及相应待添加数据传入即可

修改 activity_main.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <Button
        android:id="@+id/create_database"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Create database" />

    //新增了一个按钮，稍后在这个按钮的点击事件里编写添加数据的逻辑
    <Button
        android:id="@+id/add_data"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Add data" />

</LinearLayout>
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    private MyDatabaseHelper dbHelper;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        dbHelper = new MyDatabaseHelper(this, "BookStore.db", null, 2);
       
        ...
        
        Button addData = (Button) findViewById(R.id.add_data);
        addData.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                //先获取到 SQLiteDatabase 对象，然后使用 ContentValues 来对要添加的数据进行组装
                SQLiteDatabase db = dbHelper.getWritableDatabase();
                ContentValues values = new ContentValues();
                //id 那一列并没有给它赋值，因为在前面创建表的时候，我们就将 id 列设置为自增长，它的值会在入库的时候自动生成，所以不需要手动给它赋值
                //开始组装第一条程序
                values.put("name", "The Da Vinci Code");
                values.put("author", "Dan Brown");
                values.put("pages", 454);
                values.put("price", 16.96);
                //调用了 insert() 方法将数据添加到了表当中
                db.insert("Book", null, values);//插入第一条数据
                //开始组装第二条程序
                values.put("name", "The Lost Symbol");
                values.put("author", "Dan Brown");
                values.put("pages", 510);
                values.put("price", 19.95);
                db.insert("Book", null, values);//插入第二条数据
            }
        });
    }
}
```

点击一下 Add data 按钮，打开 BookStore.db，输入 select * from Book; 查询 Book 表中的数据



#### 更新数据

SQLiteDatabase 中也提供了一个非常好用的 updata() 方法，用于对数据进行更新，这个方法接收 4 个参数，第一个参数和 insert() 方法一样是表名，在这里指定去更新哪张表里的数据；第二个参数是 ContentValues 对象，要把更新数据在这里组装进去；第三四个参数用于约束更新某一行或某几行中的数据，不指定的话默认就是更新所有行

修改 activity_main.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

	...

    //添加了一个用于更新数据的按钮
    <Button
        android:id="@+id/update_data"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Update data" />

</LinearLayout>
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    private MyDatabaseHelper dbHelper;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        dbHelper = new MyDatabaseHelper(this, "BookStore.db", null, 2);

		...

        Button updateData = (Button) findViewById(R.id.update_data);
        updateData.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                SQLiteDatabase db = dbHelper.getWritableDatabase();
                //构建一个 ContentValues 对象，并且给它指定了一组数据，说明我们只是想把价格这一列的数据更新成 10.99，然后调用了 SQLiteDatabase 的 update() 方法去执行具体的更新操作
                ContentValues values = new ContentValues();
                values.put("price", 10.99);
                //这里 update() 方法的第三、四个参数来指定具体更新到哪行，第三个参数对应的是 SQL 语句的 where 部分，表示更新所有 name 等于 ？的行，而 ？是一个占位符，可以通过第四个参数提供的一个字符串数组为第三个参数中的每个占位符指定相应的内容
                db.update("Book", values, "name = ?", new String[]{"The Da Vinci Code"});
                //以上代码意图是将名字是 The Da Vinci Code 的这本书的价格改成 10.99
            }
        });
    }
}
```



#### 删除数据

SQLiteDatabase 中提供了一个 delete() 方法，专门用于删除数据，这个方法接收 3 个参数，第一个参数是表名，第二、三个参数又是用于约束删除某一行或某几行的数据，不指定的话默认就是删除所有行

修改 acticity_main.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

	...
    
    //添加一个按钮，用于删除数据
    <Button
        android:id="@+id/delete_data"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Delete data" />

</LinearLayout>
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    private MyDatabaseHelper dbHelper;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        dbHelper = new MyDatabaseHelper(this, "BookStore.db", null, 2);

        ...
        
        //在删除按钮的点击时间里指明去删除 Book 表中的数据，并通过第二、三个参数来指定仅删除那些页数超过 500 页的书
        Button deleteButton = (Button) findViewById(R.id.delete_data);
        deleteButton.setOnClickListener(new View.OnClickListener(){
            @Override
            public void onClick(View v){
                SQLiteDatabase db = dbHelper.getWritableDatabase();
                db.delete("Book", "pages > ?", new String[]{"500"});
            }
        });
    }
}
```



#### 查询数据

SQLiteDatabase 提供了一个 query() 方法用于对数据进行查询，该方法最短的一个需要传入七个参数，第一个参数是表名；第二个参数是用于指定趣查询哪几列，如果不指定则默认查询所有列；第三、四个参数用于约束查询某一行或某几行的数据，不指定则默认查询所有行的数据；第五个参数用于指定需要去 group by 的列，不指定则表示不对查询结果进行 group by 操作；第六个参数用于对 group by 之后的数据进一步过滤，不指定则表示不进行过滤；第七个参数用于指定查询结果的排列方式，不指定则表示使用默认的排序方式

修改 activity_main.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

 	...

    //添加一个按钮用于查询数据
    <Button
        android:id="@+id/query_data"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Query data" />

</LinearLayout>
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    private MyDatabaseHelper dbHelper;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        dbHelper = new MyDatabaseHelper(this, "BookStore.db", null, 2);

	   ...

        //在查询按钮的点击事件里面调用了 SQLiteDatabase 的 query() 方法去查询数据
        Button queryButton = (Button) findViewById(R.id.query_data);
        queryButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                SQLiteDatabase db = dbHelper.getWritableDatabase();
                //查询 Book 表中的所有数据，只是使用了第一个参数指明去查询 Book 表，后面的参数全为 null，表示查询该表中的所有数据，查询之后得到了一个 Cursor 对象，接着调用它的 moveToFirst() 方法将数据的指针移动到了第一行的位置，然后进入到了一个循环当中去遍历查询到的每一行数据
                Cursor cursor = db.query("Book", null, null, null, null, null, null);
                if (cursor.moveToFirst()) {
                    //循环中通过 Cursor 的 getColumnIndex() 方法获取到某一列在表中对应的位置索引，然后将这个索引传入到相应取值方法中，就可以得到从数据库中读取到的数据，
                    do {
                        //遍历 Cursor 对象，取出数据并打印
                        String name = cursor.getString(cursor.getColumnIndex("name"));
                        String author = cursor.getString(cursor.getColumnIndex("author"));
                        int pages = cursor.getInt(cursor.getColumnIndex("pages"));
                        double price = cursor.getDouble(cursor.getColumnIndex("price"));
                        //使用 Log 的方式将取出的数据打印出来，借此来检查一下读取数据工作有没有成功完成
                        Log.d("MainActivity", "book name is " + name);
                        Log.d("MainActivity", "author name is " + author);
                        Log.d("MainActivity", "pages name is " + pages);
                        Log.d("MainActivity", "price name is " + price);
                    } while (cursor.moveToNext());
                }
                //调用 close() 方法来关闭 Cursor
                cursor.close();
            }
        });
    }
}
```



#### 使用 SQL 操作数据库

添加、更新、删除均是

```java
db.execSQL(" ****** ");//***填写 SQL 语句
```

查询

```java
db.rawQuery(" ****** ");
```





### 使用 LitePal 操作数据库

LitePal 是一个开源的数据库框架，它采用了对象关系映射（ORM）的模式，并将我们平时开发最常用到的一些数据库功能进行封装，使得不用编写一行 SQL 语句就可以完成各种建表和增删改查的操作



#### 配置 LitePal

大多数开源的项目都会将版本提交到 jcenter 上，我们只需要在 app/build.gradle 文件声明该开源库的引用就可以

编辑 app/build.gradle

```java
implementation 'org.litepal.android:core:1.4.1'
```

新建一个 LitePalTest 项目

右击 app/src/main 目录 -> New -> Directory，创建一个 asserts 目录，然后在 assets 目录下再新建一个 litepal.xml 文件，编辑 litepal.xml

```java
<?xml version ="1.0" encoding ="utf-8"?>
<litepal>
	//<dbname> 标签用于指定数据库名
    <dbname value="BookStore"></dbname>

	//<version> 标签用于指定数据库版本号
    <version value="1"></version>

	//<list> 用于指定所有的映射模型
    <list>
    </list>
</litepal>
```

 配置 LitePalApplication，修改 AndroidManifest.xml

```java
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.litepaltest">

    <application
    	//将项目的配置为 org.litepal.LitePalApplication，这样才能让 LitePal 的所有功能都可以正常工作
        android:name="org.litepal.LitePalApplication"
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">

	    ...

    </application>

</manifest>
```



#### 创建和升级数据库

将 activity_main.xml 布局文件从 DatabaseTest 项目复制到 ListPalTest 项目中

LitePal 采用的是映射模式（ORM），我们使用的编程语言是面向对象语言，而使用的数据库则是关系型数据库，将面向对象的语言和面向关系的数据库之间建立一种映射关系，这就是对象关系映射

面向对象的思维来错做数据库，不用再和 SQL 语句打交道了

新建一个 Book 类

```java
public class Book {

    private int id;

    private String author;

    private double price;

    private int pages;

    private String name;

    public int getId(){
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getAuthor() {
        return author;
    }

    public void setAuthor(String author) {
        this.author = author;
    }

    public double getPrice() {
        return price;
    }

    public void setPrice(double price) {
        this.price = price;
    }

    public int getPages() {
        return pages;
    }

    public void setPages(int pages) {
        this.pages = pages;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

快速生成 getter 和 setter 方法

- code -> Generate
- Alt + Insert 键

shift 键将所有字段都选中

Book 类就会对应数据库中的 Book 表，列中的每一个字段分别对应了表中的没一个列，这就是对象关系映射最直观的体验，还需要将 Book 类添加到映射模型列表当中，修改 litepal.xml

```java
<litepal>
    <dbname value="BookStore"></dbname>

    <version value="1"></version>

    <list>
    	//使用 <mapping> 标签来声明我们要配置的映射模型类，注意一定要使用完整的类名，不管有多少模型需要映射，都是用同样的方法配置在 <list> 标签下即可
        <mapping class="com.example.litepaltest.Book"></mapping>
    </list>
</litepal>
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button createDatabase = (Button) findViewById(R.id.create_database);
        createDatabase.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                //调用 LitePal.getDatabase() 方法，只要点击一下按钮就会自动创建数据库
                LitePal.getDatabase();
            }
        });
    }
}
```

点击 CREATE DATABASE 按钮后可以看到新建了三张表，其中 android_metadata 不用管，table_schema 表是  LitePal 内部使用的， book 表就是根据我们定义的 Book 类以及类中的字段来自动生成的

SQLiteOpenHelper 升级数据库的时候我们需要先把之前的表 drop 掉，然后再重新建才行，这样会造成每升级一次数据库之前表中的数据就全没了。而 LitePal 只需要改你想要改的任何内容，然后再版本号加 1 就行,

修改 Book 

```java
package com.example.litepaltest;

public class Book {

	...

    private String press;

    public String getPress() {
        return press;
    }

    public void setPress(String press) {
        this.press = press;
    }

	...
	
}
```

添加一张 Category 表，只需要新建一个 Category 的类

```java
public class Category {
    
    private int id;
    
    private String categoryName;
    
    private int categoryCode;

    public void setId(int id) {
        this.id = id;
    }

    public void setCategoryName(String categoryName) {
        this.categoryName = categoryName;
    }

    public void setCategoryCode(int categoryCode) {
        this.categoryCode = categoryCode;
    }
}
```

添加了一个新的模型类，因此需要将它添加到映射模型列表中，修改 litepal.xml

```java
<?xml version ="1.0" encoding ="utf-8"?>
<litapal>
    <dbname value="BookStore"></dbname>

	//改完了想要改的东西之后只需要记得把版本号加 1 就行
    <version value="2"></version>

    <list>
        <mapping class="com.example.litepaltest.Book"></mapping>
        <mapping class="com.example.litepaltest.Category"></mapping>
    </list>
</litapal>
```

这样 book 表中新增了一个 press 列，category 表也创建成功了，LitePal 还自动帮我们保留了之前表中的所有数据



#### 使用 LitePal 添加数据

LitePal 添加数据只需要创建出模型类的实例，再将所有的要存储的数据设置好，最后调用一下 save() 方法就可以

LitePal 进项表管理操作时不需要模型类有任何的继承结构，但是进行 CRUD 操作时就不行了，必须要继承自 DataSupport 类才行

修改 Book

```java
public class Book extends DataSupport {
	...
}
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
	    
        ...
            
        Button addData = (Button) findViewById(R.id.add_data);
        addData.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                //创建一个 Book 实例，再调用 Book 类中的各种 set 方法对数据进行设置，最后调用 book.save() 方法就能完成数据的添加操作
                Book book = new Book();
                book.setName("The Da Vinci Code");
                book.setAuthor("Dan Brown");
                book.setPages(454);
                book.setPrice(16.96);
                book.setPress("Unknow");
                //save() 方法来自 Book 类继承的 DataSupport
                book.save();
            }
        });
    }
}
```

点击一次 Add data 按钮数据就添加成功了



#### 使用 LItePal 更新数据

使用 LitePal 更新数据的 API 接口比较多，最简单的一种更新方式就是对已存储的对象重新设值，然后调用 save() 方法即可

对于 LitePal，对象是否已存储就是根据 model.isSaved() 方法的结果来判断的，返回 true 就表示已存储，返回 false 就表示为存储。实际上只有两种情况下 model.isSaved() 方法才会返回 true，一种情况时已经调用过了 model.save() 方法去添加数据了，此时 model 会被认为是已存储的对象；另一种情况是 model 对象是通过 LitePal 提供的查询 API 查出来的，由于是从数据库中查到的对象，因此也会被认为是已存储的对象，接下来使用第一种方法

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        ...
        
        Button updateData = (Button) findViewById(R.id.update_data);
        updateData.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Book book = new Book();
                //添加了一条 Book 数据，然后调用 setPrice() 方法将这本书进行修改，之后再次调用 save() 方法，此时 LitePal 会发现当前的 Book 对象是已存储的，因此不会再向数据库中去添加一条新数据，而是会直接更新当前数据
                book.setName("The Lost Symbol");
                book.setAuthor("Dan Brown");
                book.setPages(510);
                book.setPrice(19.95);
                book.setPress("Unknow");
                book.save();
                book.setPrice(10.99);
                book.save();
            }
        });
    }
}
```

改方法限制性比较大，另一种方法，修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

		...

        Button updateData = (Button) findViewById(R.id.update_data);
        updateData.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Book book = new Book();
                book.setPrice(14.95);
                book.setPress("Anchor");
                //这里我们将指定书名是 The Lost Symbol 并且作者是 Dan Brown 的书价更新为 14.95，出版社更新为 Anchor
                book.updateAll("name = ? and author = ?", "The Lost Symbol", "Dan Brown");
            }
        });
    }
}
```

使用 updateAll() 方法时，当你想要把一个字段的值更新成默认值时，是不可以使用上面的方式来 set 数据的，因为 Java 中任何一种数据类型的字段都会有默认值，例如：int 类型的默认值是 0，boolean 类型的默认值是 false，String 类型的默认值是 null，当 new 一个对象时，其实所有字段都已经被初始化成了默认值，而此时只能通过 setToDefault() 方法然后传入相应的列名就可以实现了

```java
Book book = new Book();
book.setToDeafult("pages");
//这里 updateAll() 方法中没有指定约束条件，因此更新操作对所有数据都生效了
book.updateAll();
```



#### 使用 LitePal 删除数据

LitePal 删除数据的方式主要有两种，第一种是直接调用已存储对象的 delete() 方法就可以了，即调用过 save() 方法的对象，或者通过 LitePal 提供的查询 API 查出来的对象都是可以直接使用 delete() 方法来删除数据的，下面使用另一种方法

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

		...

        Button deleteButton = (Button) findViewById(R.id.delete_data);
        deleteButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                //删除表中价格低于 15 的书
                //调用了 DataSupport.deleteAll() 方法来删除数据，第一个参数用于指定那张表中的数据，Book.class 意味着删除 Book 表中的数据，后面的参数用于指定约束条件，如果 DataSupport.deleteAll() 方法如果不指定约束条件就意味着删除表中的所有数据
                DataSupport.deleteAll(Book.class, "price < ?", "15");
            }
        });
    }
}
```



#### 使用 LIitePal 查询数据

上面我们使用了 query() 方法

```java
Cursor cursor = db.query("Book", null, null, null, null, null, null);
```

LitePal 则是通过

```java
//调用 findAll() 方法，然后通过 Book.class 参数指定查询 Book 表就可以，另外 findAll() 方法的返回值时一个 Book 类型的 List 集合，我们不用向 Cursor 一样一个个去取值，LitePal 已经自动帮我们完成了赋值操作
List<Book> books = DataSupprot.findAll(Book.class);
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

		...

        Button queryButton = (Button) findViewById(R.id.query_data);
        queryButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                List<Book> books = DataSupport.findAll(Book.class);
                for (Book book : books) {
                    Log.d("MainActivity", "book name is " + book.getName());
                    Log.d("MainActivity", "book author is " + book.getAuthor());
                    Log.d("MainActivity", "book pages is " + book.getPages());
                    Log.d("MainActivity", "book price is " + book.getPrice());
                    Log.d("MainActivity", "book press is " + book.getPress());
                }
            }
        });
    }
}
```

除了 findAll() 方法之外，还可以

```java
//查询 Book 表中的第一条数据
Book firstBook = DataSupport.findFrist(Book.class);
//查询 Book 表中最后一条数据
Book lastBook = DataSupprot.findLast(Book.class);
```

- select() 方法用于指定查询哪几列的数据，对应了 SQL 当中的 select 关键字，例如查询 name 和 author 这两列数据：

  ```java
  List<Book> books = DataSupport.select("name", "author").find(Book.class);
  ```

- where() 方法用于指定查询的约束条件，对应了 SQL 当中的 where 关键字，例如只查页数大雨 400 的数据：

  ```java
  List<Book> books = DataSupport.where("pages > ?", "400").find(Book.class);
  ```

- order() 方法用于指定结果的排列方式，对应了 SQL 当中的 order by 关键字，例如将查询结果按照暑假从高到低排序：

  ```java
  List<Book> books = DataSupport.order("price desc").find(Book.class);
  //desc 表示降序排列，asc 或者不写表示升序排列
  ```

- limit() 方法用于指定查询结果的数量，例如只查表中的前 3 条数据：

  ```java
  List<Book> books = DataSupport.limit(3).find(Book.class);
  ```

- offset() 方法用于指定查询结果的偏移量，例如查询表中的第 2 条、第 3 条、第 4 条数据：

  ```java
  List<Book> books = DataSupport.limit(3).offset(1).find(Book.class);
  //limit(3) 查询前 3 调数据，offset(1) 偏移了一个位置，就实现了查询表中的第 2 条、第 3 条、第 4 条数据
  ```

- 这 5 个方法还可以进行任意组合

  ```java
  //查询 Book 表中第 11~20 条满足页数大于 400 这个条件的 name、author 和 pages 这三列数据，并将查询结果按照页数升序排列
  List<Book> books = DataSupport.select("name", "author", "pages")
  						    .where("pages > ?", "400")
  						    .order("pages")
  						    .limit(10)
  						    .offset(10)
  						    .find(Book.class);
  ```

使用 LitePal 我们需要用到一个方法的时候直接连缀一下就可以，不需要的话可以不写，而不是像 query() 方法一样，不管需不需要用到都传要固定的参数进去才行

- LitePal 仍然支持原生的 SQL 语句来进行查询

  ```java
  //第一个参数用于指定 SQL 语句，后面的参数用于之地你给占位符的值
  Cursor c = DataSupport.findBySQL("selsct * from Book where pages > ? and price < ?", "400", "20");
  ```

findBySQL() 方法返回的是一个 Cursor 对象，接下来还需要向之前一样一一取出才行





## Content Provider

内容提供器主要用于在不同的程序之间实现数据共享的功能，它提供了一套完整的机制，允许一个程序访问另一个程序中的数据，同时还能保证被访数据的安全性。目前，使用内容提供启是 Android 实现跨程序共享数据的标准方式

不同于文件存储和 SharedPreferences 存储中的两种全局可读写操作模式，内容提供器可以选择只对哪一部分数据进行共享，从而保证我们程序中的隐私数据不会有泄漏风险



### 运行时权限

```java
//运行时权限的核心就是在程序运行过程中由用户授权我们去执行某些危险操作，程序是不可以擅自做主去执行这些危险操作的
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button makeCall = (Button) findViewById(R.id.make_call);
        makeCall.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                //判断用户是否已经给过我们授权的，运用 ContextCompat.checkSelfPermission() 方法，接收两个参数，第一个参数是 Context，第二个参数是具体的权限名，然后我们使用的方法和 PackageManager.PERMISSION_GRANTED 比较，相等就说明用户已经授权了，不等就表示用户没有授权
                if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED) {
                    //没有授权，调用 ActivityCompat.requestPermissions() 方法来向用户申请授权，requestPermissions() 方法接收 3 个参数，第一个参数要求是 Activity 实例，第二个参数是一个 String 数组，我们把要申请的权限名放在数组中即可，第三个参数是请求码，只要是唯一值就可以，这里传入 1
                    //调用 requestPermissions() 方法之后，系统会弹出一个权限申请的对话框
                    ActivityCompat.requestPermissions(MainActivity.this, new String[]{Manifest.permission.CALL_PHONE}, 1);
                } else {
                    call();
                }
            }
        });
    }

    //拨打电话
    private void call(){
        try {
            Intent intent = new Intent(Intent.ACTION_CALL);
            intent.setData(Uri.parse("tel:10086"));
            startActivity(intent);
        } catch (SecurityException e) {
            e.printStackTrace();
        }
    }

    //在用户运行时权限授权选择之后，无论结果如何都会回调到 onRequestPermissionsResult() 方法中，而授权结果会封装在 grantResults 参数当中，判断最后的授权结果，用户同意就拨打电话，不同意就弹出一条失败提示
    @Override
    public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
        switch (requestCode) {
            case 1:
                if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                    call();
                } else {
                    Toast.makeText(this, "You denied the permission", Toast.LENGTH_SHORT).show();
                }
                break;
            default:
        }
    }
}
```



### 访问其他程序中的数据

内容提供器的用法一般有两种，一种是使用现有的内容提供器来读取和操作相应程序中的数据，另一种是创建自己的内容提供器给我们程序的数据提供外部访问接口。如果一个应用程序通过内容提供器对其数据提供了外部访问接口，那么任何其他的应用程序就都可以对这部分数据进行访问，例如：Android 系统中自带的短信、电话簿等



#### ContentResolver 的基本用法

对于每一个应用程序来说，如果想要访问内容提供器中共享的数据，就一定要借助 ContentResolver 类，可以通过 Context 中的 getContentResolver() 方法获取到该类的实例。和 SQLiteDatabase 一样，用 insert()、update()、delete() 、query() 分别来进行添加、更新、删除、查询数据，但它们在参数上稍微有一点区别。ContentResolver 中的增删改查方法都是不接收表名参数的，而是使用一个 Uri 参数代替，这个参数被称为内容 URI。

内容 URI 给内容提供器中的数据建立了唯一的标识符，它主要由两部分组成：authority 和 path。authority 是用于对不同的应用程序做区分的，一般为了避免冲突，都会采用程序包名的方式来进行命名。path 则是用于对同一应用程序中不同的表做区分的，通常会添加到 authority 的后面。我们还需要在字符串的头部加上协议声明。

```java
//内容 URI 可以非常清楚地表达出我们想要访问哪个程序中哪张表里的数据
content://com.example.app.provider/table1
content://com.example.app.provider/table2
```

```java
//在得到内容 URI 之后，我们还需要将它解析成 Uri 对象才可以作为参数传入,只需调用 Uri.parse() 方法就可以将它解析成 Uri 对象
Uri uri = Uri.parse("content://com.example.app.provider/table1");
```

现在我们就可以使用这个 Uri 对象来查询 table 表中的数据

```java
Cursor cursor = getContentResolver().query(
	uri,
	projection,
	selection,
	selectionArgs,
	sortOrder);
```

![微信图片_20190323150002](E:\Android笔记\第七章笔记图片\微信图片_20190323150002.png)

查询完成后返回的仍然是一个 Cursor 对象，这时我们就可以将数据从 Cursor 对象中逐个读取出来。读取的思路仍然是通过移动游标的位置来遍历 Cursor 的所有行，然后再取出每一行中相应列的数据

```java
if (cursor != null) {
    while (cursor.moveToNext()) {
        String column1 = cursor.getString(cursor.getColumnIndex("column1"));
        int colum2 = cursor.getInt(cursor.getColumnIndex("colum2"));
    }
    cursor.close();
}
```

向 table 表中添加一条数据

```java
ContentValues values = new ContentValues();
values.put("column1", "text");
values.put("column2", 1);
getContentResolver().insert(uri, values);
```

将待添加的数据组装到 ContentValues 中，然后调用 ContentResolver 的 insert() 方法，将 Uri 和 ContentValues 作为参数传入即可

更新添加的数据，把 column1 的值清空，可以借助 ContentResolver 的 update() 方法实现

```java
ContentValues values = new ContentValues();
values.put("column1", "");
getContentResolver().update(uri, values, "column1 = ? and column2 = ?", new String[] {"text", "1"});
```

注意上述代码使用了 selection 和 selectionArgs 参数来对想要更新的数据进行约束，以防止所有的行为都受影响

调用 ContentResolver 的 delete() 方法将这条数据删除掉

```java
getContentResolver().delete(uri, "column2 = ?", new String[] {"1"});
```



#### 读取系统联系人

在电话簿里新建两个联系人，新建一个 ContactsTest 项目

修改 activity_main.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <ListView
        android:id="@+id/contacts_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent">
    </ListView>

</LinearLayout>
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    ArrayAdapter<String> adapter;

    List<String> contactsList = new ArrayList<>();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        //首先获取 ListView 实例，并设置好适配器，然后开始调用运行时权限的处理逻辑，因为 READ_CONTACTS 全显示属于危险权限
        ListView contactsView = (ListView) findViewById(R.id.contacts_view);
        adapter = new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, contactsList);
        contactsView.setAdapter(adapter);
        //判断用户是否已经给过我们授权
        if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(this, new String[] {Manifest.permission.READ_CONTACTS}, 1);
        } else {
            //用户授权之后调用 readContacts() 方法 
            readContacts();
        }
    }

    private void readContacts() {
        Cursor cursor = null;
        try {
            //查询联系人数据
            //其中传入的 Uri 数据没有调用 Uri.parse() 方法去解析一个内容 URI 字符串，是因为 ContactsContract.CommonDataKinds.Phone.CONTENT_URI 类已经帮我们做好了封装，提供了一个 CONTENT_URI 常量，而这个常量就是使用 Uri.parse() 方法解析出来的结果
            cursor = getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI, null, null, null, null);
            if (cursor != null) {
                //对 cursor 对象进行遍历，将联系人姓名和手机号这些数据逐个取出
                while (cursor.moveToNext()) {
                    //获取联系人姓名
                    //联系人姓名这一列对应的常量是 ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME
                    String displayName = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME));
                    //获取联系人手机号
                    //联系人手机号这一列对应的常量是 ContactsContract.CommonDataKinds.Phone.NUMBER
                    String number = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER));
                    //对取出的两个数据进行拼接，然后添加到 ListView 数据源里
                    contactsList.add(displayName + "\n" + number);
                }
                //通知刷新一下 ListView
                adapter.notifyDataSetChanged();
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            //最后将 Cursor 关闭
            if (cursor != null) {
                cursor.close();
            }
        }
    }
    
    @Override
    public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
        switch (requestCode) {
            case 1:
                if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                    readContacts();
                } else {
                    Toast.makeText(this, "You denied the permission", Toast.LENGTH_SHORT).show();
                }
                break;
            default:    
        }
    }

}
```

修改 AndroidManifest

```java
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.contactstest">
    //声明读取系统联系人的权限
    <uses-permission android:name="android.permission.READ_CONTACTS" />
    
    ...

</manifest>
```





### 创建自己的内容提供器

上面介绍的是如何在自己的程序中访问其他应用程序，总体思路是只需获取到该应用程序的内容 URI，然后借助 ContentResolver 进行 CRUD 操作就可以



#### 创建内容提供器的步骤

如果想要实现跨程序共享数据的功能，官方推荐的方式就是使用内容提供器，可以通过新建一个类去继承 ContentProvider 的方式来创建一个自己的内容提供器。ContentProvider 类中有 6 个抽象方法，我们在使用子类继承它的时候，需要将这 6 个方法全部重写

新建 MyProvider 继承 ContentProvider

```java
public class MyProvider implements ContentProvider {
    
    //初始化内容弄提供器的时候调用，通常会在这里完成对数据库的创建和升级等操作，返回 true 表示内容提供器初始化成功，返回 false 则表示失败
    @Override
    public boolean onCreate() {
        return false;
    }
    
    //从内容提供器中查询数据。uri 参数来确定查询哪张表，projection 参数用于确定查询哪些列，selection 和 selectionArgs 参数用于约束查询那些行，sortOrder 参数用于对结果进行排序，查询的结果存放在 Cursor 对象中返回
    @Override
    public Cursor query(Uri uri, String[] projection, String selecetion, String[] selectionArgs, String sortOrder) {
        return null;
    }
    
    //向内容提供器中添加一条数据。使用 uri 参数来确定更新哪一张表中的数据，新数据保存在 values 参数中，添加完成后，返回一个用于表示这条新纪录的 URI
    @Override
    public  Uri insert(Uri uri, ContentValues values) {
        return null;
    }
    
    //更新内容提供器中已有的数据。使用 uri 参数来确定要添加到的表，待添加的数据保存在 values 参数中，selection 和 selectionArgs 参数用于约束更新哪些行，受影响的行数将作为返回值返回
    @Override
    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
        return 0;
    }
    
    //从内容提供器中删除数据。使用 uri 参数来确定哪一张表中的数据，selection 和 selectionArgs 参数用于约束删除哪些行，被删除的行数作为返回值返回
    @Override
    public int delete(Uri uri, String selection, String[] selectionArgs) {
        return 0;
    }
   
    //根据传入的内容 uri 来返回相应的 MIME 类型
    @Override
    public  String getType(Uri uri) {
        return null;
    }
    
}
```

几乎每一个方法都会带有 Uri 参数，这个参数也正是调用 ContentResolver 的增删改查方法时传递过来的，而现在我们需要对传入的 Uri 参数进行解析，从中分析出调用方期望访问的表和数据



```java
//标准内容的 URI 写法
content://com.example.app.provider/table1
```

表示调用方期望访问的是 com.example.app 这个应用的 table1 表中的数据

```java
//此外我们可以上面的内容 uri 后面加上一个 id
content://com.example.app.provider/table1/1
```

表示调用方期望访问的是 com.example.app 这个应用的 table1 表中 id 为 1 的数据

以路径结尾就表示期望访问该表中所有的数据，以 id 结尾就表示期望访问该表中还拥有相应 id 的数据，我们可以使用通配符的方式来分别分配这两种格式的内容 URI

*：表示匹配任意长度的任意字符

#：表示匹配任意长度的数字

```java
//一个匹配任意表的内容 URI 格式可以写成
content://com.example.app.provider/*

//一个匹配 table 表中任意一行数据的内容 URI 格式可以写成
content://com.example.app.provider/table1/#
```

我们再借助 UriMatcher 这个类就可以轻松地实现匹配内容 URI 的功能。UriMatcher 中提供了一个 addURI() 方法，这个方法接收三个参数，可以分别把 authority、path 和一个自定义代码传进去，这样调用 UriMatcher 的 match() 方法时，就可以将一个 Uri 对象传入，返回值是某个能够匹配这个 Uri 对象所对应的自定义代码，利用这个代码，我们就可以判断出调用方期望访问的是那张表中的数据了

修改 MyProvider

```java
public class MyProvider implements ContentProvider {
    
    //MyProvider 新增 4 个整型常量，TABLE1_DIR 表示访问 table1 中的所有数据，TABLE1_ITEM 表示访问 table1 中的单条数据，TABLE2_DIR 表示访问 table2 中的所有数据，TABLE2_ITEM 表示访问 table2 中的单条数据
    public static final int TABLE1_DIR = 0;
    
    public static final int TABLE1_ITEM = 1;
    
    public static final int TABLE2_DIR = 2;
    
    public static final int TABLE2_ITEM = 3;
    
    private static UriMatcher uriMatcher;
    
    //在静态代码块中创建了 UriMatcher 的实例，并调用 addURI 方法，将期望匹配的内容 URI 格式传递进去
    static {
        uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);
        uriMatcher.addURI("com.example.app.provider", "table1", TABLE1_DIR);
        uriMatcher.addURI("com.example.app.provider", "table1/#", TABLE1_ITEM);
        uriMatcher.addURI("com.example.app.provider", "table2", TABLE2_DIR);
        uriMatcher.addURI("com.example.app.provider", "table2/#", TABLE2_ITEM);
    }

    @Override
    public boolean onCreate() {
        return false;
    }

    //当 query() 方法被调用的时候，就会通过 UriMatcher 的 match() 方法对传入的 Uri 对象进行匹配，如果发现 UriMatcher 中某个内容 URI 格式成功匹配了该对象，则会返回相应的自定义代码，然后我们就可以判断出调用方期望的到底是什么数据了
    @Override
    public Cursor query(Uri uri, String[] projection, String selecetion, String[] selectionArgs, String sortOrder) {
        switch (uriMatcher.match(uri)) {
            case TABLE1_DIR:
                //查询 table1 表中的所有数据
                break;
            case TABLE1_ITEM:
                //查询 table1 表中的单条数据
                break;
            case TABLE2_DIR:
                //查询 table2 表中的所有数据
                break;
            case TABLE2_ITEM:
                //查询 table2 表中的单条数据
                break;
            default:
                break;
        }
        return null;
    }
    ...
}
```

上述代码只是以 query() 做个示范，insert()、update()、delete() 这几个方法的实现也是差不多的，他们都携带 Uri 这个参数，然后同样利用 UriMatch 的 match() 方法对传入的 Uri 对象方法判断出调用方期望访问的是哪张表，在对该表中的数据进行操作就可以了

除此之外，getType() 是所有的内容提供器都必须提供的一个方法，用于获取 Uri 对象所对应的 MIME 类型，一个内容 URI 所对应的 MIME 字符串主要由 3 部分组成

- 必须以 vnd 开头
- 如果内容 URI 以路径结尾，则后接 android.cursor.dir/，如果内容 URI 以 id 结尾，则后接 android.cursor.item/
- 最后接上 vnd.<authority>.<path>

```java
//对于 content://com.example.app.provider/table1 这个内容 URI，对应的 MIME 类型就可以写成
vnd.android.cursor.dir/vnd.com.example.app.provider.table1
//对于 content://com.example.app.provider/table1/1 这个内容 URI，对应的 MIME 类型就可以写成
vnd.android.cursor.item/vnd.com.example.app.provider.table1
```

完善 MyProvider

```java
public class MyProvider implements ContentProvider {

	...

    @Override
    public  String getType(Uri uri) {
        switch (uriMatcher.match(uri)) {
            case TABLE1_DIR:
                return "vnd.android.cursor.dir/vnd.com.example.app.provider.table1";
            case TABLE1_ITEM:
                return "vnd.android.cursor.item/vnd.com.example.app.provider.table1";
            case TABLE2_DIR:
                return "vnd.android.cursor.dir/vnd.com.example.app.provider.table2";
            case TABLE2_ITEM:
                return "vnd.android.cursor.tiem/vnd.com.example.app.provider.table2";
        }
        return null;
    }

}
```

一个完整的内容提供器就创建完成了，现在任何一个应用程序都可以使用 ContentResolver 来访问我们程序中的数据

所有的 CRUD 操作都一定要匹配到相应的内容 URI 格式才能进行的，而我们当然不可能向 UriMatcher 中添加隐私数据的 URI，所以这部分数据根本无法被外部程序访问到，安全问题也就不存在了



#### 实现跨程序数据共享

打开 DatabaseTest，将 MyDatabaseHelper 中使用 Toast 弹出创建数据库成功的提示去除掉，跨程序访问时不能直接使用 Toast，右击 com.example.databasetest 包 -> New -> Other -> Content Provider

Exported 属性表示是否允许外部程序访问我们的内容提供器

Enabled 属性表示是否启用这个内容提供器

修改 DatabaseProvider

```java
public class DatabaseProvider extends ContentProvider {
    
    //在类的一开始定义了 4 个常量，分别用于表示访问 Book 表中的所有数据、访问 Book 表中的单条数据、访问 Category 表中的所有数据、访问 Category 表中的单条数据

    public static final int BOOK_DIR = 0;

    public static final int BOOK_ITEM = 1;

    public static final int CATEGORY_DIR = 2;

    public static final int CATEGORY_ITEM = 3;

    public static final String AUTHORITY = "com.example.databasetest.provider";

    private static UriMatcher uriMatcher;

    private MyDatabaseHelper dbHelper;

    //在静态代码块里对 UriMatcher 进行了初始化操作，将期望匹配的集中 URI 格式添加进去
    static {
        uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);
        uriMatcher.addURI(AUTHORITY, "book", BOOK_DIR);
        uriMatcher.addURI(AUTHORITY, "book/#", BOOK_ITEM);
        uriMatcher.addURI(AUTHORITY, "category", CATEGORY_DIR);
        uriMatcher.addURI(AUTHORITY, "category/#", CATEGORY_ITEM);
    }

    @Override
    public boolean onCreate() {
        //创建一个 MyDatabaseHelper 实例，然后返回 true 表示内容提供器初始化成功，这时数据库就已经完成了创建或升级操作
        dbHelper = new MyDatabaseHelper(getContext(), "BookStore.db", null, 2);
        return true;
    }

    @Override
    public Cursor query(Uri uri, String[] projection, String selection,
                        String[] selectionArgs, String sortOrder) {
        //查询数据
        //先获取 SQLiteDatabase 的实例，然后根据传入的 Uri 参数判断出用户想要访问哪张表，再调用 SQLiteDatabase 的 query() 进行查询，并将 Cursor 对象返回
        SQLiteDatabase db = dbHelper.getReadableDatabase();
        Cursor cursor = null;
        switch (uriMatcher.match(uri)) {
            case BOOK_DIR:
                cursor = db.query("Book", projection, selection, selectionArgs, null, null, sortOrder);
                break;
            case BOOK_ITEM:
                //访问单条数据调用了 Uri 对象的 getPathSegments() 方法，它会将内容 URI 权限之后的部分以 “/” 符号进行分割，并把分割之后的结果放入到一个字符串列表中，那这个列表的第 0 个位置存放的就是路径，第一个位置存放的就是 id
                String bookId = uri.getPathSegments().get(1);
                //得到 id 之后再通过 selection 和 selectionArgs 参数进行约束
                cursor = db.query("Book", projection, "id = ?", new String[]{ bookId }, null, null, sortOrder);
                break;
            case CATEGORY_DIR:
                cursor = db.query("Category", projection, selection, selectionArgs, null, null, sortOrder);
                break;
            case CATEGORY_ITEM:
                String categoryId = uri.getPathSegments().get(1);
                cursor = db.query("Category", projection, "id = ?", new String[]{ categoryId }, null, null, sortOrder);
                break;
            default:
                break;
        }
        return cursor;
    }

    @Override
    public Uri insert(Uri uri, ContentValues values) {
        //添加数据
        //现获取 SQLiteDatabase 的实例，然后根据传入的 Uri 参数判断出用户想要往哪张表里添加数据，再调用 SQLiteDatabase 的 insert() 方法进行添加就可以了
        SQLiteDatabase db = dbHelper.getWritableDatabase();
        Uri uriReturn = null;
        switch (uriMatcher.match(uri)) {
            case BOOK_DIR:
            case BOOK_ITEM:
                long newBookId = db.insert("Book", null, values);
                //注意 insert() 方法要求返回一个能够表示这条新增数据的 URI，所以我们还需要调用 Uri.parse() 方法来将一个内容 URI 解析成 Uri 对象，这个内容 URI 是以新增数据的 id 结尾
                uriReturn = Uri.parse("content://" + AUTHORITY + "/book/" + newBookId);
                break;
            case CATEGORY_DIR:
            case CATEGORY_ITEM:
                long newCategoryId = db.insert("Catagory", null, values);
                uriReturn = Uri.parse("content://" + AUTHORITY + "/category/" + newCategoryId);
                break;
            default:
                break;
        }
        return uriReturn;
    }

    @Override
    public int update(Uri uri, ContentValues values, String selection,
                      String[] selectionArgs) {
        //更新数据
        //先获取 SQLiteDatabase 的实例，然后根据传入的 Uri 参数判断出用户想要更新哪张表里的数据，再调用 SQLiteDatabase 的 update() 方法进行更新就好了，受影响的行数将作为返回值返回
        SQLiteDatabase db = dbHelper.getWritableDatabase();
        int updatedRows = 0;
        switch (uriMatcher.match(uri)) {
            case BOOK_DIR:
                updatedRows = db.update("Book", values, selection, selectionArgs);
                break;
            case BOOK_ITEM:
                String bookId = uri.getPathSegments().get(1);
                updatedRows = db.update("Book", values, "id = ?", new String[]{bookId});
                break;
            case CATEGORY_DIR:
                updatedRows = db.update("Category", values, selection, selectionArgs);
                break;
            case CATEGORY_ITEM:
                String categoryId = uri.getPathSegments().get(1);
                updatedRows = db.update("Category", values, "id = ?", new String[]{categoryId});
                break;
            default:
                break;
        }
        return updatedRows;
    }

    @Override
    public int delete(Uri uri, String selection, String[] selectionArgs) {
        //删除数据
        //现获取 SQLiteDatabase 实例，然后根据传入的 Uri 参数判断出用户想要更新哪张表里的数据，再调用 SQLiteDatabase 的 delete() 方法进行删除就好了，被删除的行数将作为返回值返回
        SQLiteDatabase db = dbHelper.getWritableDatabase();
        int deletedRows = 0;
        switch (uriMatcher.match(uri)) {
            case BOOK_DIR:
                deletedRows = db.delete("Book", selection, selectionArgs);
                break;
            case BOOK_ITEM:
                String bookId = uri.getPathSegments().get(1);
                deletedRows = db.delete("Book", "id = ?", new String[] {bookId});
                break;
            case CATEGORY_DIR:
                deletedRows = db.delete("Category", selection, selectionArgs);
                break;
            case CATEGORY_ITEM:
                String categoryId = uri.getPathSegments().get(1);
                deletedRows = db.delete("Category", "id = ?", new String[] {categoryId});
                break;
            default:
                break;
        }
        return deletedRows;
    }

    @Override
    public String getType(Uri uri) {
        //getType() 是所有的内容提供器都必须提供的一个方法，用于获取 Uri 对象所对应的 MIME 类型，并返回
        switch (uriMatcher.match(uri)) {
            case BOOK_DIR:
                return "vnd.android.cursor.dir/vnd.com.example.databasetest.provider.book";
            case BOOK_ITEM:
                return "vnd.android.cursor.item/vnd.com.example.databasetest.provider.book";
            case CATEGORY_DIR:
                return "vnd.android.cursor.dir/vnd.com.example.databasetest.provider.category";
            case CATEGORY_ITEM:
                return "vnd.android.cursor.item/vnd.com.example.databasetest.provider.category";
        }
        return null;
    }
}
```

内容提供器一定要在 AndroidManifest.xml 文件中注册才可以使用，由于我们是使用 Android Studio 的快捷方式创建的内容提供器，因此注册这一步已经被自动完成了

打开 AndroidManifest

```java
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="edu.hzuapps.androidlabs.databasetest">

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        ...
        <provider
        	//指定了 DatabaseProvider 的类名
            android:name=".DatabaseProvider"
            //指定了 DatabaseProvider 的 authority
            android:authorities="com.example.databasetest.provider"
            //Exported 属性表示是否允许外部程序访问我们的内容提供器
	        //Enabled 属性表示是否启用这个内容提供器
            android:enabled="true"
            android:exported="true">
        </provider>
    </application>

</manifest>
```

<application> 标签内出现了一个新标签 <provider>，我们使用它来对 DatabaseProvider 这个内容提供器进行注册

删除 DatabaseTest 程序再重新运行以防止存留的数据产生干扰

新建 ProviderTest 项目，通过这个程序去访问 DatabaseTest 中的数据

修改 activity_main.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <Button
        android:id="@+id/add_data"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Add To Book" />

    <Button
        android:id="@+id/query_data"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Query From Book" />

    <Button
        android:id="@+id/update_data"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Update Book" />

    <Button
        android:id="@+id/delete_data"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Delete From Book" />
    
</LinearLayout>
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    private String newId;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button addData = (Button) findViewById(R.id.add_data);
        addData.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                //添加数据
                //首先调用了 Uri.parse() 方法将一个内容 URI 解析成 Uri 对象，然后把添加的数据都存放到 ContentValues 对象中，接着调用 ContentResolver 的 insert() 方法执行添加操作即可。
                Uri uri = Uri.parse("content://com.example.databasetest.provider.book");
                ContentValues values = new ContentValues();
                values.put("name", "A Clash of Kings");
                values.put("author", "Grorge Martin");
                values.put("pages", 1040);
                values.put("price", 22.85);
                //insert() 方法会返回一个 Uri 对象，这个对象中包含了新增数据的 id，我们通过 getPathSegments() 方法将这个 id 取出
                Uri newUri = getContentResolver().insert(uri, values);
                newId = newUri.getPathSegments().get(1);
            }
        });
        Button queryData = (Button) findViewById(R.id.query_data);
        queryData.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                //查询数据
                //调用 Uri.parse() 方法将一个内容 URI 解析成 Uri 对象，然后调用 ContentResolver 的 query() 方法去查询数据，查询的结果存放在 Cursor 对象中，之后对 Cursor 进行遍历，从中取出查询结果，并一一打印出来
                Uri uri = Uri.parse("content://com.example.databasetest.provider/book");
                Cursor cursor = getContentResolver().query(uri, null, null, null, null);
                if (cursor != null) {
                    while (cursor.moveToNext()) {
                        String name = cursor.getString(cursor.getColumnIndex("name"));
                        String author = cursor.getString(cursor.getColumnIndex("author"));
                        int pages = cursor.getInt(cursor.getColumnIndex("pages"));
                        double price = cursor.getDouble(cursor.getColumnIndex("price"));
                        Log.d("MainActivity", "book name is " + name);
                        Log.d("MainActivity", "book author is " + author);
                        Log.d("MainActivity", "book pages is " + pages);
                        Log.d("MainActivity", "book price is " + price);
                    }
                    cursor.close();
                }
            }
        });
        Button updateData = (Button) findViewById(R.id.update_data);
        updateData.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                //更新数据
                //现将内容 URI 解析成 Uri 对象，然后把想要更新的数据存放到 ContentValues 对象中，再调用 ContentResolver 的 update() 方法执行更新操作就行
                //在调用 Uri.parse() 方法时，给内容 URI 的尾部增加了一个 id，而这个 id 为添加数据时做返回的，这就表示我们只希望更新刚刚添加的那条数据，Book 表中的其他行都不会受影响
                Uri uri = Uri.parse("content://com.example.databasetest.provider/book/" + newId);
                ContentValues values = new ContentValues();
                values.put("name", "A Storm of Swords");
                values.put("pages", 1216);
                values.put("price", 24.05);
                getContentResolver().update(uri, values, null, null);
            }
        });
        Button deleteData = (Button) findViewById(R.id.delete_data);
        deleteData.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                //删除数据
                //解析了一个以 id 结尾的内容 URI，然后调用了 ContentResolver 的 delete() 方法执行删除操作就可以了，我们在内容 URI 里指定了一个 id，因此只会删掉拥有相应 id 的那行数据，Book 表中的其他数据都不会影响
                Uri uri = Uri.parse("content://com.example.databasetest.provider/book/" + newId);
                getContentResolver().delete(uri, null, null);
            }
        });
    }
}
```





## 运用手机多媒体



### Notification

通知（Notification）当某个程序希望向用户发出一些提示信息，而该应用程序又不在前台运行，可以借助通知来实现，发出一条通知后，手机最上方的状态栏会显示一个通知的图标，下拉状态栏后可以看到通知的详细内容。它既可以在活动里创建，也可以在广播接收器里创建，还可以在服务里创建

首先需要一个 NotificationManager 来对通知进行管理，可以调用 Context 的 getSystemService() 方法获取到，getSystemService() 方法接收一个字符串参数用于确定获取系统的那个服务，这里我们传入 Context.NOTIFICATION_SERVICE 即可

```java
NotificationManager manager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
```

接下来需要使用一个 Builder 构造器来创建 Notification 对象，由于 Android 每一个版本都会对通知这部分功能进行修改，API 不稳定，可以使用 support 库中提供的兼容 API 

```java
Notification notification = new Notification.Builder(context).build();
```

上面只是创建一个空的 Notification 对象，我们可以在最终的 build() 方法之前连缀任意多的设置方法来创建一个丰富的 Notification 对象

```java
Notification notification = new NotificationCompat.Builder(context)
	.setContentTitle("This is content title")//用于指定通知的标题内容，下拉系统状态栏就可以看到这部分内容
	.setContentText("This is content text")//用于指定通知的正文内容，同样下拉系统状态栏就可以看到这部分内容
	.setWhen(System.currentTimeMillis())//用于指定通知被创建的时间，以毫秒为单位，同样下拉系统状态栏指定的时间可以显示在系统状态栏上
	.setSmallIcon(R.drawable.small_icon)//用于设置通知的小图标，只能使用纯 alpha 图层的图片进行设置小图标才会显示在系统状态栏上
	.setLargeIcon(BitmapFactory.decodeResource(getResources(), R.drawable.large_icon))//用于设置通知的大图标，当下拉系统状态栏的时候就可以看到设置的大图标了
	.build();
```

以上设置完成后只需要调用 NotificationManager 的 notify() 方法就可以以让通知显示出来，该方法接收两个参数，第一个参数是 id，要保证每一个通知所指定的 id 都是不同的；第二个参数是 Notification 对象，这里直接吧我们创建好的 Notification 对象传入即可

```java
manager.notify(1， notification);
```

新建 Notification 项目，修改 activity_main.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <Button
        android:id="@+id/send_notice"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Send notice"/>

</LinearLayout>
```

设置一个 send notice 按钮，用于发出一条通知，修改 MainActivity

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener{

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button sendNotice = (Button) findViewById(R.id.send_notice);
        sendNotice.setOnClickListener(this);
    }

    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.send_notice:
                NotificationManager manager = (NotificationManager)  getSystemService(NOTIFICATION_SERVICE);
                Notification notification = new NotificationCompat.Builder(this)
                        .setContentTitle("This is content title")
                        .setContentText("This is content text")
                        .setWhen(System.currentTimeMillis())
                        .setSmallIcon(R.mipmap.ic_launcher)
                        .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher))
                        .build();
                manager.notify(1, notification);
                break;
            default:
                break;
        }
    }

}
```

点击按钮会发现有了通知，但下来通知栏点击却没反应，这是需要设置，PendingIntent。它和 Intent 有些类似，Intent 更加倾向于立即执行某个动作，而 PendingIntent 更加倾向于在某个合适的时机去执行某个动作，也可以理解为延迟执行的 Intent

PendingIntent 提供了几个静态方法用于获取 PendingIntent 的实例，根据需要使用 getActivity() 、getBroadcast() 、getService() 方法。这几个方法接收的参数都是相同的，第一个参数是 Context，第二个参数一般用不到，通常都是传入0，第三个参数是一个 Intent 对象，可以通过这个对象构建出 PendingIntent 的“意图”，第四个参数用于确定 PendingIntent 的行为，有 FLAG_ONE_SHOT、FLAG_NO_CREATE、FLAG_CANCEL_CURRENT 和 FLAG_UPDATE_CURRENT 这四种值可选，具体含义查看文档，通常这个参数传入 0 即可

NotificationCompat.Builder 这个构造器还可以再连缀一个 setContentIntent() 方法，接收的参数这是一个 PendingIntent 对象，这里就可以通过 PendingIntent 构建出一个演出执行的“意图”，当用户点击这条通知时就会执行相应的逻辑

右键 com.example.notificationtest 包 -> New -> Activity -> Empty Activity，新建 NotificationActivity，布局起名为 notification_layout，修改 notification_layout

```java
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    
    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_centerInParent="true"
        android:textSize="24dp"
        android:text="This is notification layout"/>

</RelativeLayout>
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener{

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button sendNotice = (Button) findViewById(R.id.send_notice);
        sendNotice.setOnClickListener(this);
    }

    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.send_notice:
                //通过 Intetn 表达我们想要启动 NotificationActivity 的“意图”，将构建好的 Intent 对象传入到 PendingIntent 的 getActivity() 里得到 PendingIntent 的实例
                Intent intent = new Intent(this, NotificationActivity.class);
                //第一个参数是 Context，第二个参数一般用不到，通常都是传入0，第三个参数是一个 Intent 对象，可以通过这个对象构建出 PendingIntent 的“意图”，第四个参数用于确定 PendingIntent 的行为，有 FLAG_ONE_SHOT、FLAG_NO_CREATE、FLAG_CANCEL_CURRENT 和 FLAG_UPDATE_CURRENT 这四种值可选，具体含义查看文档，通常这个参数传入 0 即可
                PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0);
                NotificationManager manager = (NotificationManager)  getSystemService(NOTIFICATION_SERVICE);
                Notification notification = new NotificationCompcat.Builder(this)
                        .setContentTitle("This is content title")
                        .setContentText("This is content text")
                        .setWhen(System.currentTimeMillis())
                        .setSmallIcon(R.mipmap.ic_launcher)
                        .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher))
                        .setContentIntent(pi) //在 NotificationCompat.Builder 中调用 setContentIntent() 方法，把 PendingIntent 实例作为参数传进去即可
                        .build();
                manager.notify(1, notification);
                break;
            default:
                break;
        }
    }

}
```

点击通知后跳转到了 NotificationActivity 了，但是通知还没消失，如果不在代码中对该通知进行取消，通知就会一直显示在系统的状态栏里，解决方法有两种

一是在 NotificationCompat.Builder 中再连缀一个 setAutoCancel() 方法

```java
Notification notification = new NotificationCompat.Builder(this)
						...
                        .setAutoCancel(true)//传入 true，表示当点击了这个通知的时候，通知会自动取消掉
                        .build();
```

另一种是显示地调用 NotificationManager 的 cancel() 方法将它取消，修改 NotificationActivity

```java
public class NotificationActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.notification_layout);
        NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
        //cancel() 方法中传入的是通知的 id，就是我们在创建通知的时候给每条通知指定的 id
        manager.cancel(1);
    }
}
```

NotificationCompat.Builder 中提供了非常丰富的 API 来让我们创建出更加多样的通知效果

setSound() 方法可以在通知发出的时候播放一段音频，这样就能够更好地告知用户有通知到来，setSound() 方法接收一个 Uri 参数，所以在指定音频文件的时候还需要先获取到音频文件对应的 URI

```java
Notification notification = new NotificationCompat.Builder(this)
        ...
        .setSound(Uri.fromFile(new File("/system/media/audio/ringtones/Girtab.ogg")))
        .build();
```

在通知到来的时候让手机进行振动，使用 vibrate 这个属性，它是一个长整型的数据，用于设置手机静止和震动的时长，以毫秒为单位，下标为 0 的值表示手机静止的时长，下表为 1  的值表示手机振动的时长，下表为 2 的值又表示手机精致的时长，依次类推

```java
Notification notification = new NotificationCompat.Builder(this)
        ...
    	//手机在通知到来的时候立刻振动1秒，然后静止1秒，再振动1秒
        .setVibrate(new long[] {0, 1000, 1000, 1000})
        .build();
```

想要控制手机振动还需要声明权限，编辑 AndroidMani.xml

```java
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.notificationtest">
    
    <uses-permission android:name="android.permission.VIBRATE" />

   ...

</manifest>
```

使用 setLights() 方法来实现控制手机的 LED 灯，该方法接收三个参数，第一个参数用于指定 LED 灯的颜色，第二个参数用于用于指定 LED 灯亮起的时长，以毫秒为单位，第三个参数用于指定 LED 等暗去的时长，也是以毫秒为单位

```java
Notification notification = new NotificationCompat.Builder(this)
        ...
        .setLights(Color.GREEN, 1000, 1000)
        .build();
```

也可以直接使用通知的默认效果来根据当前手机的环境来决定播放什么铃声以及如何振动

```java
Notification notification = new NotificationCompat.Builder(this)
        ...
        .setDefault(NotificationCompat.DEFAULT_ALL)
        .build();
```

NotificationCompat.Builder 这个类还有很多的 API

setStyle() 方法，这个方法允许我们构建出富文本的通知内容，也就是说通知中不光可以有文字和图标，还可以包含更多的东西，该方法接收一个 NotificationCompat.Style 参数，这个参数就是用来构建具体的富文本信息的，如长文字、图片等

```java
Notification notification = new NotificationCompat.Builder(this)
        ...
        .setContentText("This is content text. This is content text. This is content text. This is content text. This is content text. This is content text. This is content text. This is content text." 
        .build();
```

可以看到通知的内容那个是无法完整显示的，多余的部分会用省略号来代替，设置 setStyle() 来让通知中显示一段长文字

```java
Notification notification = new NotificationCompat.Builder(this)
					  ...
//在 setStyle() 方法中创建了一个 NotificationCompat.BigTextStyle 对象，这个对象就是用于封装长文字信息的，调用它的 bigText() 方法并将文字内容传入即可
                        .setStyle(new NotificationCompat.BigTextStyle().bigText("This is content text. This is content text. This is content text. This is content text. This is content text. This is content text. This is content text. This is content text."))
                        .build();
```

通知里显示一张大图片

```java
Notification notification = new NotificationCompat.Builder(this)
                        //调用 setStyle() 方法，在参数中创建一个 NotificationCompat.BigPictureStyle 对象，这个对象适用于设置大图片的，然后调用它的 bigPicture() 方法并将图片传入，通过 BitmapFactory 的 decodeResource() 方法将图片解析成 Bitmap 对象，在传入到 bigPicture() 方法中就可以了
                        .setStyle(new NotificationCompat.BigPictureStyle().bigPicture(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)))
                        .build();
```

setPriority() 方法可以用于设置通知的重要程度，该方法接收一个整型参数用于设置这条通知的重要程度，一共有五中常量值可以选：

- PRIORITY_DEFAULT：表示默认的重要程度，和不设置的效果一样
- PRIORITY_MIN：表示最低的重要程度，系统可能只会在特定的场景才显示这条通知，如用户下拉状态栏的时候
- PRIORITY_LOW：表好似较低的重要程度，系统可能会将这类通知缩小，或改变其显示的顺序，将其排在更重要的通知之后
- PRIORITY_HIGH：表示较高的重要程度，系统可能会将这类通知放大，或该表其显示的顺序，将其排在比较靠前的位置
- PRIORITY_MAX：表示最高的重要程度，这类通知消息必须要让用户立刻看到，甚至需要用户做出响应操作

```java
Notification notification = new NotificationCompat.Builder(this)
                        ...
                        .setPriority(NotificationManager.IMPORTANCE_MAX)
                        .build();
```



### 调用手机摄像头拍照

新建一个 CameraAlbumTest 项目，修改 activity_main.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

	//用于打开摄像头进行拍照
    <Button
        android:id="@+id/take_photo"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Take Photo" />
    
    //用于将拍到的图片显示出来
    <ImageView
        android:id="@+id/picture"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_vertical" />

</LinearLayout>
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    private static final int TAKE_PHOTO = 1;

    private ImageView picture;

    private Uri imageUri;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        //分别获取 Button 和 ImageView 实例
        Button takePhoto = (Button) findViewById(R.id.take_photo);
        picture = (ImageView) findViewById(R.id.picture);
        takePhoto.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                //创建 File 对象，用于存储拍照后的图片，这里把图片命名为 outputimage.jpg，并将它存放在手机 SD 卡的应用关联缓存目录下
                //应用关联缓存目录是指 SD 卡中专门用于存放当前应用缓存数据的位置，调用 getExternalCacheDir() 方法可以得到这个目录，具体的路径是 /sdcard/Android/data/<package name>/cache
                //使用应用关联缓存目录来存放图片是因为从 Android 6.0 开始，读写 SD 卡被列为了危险权限，如果将图片存放在 SD 卡的任何其他目录都要进行运行时权限处理才行，而使用应用关联目录则可以跳过这一步
                File outputImage = new File(getExternalCacheDir(), "output_image.jpg");
                try {
                    if (outputImage.exists()) {
                        outputImage.delete();
                    }
                    outputImage.createNewFile();
                } catch (IOException e) {
                    e.printStackTrace();
                }
                //进行一个判断，如果该运行设备版本低于 Android 7.0，就调用 Uri 的 fromFile() 方法将 File 对象转换成 Uri 对象，这个 Uri 对象标识着 output_image.jpg 这张图片的本地准时路径，否则就调用 FileProvider() 的 getUriForFile() 方法将 File 对象转换成一个封装过得 Uri 对象
                //进行这样一层转换是因为 Android 7.0 开始，直接使用本地真实路径的 Uri 被认为是不安全的，会抛出一个 FileURIExposedException 异常，而 FileProvider 则是一种特殊的内容提供器，它使用和内容提供器类似的机制来对数据进行保护，可以选择性地将封装过的 Uri 共享给外部，从而提高了应用的安全性
                if (Build.VERSION.SDK_INT >= 24) {
                    //getUriForFile() 方法接收三个参数，第一个参数是 Context对象，第二个参数可以是任意唯一的字符串，第三个参数则是 File 对象
                    imageUri = FileProvider.getUriForFile(MainActivity.this, "com.example.cameraalbumtest.fileprovider", outputImage);
                } else {
                    imageUri = Uri.fromFile(outputImage);
                }
                //启动相机程序
                //使用隐式 Intent，系统会展出能够响应这个 Intent 的活动去启动，这样照相机程序就会被打开，拍下的照片会输出到 output_image.jpg
                //构建一个 Intent 对象，将这个 Intent 的 action 指定为 android.media.action.IMAGE_CAPTURE
                Intent intent = new Intent("android.media.action.IMAGE_CAPTURE");
                //再调用 putExtra() 方法指定图片的输出地址，填入刚刚得到的 Uri 对象
                intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri);
                //最后调用 startActivityForResult() 启动活动
                startActivityForResult(intent, TAKE_PHOTO);
            }
        });
    }

    //使用 startActivityForResult() 来启动活动的，因此拍完照后会有结果返回到 onActivityResult() 方法将 outputimage.jpg 这张照片解析成 Bitmap 对象，然后把它设置到 ImageView 中显示出来
    @Override
    protected void onActivityResult (int requestCode, int resultCode, Intent data) {
        switch (requestCode) {
            case TAKE_PHOTO:
                if (resultCode == RESULT_OK) {
                    try {
                        //将拍摄的照片显示出来
                        //将 outputimage.jpg 这张照片解析成 Bitmap 对象，然后把它设置到 ImageView 中显示出来
                        Bitmap bitmap = BitmapFactory.decodeStream(getContentResolver().openInputStream(imageUri));
                        
                        picture.setImageBitmap(bitmap);
                    } catch (FileNotFoundException e) {
                        e.printStackTrace();
                    }
                }
                break;
            default:
                break;
        }
    }
}
```

内容提供器需要在 AndroidManifest.xml 进行注册

```java
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.cameraalbumtest">

    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />

    <application
            android:allowBackup="true"
            android:icon="@mipmap/ic_launcher"
            android:label="@string/app_name"
            android:roundIcon="@mipmap/ic_launcher_round"
            android:supportsRtl="true"
            android:theme="@style/AppTheme">
            ...
        <provider
        	//android:authorities 属性的值必须要和刚才的 FileProvider.getUriForFile() 方法中的第二个参数一致
            android:authorities="com.example.cameraalbumtest.fileprovider"
            //android:name 属性固定
            android:name="android.support.v4.content.FileProvider"
            android:exported="false"
            android:grantUriPermissions="true">
            //<provider 标签的内部使用 <meta-data> 标签来指定 Uri 的共享路径，并引用了一个 @xml/file_paths 资源
            <meta-data
                android:name="android.support.FILE_PROVIDER_PATHS"
                android:resource="@xml/file_paths" />
        </provider>
    </application>

</manifest>
```

右击 res 目录 -> New -> Directory -> Directory，创建一个 xml 目录，右击 xml 目录 -> New -> File，创建 file_paths.xml，修改它

```java
<?xml version="1.0" encoding="UTF-8"?>
<paths xmlns:android="http://schemas.android.com/apk/res/android">
	//external-path 用来指定 Uri 共享的，name 属性的值可以随便填，path 属性的值表示共享的具体路径
    <external-path
        name="my_images"
    	//这里设置 path 属性的值为控制表示将整个 SD 卡进行共享，当然也可以仅共享存放的 output_image.jpg 这张图片的路径
        path="" />
</paths>
```

在 Android 4.4 之前访问 SD 卡的应用关联目录也是要声明权限的，从 4.4 开始不再需要权限声明，为了兼容老版本系统的手机，在 AndroidManifest.xml 中声明访问 SD 卡的权限

```java
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.cameraalbumtest">

    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />

	...

</manifest>
```



### 从相册中选择照片

修改 activity_main.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <Button
        android:id="@+id/take_photo"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Take Photo" />
    
    <Button
        android:id="@+id/chosse_from_album"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Choose From Album" />

    <ImageView
        android:id="@+id/picture"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_vertical" />

</LinearLayout>
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    private static final int TAKE_PHOTO = 1;

    private static final int CHOOSE_PHOTO = 2;

    private ImageView picture;

    private Uri imageUri;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button takePhoto = (Button) findViewById(R.id.take_photo);
        Button chooseFromAlbum = (Button) findViewById(R.id.chosse_from_album);
        picture = (ImageView) findViewById(R.id.picture);
        takePhoto.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                //创建 File 对象，用于存储拍照后的图片
                File outputImage = new File(getExternalCacheDir(), "output_image.jpg");
                try {
                    if (outputImage.exists()) {
                        outputImage.delete();
                    }
                    outputImage.createNewFile();
                } catch (IOException e) {
                    e.printStackTrace();
                }
                if (Build.VERSION.SDK_INT >= 24) {
                    imageUri = FileProvider.getUriForFile(MainActivity.this, "com.example.cameraalbumtest.fileprovider", outputImage);
                } else {
                    imageUri = Uri.fromFile(outputImage);
                }
                //启动相机程序
                Intent intent = new Intent("android.media.action.IMAGE_CAPTURE");
                intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri);
                startActivityForResult(intent, TAKE_PHOTO);
            }
        });
        
        //在 Choose From Album 按钮的点击事件里先是进行了一个运行时权限处理，动态申请 WRITE_EXTERNAL_STORAGE 这个危险权限，因为相册中的照片是存在 SD 卡上的，我们要从 SD 卡中读取照片就需要申请这个权限，WRITE_EXTERNAL_STORAGE 表示同时授予程序对 SD 卡读和写的能力
        chooseFromAlbum.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
                    ActivityCompat.requestPermissions(MainActivity.this, new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE}, 1);
                } else {
                    openAlbum();
                }
            }
        });
    }

    //用户授权了权限申请之后就会调用 openAlbum 方法
    private void openAlbum() {
        //先构建一个 Intent 对象，将它的 action 指定为 android.intent.action.GET_CONTENT
        Intent intent = new Intent("android.intent.action.GET_CONTENT");
        //给 Intent 设置一些必要的参数
        intent.setType("image/*");
        //调用 startActivityForResult() 方法来打开相册，第二个参数变成 CHOOSE_PHOTO，这样当从相册选择完图片回到 startActivityForResult() 方法时，就会进入 CHOOSE_PHOTO 的 case 来处理图片
        startActivityForResult(intent, CHOOSE_PHOTO); //打开相册
    }

    @Override
    public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
        switch (requestCode) {
            case 1:
                if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                    openAlbum();
                } else {
                    Toast.makeText(this, "You denied the peimission", Toast.LENGTH_SHORT).show();
                }
                break;
            default:
        }
    }

    @Override
    protected void onActivityResult (int requestCode, int resultCode, Intent data) {
        switch (requestCode) {
            case TAKE_PHOTO:
                if (resultCode == RESULT_OK) {
                    try {
                        //将拍摄的照片显示出来
                        Bitmap bitmap = BitmapFactory.decodeStream(getContentResolver().openInputStream(imageUri));
                        picture.setImageBitmap(bitmap);
                    } catch (FileNotFoundException e) {
                        e.printStackTrace();
                    }
                }
                break;
            case CHOOSE_PHOTO:
                if (resultCode == RESULT_OK) {
                    //判断手机系统版本号，因为从 4.4 开始，选择相册中的图片不再返回图片的真实 Uri，而是一个封装过的 Uri，因此 4.4 版本以上的手机需要对这个 Uri 进行解析
                    if (Build.VERSION.SDK_INT >= 19) {
                        //4.4 及以上系统使用这个方法处理图片
                        handleImageOnKitKat(data);
                    } else {
                        //4.4 以下系统使用这个该方法处理图片
                        handleImageBeforeKitKat(data);
                    }
                }
            default:
                break;
        }
    }

    //解析这个封装过的 Uri
    @TargetApi(19)
    private void handleImageOnKitKat(Intent data) {
        String imagePath = null;
        Uri uri = data.getData();
        //如果是 document 类型的 Uri，那就取出 document id 进行处理
        if (DocumentsContract.isDocumentUri(this, uri)) {
            String docId = DocumentsContract.getDocumentId(uri);
            //如果 Uri 的 authority 是 media 格式的话，document id 还需要再进行一次解析，要通过字符串分割的方式取出后半部分才能得到真正的数字 id。取出的 id 用于构建新的 Uri 和条件语句，然后把这些值作为参数传入到 getImagePath() 方法当中，就可以得到真实路径
            if ("com.android.providers.media.documents".equals(uri.getAuthority())) {
                String id = docId.split(":")[1];
                String selection = MediaStore.Images.Media._ID + "=" + id;
                imagePath = getImagePath(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection);
            } else if ("com.android.providers.downloads.documents".equals(uri.getAuthority())){
                Uri contentUri = ContentUris.withAppendedId(Uri.parse("content://downloads/public_downloads"), Long.valueOf(docId));
                imagePath = getImagePath(contentUri, null);
            }
        } else if ("file".equalsIgnoreCase(uri.getScheme())) {
            //如果是 content 类型的 Uri ，则使用普通方式处理
            imagePath = getImagePath(uri, null);
        } else if ("file".equalsIgnoreCase(uri.getScheme())) {
            //如果是 file 类型的 Uri ，直接获取图片路径即可
            imagePath = uri.getPath();
        }
        //拿到图片的路径之后，再调用 displayImage() 方法将图片显示到界面上
        displayImage(imagePath);    //根据图片路径显示图片
    }

    // handleImageBeforeKitKat() 方法直接将 Uri 传入到 getImagePath() 方法当中就能直接获取到图片的真是路径，最后调用 displayImage() 方法将图片显示到界面上
    private void handleImageBeforeKitKat(Intent data) {
        Uri uri = data.getData();
        String imagePath = getImagePath(uri, null);
        displayImage(imagePath);
    }

    private String getImagePath(Uri uri, String selection) {
        String path = null;
        //通过 Uri 和 selection 来获取真实的图片路径
        Cursor cursor = getContentResolver().query(uri, null, selection, null, null);
        if (cursor != null) {
            if (cursor.moveToFirst()) {
                path = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA));
            }
            cursor.close();
        }
        return path;
    }

    private void displayImage(String imagePath) {
        if (imagePath != null) {
            Bitmap bitmap = BitmapFactory.decodeFile(imagePath);
            picture.setImageBitmap(bitmap);
        } else {
            Toast.makeText(this, "failed to get image", Toast.LENGTH_SHORT).show();
        }
    }

}
```





### 播放音频

在 Android 中播放音频文件一般都是使用 MediaPlayer 来实现的，它对多种格式的音频文件提供了非常全面的控制方法，从而使得播放音乐的工作变得十分简单

MediaPlayer 的工作流程：

- 创建出一个 MediaPlayer 对象
- 调用 setDataSource() 方法来设置音频文件的路径
- 调用 prepare() 方法使 MediaPlayer 进入到准备状态
- 调用 start() 方法开始播放音频
- 调用 pause() 方法暂停播放
- reset() 方法停止播放

新建 PlayAudioTest 项目，修改 activity_main.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <Button
        android:id="@+id/play"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Paly" />

    <Button
        android:id="@+id/pause"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Pause" />

    <Button
        android:id="@+id/stop"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Stop"/>

</LinearLayout>
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener{

    //在类初始化的时候先创建一个 MediaPlay 实例
    private MediaPlayer mediaPlayer = new MediaPlayer();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button play = findViewById(R.id.play);
        Button pause = findViewById(R.id.pause);
        Button stop = findViewById(R.id.stop);
        play.setOnClickListener(this);
        pause.setOnClickListener(this);
        stop.setOnClickListener(this);
        //动态申请 WRITE_EXTERNAL_STORAGE 权限，因为我们待会会在 SD 卡中放置一个音频文件，程序为了播放这个音频文件必须拥有访问 SD 卡的权限才行
        if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(MainActivity.this, new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE}, 1);
        } else {
            initMediaPlayer();//初始化 MediaPlayer
        }
    }

    //用户同意授权后就会调用该方法为 MediaPlayer 对象进行初始化操作
    private void initMediaPlayer() {
        try {
            //创建一个 File 对象来指定音频文件的路径，从中看出我们需要事先在 SD 卡的目录下放置一个 music.mp3 的音频文件
            File file = new File(Environment.getExternalStorageDirectory(), "music.mp3");
            //依次调用 setDataSource() 方法和 prepare() 方法为 MediaPlayer 做好了播放前的准备
            mediaPlayer.setDataSource(file.getPath());  //指定音频文件的路径
            mediaPlayer.prepare();  //让 Media 进入到准备状态
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    //在 onRequestPermissionsResult() 方法中，如果用户拒绝了权限的申请，那么调用 finish() 方法将程序关闭，因为没有 SD 卡的访问权限，我们这个程序什么都干不了
    @Override
    public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
        switch (requestCode) {
            case 1:
                if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                    initMediaPlayer();
                } else {
                    Toast.makeText(this, "拒绝权限将无法使用程序", Toast.LENGTH_SHORT).show();
                    finish();
                }
                break;
            default:
        }
    }

    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            //当点击 play 按钮时会进行判断，如果当前的 MediaPlayer 没有正在播放音频，则调用 start() 方法开始播放
            case R.id.play:
                if (!mediaPlayer.isPlaying()) {
                    mediaPlayer.start();    //开始播放
                }
                break;  
            //当点击 pause 按钮时会进行判断，如果当前的 MediaPlayer 正在播放音频，则调用 pause() 方法暂停播放
            case R.id.pause:
                if (mediaPlayer.isPlaying()) {
                    mediaPlayer.pause();    //暂停播放
                }
                break;
            //当点击 stop 按钮时会进行判断，如果当前 MediaPlayer 正在播放音频，则会调用 reset() 方法将 MediaPlayer 重置为刚刚创建的状态，然后再重新调用一遍 initMediaPlayer() 方法
            case R.id.stop:
                if (mediaPlayer.isPlaying()) {
                    mediaPlayer.reset();    //停止播放
                    initMediaPlayer();
                }
                break;
            default:
                break;
        }
    }

    //最后在 onDestroy() 方法中分别调用 stop() 和 release() 方法，将与 MediaPlayer 相关的资源释放掉
    @Override
    protected void onDestroy() {
        super.onDestroy();
        if (mediaPlayer != null) {
            mediaPlayer.stop();
            mediaPlayer.release();
        }
    }
    
}
```

在 AndroidManifest.xml 文件中声明权限

```java
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.playaudiotest">

    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />

	...

</manifest>
```



### 播放视频

主要使用 VideoView 类来实现的，这个类将视频的显示和控制集于一身

新建 PlayVideoTest 项目，修改 activity_main.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

        <Button
            android:id="@+id/play"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Play" />

        <Button
            android:id="@+id/pause"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Play" />

        <Button
            android:id="@+id/replay"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Replay" />

	</LinearLayout>

    <VideoView
        android:id="@+id/video_view"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

</LinearLayout>
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener{

    //在类初始化的时候创建一个 VideoView 实例
    private VideoView videoView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        videoView = findViewById(R.id.video_view);
        Button play = findViewById(R.id.play);
        Button pause = findViewById(R.id.pause);
        Button replay = findViewById(R.id.replay);
        play.setOnClickListener(this);
        pause.setOnClickListener(this);
        replay.setOnClickListener(this);
        //进行一个运行时权限处理，因为音频文件将会放在 SD 卡上，当用户同意授权之后就会调用 initVideoPath() 方法来设置视频文件的路径，这里我们需要是现在 SD 卡的根目录下放置一个名为 movie.mp4 的视频文件
        if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(MainActivity.this, new String[] {Manifest.permission.WRITE_EXTERNAL_STORAGE}, 1);
        } else {
            initVideoPath();    //初始化 VideoView
        }
    }

    private void initVideoPath() {
        File file = new File(Environment.getExternalStorageDirectory(), "movie.mp4");
        videoView.setVideoPath(file.getPath());    //指定视频文件的路径
    }

    @Override
    public  void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
        switch (requestCode) {
            case 1:
                if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                    initVideoPath();
                } else {
                    Toast.makeText(this, "拒绝权限将无法使用程序", Toast.LENGTH_SHORT).show();
                    finish();
                }
                break;
            default:
        }
    }

    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            //当点击 Play 按钮时会进行判断，如果当前并没有正在播放的视频，则调用 start() 方法开始播放
            case R.id.play:
                if (!videoView.isPlaying()) {
                    videoView.start();    //开始播放
                }
                break;
            //当点击 Pause 按钮时会进行判断，如果当前视频正在播放，则调用 pause() 方法暂停播放
            case R.id.pause:
                if (videoView.isPlaying()) {
                    videoView.pause();     //暂停播放
                }
                break;
            //当点击 Replay 按钮时会进行判断，如果当前视频正在播放，则调用 resume() 方法从头播放视频
            case R.id.replay:
                if (videoView.isPlaying()) {
                    videoView.resume();    //重新播放
                }
                break;
        }
    }

    //最后在 onDestroy() 方法中调用 suspend() 将 VideoView 所占用资源释放掉
    @Override
    protected void onDestroy() {
        super.onDestroy();
        if (videoView != null) {
            videoView.suspend();
        }
    }

}
```

在 AndroidManifest.xml 文件中声明用到的权限

```java
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.playvideotest">

    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />

    ...
    
</manifest>
```

VideoView 和 MediaPlayer 很相似，是因为 VideoView 只是帮我们做了一个很好的封装而已，它的背后仍然是使用 MediaPlayer 来对视频文件进行控制的

VideoView 并不是一个万能的视频播放工具类，它在视频格式的支持以及播放效率方面都存在着较大的不足，所以如果想要仅仅使用 VideoView 就编写出一个功能非常强大的视频播放器是不太现实的，但是如果只是用于播放一些游戏的片头动画，或者某个应用的视频宣传，使用 VideoView 还是绰绰有余的。





## 使用网络技术



### WebView 的用法

在应用程序里展示一些网页，不允许打开系统浏览器，Android 提供了一个 WebView 控件，借助它我们就可以在自己的应用程序里嵌入一个浏览器，从而轻松地浏览各种各样的网页

新建一个 WebViewTest 项目，修改 activity_main.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <WebView
        android:id="@+id/web_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent">
    </WebView>

</LinearLayout>
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        //使用 findViewById() 方法获取到了 WebView 实例
        WebView webView = findViewById(R.id.web_view);
        //然后调用 getSettings() 方法设置一些浏览器的属性，但这里只是调用了 setJavaScriptEnabled() 方法来让 WebView 支持 JavaScript 脚本
        webView.getSettings().setJavaScriptEnabled(true);
        //重要，调用了 WebView 的 setWebViewClient() 方法，并传入了一个 WebViewClient 的实例，作用是当需要从一个网页跳转到另一个网页的时候，我们希望目标网页仍然在当前的 WebView 中显示，而不是打开系统浏览器
        webView.setWebViewClient(new WebViewClient());
        //调用 WebView 的 loadUrl() 方法，并将网址传入，即可展示相应网页的内容
        webView.loadUrl("http://baidu.com");
    }
}
```

修改 AndroidMainfest.xml 加入权限声明

```java
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.webviewtest">

    <uses-permission android:name="android.permission.INTERNET" />

    ...

</manifest>
```



### 使用 HTTP 协议访问网络

对于 HTTP 协议只需要了解它的工作原理：客户端向服务器发出一条 HTTP 请求，服务器收到请求信息之后会返回一些数据给客户端，然后客户端再对这些数据进行解析和处理就可以了。一个浏览器的基本原理也就是如此了。

比如上一节中使用到的 WebView 控件，其实也就是我们向百度的服务器发起了一条 HTTP 请求，接着服务器分析出我们想要访问的是百度的首页，于是会把该网页的 HTML 代码进行返回，然后 WebView 再调用手机浏览器的内核对返回的 HTML 代码进行解析，最终将页面展示出来，简单地说 WebView 已经在后台帮我们处理好了发送 HTTP 请求、接收服务器响应、解析返回数据以及最终的页面展示这几步工作。



#### 使用 HttpURLConnection

在过去，Android 上发送 HTTP 的请求一般有两种方式：HttpURLConnection 和 HttpClient

Android 6.0 开始官方建议使用 HttpURLConnection 在 Android 上发送 HTTP 请求，HttpClient 的功能已经被完全移除了

首先需要获取到 HttpURLConnection 的实例，一般只需要 new 出一个 URL 对象，并传入目标的网络地址，然后调用一下 openConnection() 方法即可

```java
URL url= new URL("http://www.baidu.com");
HttpURLConnection connection = (HttpURLConnection) url.openConnection();
```

在得到 HttpURLConnection 的实例之后，我们可以设置一下 HTTP 请求所使用的方法，常用的方法主要有两个：GET 和 POST。GET 表示希望从服务器那里获取到数据。POST 则表示希望提交数据给服务器

```java
connection.setRequestMethod("GET");
```

接下来就可以进行一些自由的定制了，比如设置中连接超时、读取超时的毫秒数，以及服务器希望得到的一些消息头等，实例写法如下：

```java
connection.setConnectionTimeout(8000);
connection.setReadTimeout(8000);
```

之后再调用 getInputStream() 方法就可以获取到服务器返回的输入流了，剩下的任务就是对输入流进行读取

```java
InputStream in = cononection.getInputStream();
```

最后调用 disconnection() 方法将这个 HTTP 连接关闭掉

```java
connection.disconnect();
```

新建 NetworkTest 项目，修改 activity_main.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

	//Button 用于发送 HTTP 请求
    <Button
        android:id="@+id/send_request"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Send Request" />

    //ScrollView 可以以滚动的形式查看屏幕外的那部分内容
    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="match_parent">

		//TextView 用于将服务器返回的数据显示出来
        <TextView
            android:id="@+id/response_text"
            android:layout_width="match_parent"
            android:layout_height="wrap_content" />
    </ScrollView>

</LinearLayout>
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener {

    TextView responseText;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button sendRequest = findViewById(R.id.send_request);
        responseText = findViewById(R.id.response_text);
        sendRequest.setOnClickListener(this);
    }

    //在 Send Request 按钮的点击事件里调用了 sendRequestWithHttpURLConnection() 方法
    @Override
    public void onClick(View v) {
        if (v.getId() == R.id.send_request) {
            sendRequestWithHttpURLConnection();
        }
    }
    
    private void sendRequestWithHttpURLConnection() {
        //开启子线程来发起网络请求，在子线程里使用 HttpURLConnection 发出一条 HTTP 请求，请求的目标地址是百度的首页
        new Thread(new Runnable() {
            @Override
            public void run() {
                HttpURLConnection connection = null;
                BufferedReader reader = null;
                try {
                    URL url = new URL("https://www.baidu.com");
                    connection = (HttpURLConnection) url.openConnection();
                    connection.setRequestMethod("GET");
                    connection.setConnectTimeout(8000);
                    connection.setReadTimeout(8000);
                    InputStream in = connection.getInputStream();
                    //利用 BufferedReader 对服务器返回的流进行读取，并将结果传入到 showResponse() 方法
                    //下面对获取到的输入流进行读取
                    reader = new BufferedReader(new InputStreamReader(in));
                    StringBuilder response = new StringBuilder();
                    String line;
                    while ((line = reader.readLine()) != null) {
                        response.append(line);
                    }
                    showResponse(response.toString());
                } catch (Exception e) {
                    e.printStackTrace();
                } finally {
                    if (reader != null) {
                        try {
                            reader.close();
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    }
                    if (connection != null) {
                        connection.disconnect();
                    }
                }
            }
        }).start();
    }

    private void showResponse(final String response) {
        //调用一个 runOnUiThread() 方法，在这个方法的匿名类参数中进行操作，将返回的数据显示到界面上
        //使用 runOnUiThread() 方法是因为 Android 是不允许在子线程中进行 UI 操作的，我们需要通过这个方法将线程切换到主线程，然后更新 UI 元素
        runOnUiThread(new Runnable() {
            @Override
            public void run() {
                //在这里进行 UI 操作，将结果显示到界面上
                responseText.setText(response);
            }
        });
    }
    
}
```

声明网络权限，修改 AndroidManifest.xml

```java
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.networktest">
    
    <uses-permission android:name="android.permission.INTERNET" />

    ...

</manifest>
```

点击按钮后出现的数据就是服务器返回给我们的 HTML 这种代码，只是通常情况下浏览器都会将这些代码解析成漂亮的网页后在展示出来

想要提交数据给服务器只需要将 HTTP 请求方式改成 POST，并在获取输入流之前把要提交的数据写出即可，注意每条数据都要以键值对的形式存在，数据与数据之间用 “&” 符号隔开

比如我们想要想服务器提交用户名和密码，就可以这样写：

```java
connection.setRequesMethod("POST");
DataOutputStream out = new DataOutputStream(connection.getOutputStream());
out.writeBytes("username = admin & password = 123456);
```



#### 使用 OkHttp

网络通信库 OkHttp ，可以替代原生的 HttpURLConnection，主页是 https://github.com/square/okhttp

app/build.gradle 在 dependencies 闭包中添加：

```java
//添加该依赖会自动下载两个库，一个是 OkHttp 库，一个是 Okio 库，后者是前者的通信基础
implementation 'com.squareup.okhttp3:okhttp:3.4.1'
```

OkHttp 具体用法：首先创建一个 OkHttpClient 实例

```java
OkHttpClient client = new  OkHttpClient();
```

如果想要发起一条 HTTP 请求，就需要创建一个 Request 对象

```java
Request request = new Request.Builder().build();
```

上述代码只是创建了一个空的 Request 对象，并没有什么作用，我们可以在最终的 build() 方法之前连缀很多其它方法来丰富这个 Request 对象，比如通过 url() 方法来设置目标的网络地址

```java
Request request = new Request.Builder()
		.url("http://www.baidu.com")
		.build();
```

之后调用 OkHttpClient 的 newCall() 方法来创建一个 Call 对象，并调用它的 execute() 方法来发送请求并获取服务器返回的数据

```java
Response response = client.newCall(request).execute();
```

Response 对象就是服务器返回的数据，可以使用以下写法来得到返回的具体内容：

```java
String responseData = response.body().string();
```

如果发起一条 POST 请求，我们首先要构建出一个 RequestBody 对象来存放待提交的参数

```java
RequestBody requestBody = new  FormBody.Builder()
		.add("username", "admin")
		.add("password", "123456")
		.build();
```

然后在 Request.Builder 中调用 post() 方法，并将 RequestBody 对象传入

```java
Request request = new Request.Builder()
		.url("http://www.baidu.com")
		.post(requestBody)
		.build();
```

接下来的操作就和 GET 请求一样了，调用 execute() 方法来发送请求并获取服务器返回的数据即可

把 NetworkTest 项目改用 OkHttp 的方式实现，修改 MainActivity

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener {

	...

    @Override
    public void onClick(View v) {
        if (v.getId() == R.id.send_request) {
            sendRequestWithOkHttp();
        }
    }

    //添加一个 sendRequestWithOkHttp() 方法，并在 Send Request 按钮的点击事件里去调用这个方法
    private void sendRequestWithOkHttp() {
        //在子线程里面使用 OkHttp 发出一条 HTTP 请求，请求的目标地址还是百度的首页
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    OkHttpClient client = new OkHttpClient();
                    Request request = new Request.Builder()
                            .url("http://www.baidu.com")
                            .build();
                    Response response = client.newCall(request).execute();
                    String responseData = response.body().string();
                    //最后一样使用 showResponse() 方法来讲服务器返回的数据显示到界面上
                    showResponse(responseData);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }).start();
    }

	...

}
```



### 解析 XML 数据

通常情况下，每个需要访问网络的应用程序都会有一个自己的服务器，我们可以向服务器提交数据，也可以从服务器上获取数据。一般我们都会在网络上传输一些格式化后的数据，这种数据会有一定的结构规格和语义，当另一方收到消息之后就可以按照相同的规格进行解析，从而取出他想要的那部分内容。

在网络上传输数据时最常用的格式有两种：XML 和 JSON

下载安装 Apache，在 */htdocs 目录下新建 get_data.xml

```xml
<apps>
	<app>
		<id>1</id>
		<name>Google Maps</name>
		<version>1.0</version>
	</app>
	<app>
		<id>2</id>
		<name>Chrome</name>
		<version>2.1</version>
	</app>
	<app>
		<id>3</id>
		<name>Google Play</name>
		<version>2.3</version>
	</app>
</apps>
```



#### Pull 解析方式

解析 XML 有很多种方式，我们学习 Pull 和 SAX 解析，在 NetworkTest 项目上继续，修改 MainActivity

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener {

	...

    private void sendRequestWithOkHttp() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    OkHttpClient client = new OkHttpClient();
                    Request request = new Request.Builder()
                            //指定访问的服务器是电脑本机
                        	//10.0.2.2 对于模拟器来说就是电脑本机的 IP 地址
                            .url("http://10.0.2.2/get_data.xml")
                            .build();
                    Response response = client.newCall(request).execute();
                    String responseData = response.body().string();
                    //得到了服务器返回的数据后调用 parseXMLWithPull() 方法来解析
                    parseXMLWithPull(responseData);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }).start();
    }

    private void parseXMLWithPull(String xmlData) {
        try {
            //首先获取一个 XmlPullParserFactory 实例
            XmlPullParserFactory factory = XmlPullParserFactory.newInstance();
            //借助这个实例得到 XmlPullParser 对象
            XmlPullParser xmlPullParser = factory.newPullParser();
            //调用 XmlPullParser 的 setInput() 方法将服务器返回的 XML 数据设置进去就可以开始解析了
            xmlPullParser.setInput(new StringReader(xmlData));
            //通过 getEventType() 方法可以得到当前的解析事件
            int eventType = xmlPullParser.getEventType();
            String id = "";
            String name = "";
            String version ="";
            //接着在一个 while 循环里不断解析，如果当前的解析事件不等于 XmlPullParser.END_DOCUMENT，说明解析工作还没有完成，调用 next() 方法后可以获取下一个解析事件
            while (eventType != XmlPullParser.END_DOCUMENT) {
                //通过 getName() 方法来获取当前节点的名字，如果发现节点名等于 id、name 或 version，就调用 nextText() 方法来获取节点内具体的内容，每当解析完一个 app 节点后就将取到的内容打印出来
                String nodeName = xmlPullParser.getName();
                switch (eventType) {
                    //开始解析某个节点
                    case XmlPullParser.START_TAG: {
                        if ("id".equals(nodeName)) {
                            id = xmlPullParser.nextText();
                        } else if ("name".equals(nodeName)) {
                            name = xmlPullParser.nextText();
                        } else if ("version".equals(nodeName)) {
                            version = xmlPullParser.nextText();
                        }
                        break;
                    }
                    //完成解析某个节点
                    case XmlPullParser.END_TAG: {
                        if ("app".equals(nodeName)) {
                            Log.d("MainActivity", "id is " + id);
                            Log.d("MainActivity", "name is " + name);
                            Log.d("MainActivity", "version is " + version);
                        }
                        break;
                    }
                    default:
                        break;
                }
                eventType = xmlPullParser.next();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

	...
    
}
```





#### SAX 解析方式

通常情况下我们都会新建一个类继承自 DefaultHandler，并重写父类的五个方法

```java
public class MyHandler extends DefaultHandler {
    
    //开始解析 XML 的时候调用
 	@Override
    public void startDocument() throws SAXException {
    }
    
    //开始解析某个节点的时候调用
    @Override
    public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
    }
    
    //在获取节点中内容的时候调用
    @Override
    public void characters(char[] ch, int start, int length)throws SAXException {    
    }   
    
    //完成解析某个节点的时候调用
    @Override
    public void endElement(String uri, String localName, String qName) throws SAXException{
    }
    
    //完成整个 XML 解析的时候调用
    @Override
    public void endDocument() throws SAXEception {
    }
}
```

其中 startElement()、characters() 和 endElement() 三个方法是有参数的，从 XML 中解析出来的数据就会以参数的形式传入到这些方法当中

需要注意的是，在获取节点当中的内容时， characters() 方法可能会被调用很多次，一些换行符也被当作内容解析出来，我们需要针对这种情况在代码中做好控制 

新建 ContentHandler 类继承 DefaultHandler

```java
public class ContentHandler extends DefaultHandler {

    private String nodeName;

    //给 id、name 和 version 分别定义了一个 StringBuilder 对象，并在 startDocument() 方法中对他们进行初始化
    private StringBuilder id;

    private StringBuilder name;

    private StringBuilder version;

    @Override
    public void startDocument() throws SAXException {
        id = new StringBuilder();
        name = new StringBuilder();
        version = new StringBuilder();
    }

    //每当开始解析某个节点的时候， startElement() 方法就会得到调用，其中 localName 参数记录着当前节点的名字，这里我们记录下来
    @Override
    public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
        //记录当前节点名
        nodeName = localName;
    }

    //在解析节点中具体内容的时候就会调用 characters() 方法
    @Override
    public void characters(char[] ch, int start, int length) throws SAXException {
        //根据当前的节点名判断将内容添加到哪一个 StringBuilder 对象中
        if ("id".equals(nodeName)) {
            id.append(ch, start, length);
        } else if ("name".equals(nodeName)) {
            name.append(ch, start, length);
        } else if ("version".equals(nodeName)) {
            version.append(ch, start, length);
        }
    }
    
    //最后在 endElement() 方法中进行判断，如果 app 节点已经解析完成，就打印出 id、name 和 version 的内容
    @Override
    public void endElement(String uri, String localName, String qName) throws SAXException {
        if ("app".equals(localName)) {
            //因为 id、name 和 version 中都有可能包括回车或换行符，因此打印前调用一下 trim() 方法
            Log.d("ContentHandler", "id is " + id.toString().trim());
            Log.d("ContentHandler", "name is " + name.toString().trim());
            Log.d("ContentHandler", "version is " + version.toString().trim());
            //最后将 StringBuilder 的内容清空掉，不然会影响下一次内容的读取
            id.setLength(0);
            name.setLength(0);
            version.setLength(0);
        }
    }
    
    @Override
    public void endDocument() throws SAXException {
        super.endDocument();
    }
    
}
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener {

   	...

    @Override
    public void onClick(View v) {
        if (v.getId() == R.id.send_request) {
            sendRequestWithOkHttp();
        }
    }

    private void sendRequestWithOkHttp() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    OkHttpClient client = new OkHttpClient();
                    Request request = new Request.Builder()
                            //指定访问的服务器地址是电脑本机
                            .url("http://10.0.2.2/get_data.xml")
                            .build();
                    Response response = client.newCall(request).execute();
                    String responseData = response.body().string();
                    //得到服务器返回的数据之后，调用 parseXMLWithSAX() 方法来解析 XML 数据
                    parseXMLWithSAX(responseData);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }).start();
    }

    private void parseXMLWithSAX(String xmlData) {
        try {
            //创建一个 SAXParserFactory 对象
            SAXParserFactory factory = SAXParserFactory.newInstance();
            //再获取 XMLReader 对象
            XMLReader xmlReader = factory.newSAXParser().getXMLReader();
            ContentHandler handler = new ContentHandler();
            //将 ContentHandler 的实例设置到 XMLReader 中
            xmlReader.setContentHandler(handler);
            //最后调用 parse() 方法开始执行解析
            xmlReader.parse(new InputSource(new StringReader(xmlData)));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

	...

}
```



### 解析 JSON 数据

比起 XML，JSON 的主要优势在于它的体积更小，在网络上传输的时候可以更省流量，但缺点在于它的语义较差，看起来不如 XML 直观

在 *\htdocs 目录中新建一个 get_data.json 

```json
[{"id":"5","version":"5.5","name":"Clash of Clans"},
{"id":"6","version":"7.0","name":"Boom Beach"},
{"id":"7","version":"3.5","name":"Clash Royale"}]
```

在浏览器中访问 127.0.0.1/get_data.json



#### 使用 JSONObject

解析 JSON 也有很多种方法，官方提供 JSONObject，也可以使用谷歌的开源库 GSON，另外第三方的开源库如 Jackson、FastJSON 也非常不错

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener {

	...

    private void sendRequestWithOkHttp() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    OkHttpClient client = new OkHttpClient();
                    Request request = new Request.Builder()
                            //指定访问的服务器地址是电脑本机
                        	//将 HTTP 请求改为 http://10.0.2.2/get_data.json
                            .url("http://10.0.2.2/get_data.json")
                            .build();
                    Response response = client.newCall(request).execute();
                    String responseData = response.body().string();
                    //得到服务器返回的数据后调用 parseJSONWithJSONObject() 方法来解析数据
                    parseJSONWithJSONObject(responseData);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }).start();
    }

    private void parseJSONWithJSONObject(String jsonData) {
        try {
            //由于我们在服务器中定义的是一个 JSON 数组，首先是将服务器返回的数组传入到一个 JSONObject 对象，每个 JSONObject 对象又会包含 id 、name 和 version 这些数据
            JSONArray jsonArray = new JSONArray(jsonData);
            for (int i = 0; i < jsonArray.length(); i++) {
                JSONObject jsonObject =jsonArray.getJSONObject(i);
                //调用 getString() 方法将这些数据取出并打印
                String id = jsonObject.getString("id");
                String name = jsonObject.getString("name");
                String version = jsonObject.getString("version");
                Log.d("MainActivity", "id is " + id);
                Log.d("MainActivity", "name is " + name);
                Log.d("MainActivity", "version is " + version);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

	...

}
```





#### 使用 GSON

除了 JSONObject ，使用谷歌提供的 GSON 开源库同样可以解析 JSON 数据，不过 GSON 没有加入到 Android 官方的 API，因此想要使用这个功能的话，就必须在项目中添加 GSON 库的依赖，编辑 app/build.gradle

```java
implementation 'com.google.code.gson:gson:2.7'
```

GSON 主要是可以将一段 JSON 格式的字符串自动映射成一个对象，从而不需要我们再手动去编写代码进行解析

比如一段 JSON 格式的数据：

```json
{"name":"Tom","age":20}
```

我们可以定义一个 Person 类，并加入 name 和 age 这两个字段，然后只需要简单地调用如下代码就可以将 JSON 数据自动解析成一个 Person 对象：

```java
Gson gson = new Gson();
Person person = gson.fromJson(jsonData, Person.class);
```

如果解析一段 JSON 数组，我们需要借助 TypeToken 将期望解析成的数据类型传入到 fromJson() 方法中

```java
List<Person> people = gson.fromJson(jsonData, new TypeToken<List<Person>>() {}.getType());
```

新增一个 App 类

```java
public class App {
    
    private String id;
    
    private String name;
    
    private String version;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getVersion() {
        return version;
    }

    public void setVersion(String version) {
        this.version = version;
    }
    
}
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener {

	...

	private void sendRequestWithOkHttp() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    OkHttpClient client = new OkHttpClient();
                    Request request = new Request.Builder()
                            //指定访问的服务器地址是电脑本机
                            .url("http://10.0.2.2/get_data.json")
                            .build();
                    Response response = client.newCall(request).execute();
                    String responseData = response.body().string();
                    parseJSONWithJSON(responseData);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }).start();
    }

    private void parseJSONWithJSON(String jsonData) {
        Gson gson = new Gson();
        List<App> appList = gson.fromJson(jsonData, new TypeToken<List<App>>(){}.getType());
        for (App app : appList) {
            Log.d("MainActivity", "id is " + app.getId());
            Log.d("MainActivity", "name is " + app.getName());
            Log.d("MainActivity", "version is " + app.getVersion());
        }
    }
	
	...

}
```



### 网络编程的最佳实践

通常情况下我们都应该将这些通用的网络操作提取到一个公共的类里，并提供一个静态方法，当想要发起网络请求的时候，只需要简单地调用这个方法，例如：

```java
public class HttpUtil {

    public static String sendHttpRequest(String address) {
        HttpURLConnection connection = null;
        try {
            URL url = new URL(address);
            connection = (HttpURLConnection) url.openConnection();
            connection.setRequestMethod("GET");
            connection.setConnectTimeout(8000);
            connection.setReadTimeout(8000);
            connection.setDoInput(true);
            connection.setDoOutput(true);
            InputStream in = connection.getInputStream();
            BufferedReader reader = new BufferedReader(new InputStreamReader(in));
            StringBuilder response = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                response.append(line);
            }
            return response.toString();
        } catch (Exception e) {
            e.printStackTrace();
            return e.getMessage();
        } finally {
            if (connection != null) {
                connection.disconnect();
            }
        }
    }

}
```

以后每当需要发起一条 HTTP 请求时，就可以：

```java
String address = "http://www.baidu.com";
String response = HttpUtil.sendHttpRequest(address);
```

在获取到服务器响应的数据之后，我们就可以对它进行解析处理了。网络请求通常都是属于耗时操作，而 sendHttpRequest() 方法的内部并没有开启线程，这样就有可能导致在调用 sendHttpRequest() 方法的时候使得主线程被阻塞住。

但是如果在 sendHttpRequest() 方法中开启一个线程来发起 HTTP 请求，那么服务器响应的数据是无法返回的，所有的耗时逻辑都在子线程里进行的，sendHttpRequest() 方法会在服务器还没来得及响应的时候就执行结束了，当然也就无法返回响应的数据了。

解决的方法只需要使用 Java 的回调机制就可以了

首先定义一个接口

```java
//在接口中定义两个方法
public interface HttpCallbackListener {
    
    //onFinish() 方法表示当服务器成功响应我们请求的时候调用，参数代表着服务器返回的数据
    void onFinish(String response);
    
    //onError() 方法表示当进行网络操作出错的时候调用，参数记录着错误的详细信息
    void onError(Exception e);
    
}
```

修改 HttpUtil

```java
public class HttpUtil {

    //首先给 sendHttpRequest() 方法添加了一个 HttpCallbackListener 参数
    public static String sendHttpRequest(final String address, final HttpCallbackListener listener) {
        //在方法的内部开启一个子线程，然后在子线程里去执行具体的网络操作
        new Thread(new Runnable() {
            @Override
            public void run() {
                HttpURLConnection connection = null;
                try {
                    URL url = new URL(address);
                    connection = (HttpURLConnection) url.openConnection();
                    connection.setRequestMethod("GET");
                    connection.setConnectTimeout(8000);
                    connection.setReadTimeout(8000);
                    connection.setDoInput(true);
                    connection.setDoOutput(true);
                    InputStream in = connection.getInputStream();
                    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
                    StringBuilder response = new StringBuilder();
                    String line;
                    while ((line = reader.readLine()) != null) {
                        response.append(line);
                    }
                    //子线程中是无法通过 return 语句来返回数据的，因此我们将服务器响应的数据传入了 HttpCallbackListener 的 onFinish() 方法中
                    if (listener != null) {
                        //回调 onFinish() 方法
                        listener.onFinish(response.toString());
                    }
                } catch (Exception e) {
                    //如果出现了异常，就将异常原因传入到 onError() 方法中
                    if (listener != null) {
                        //回调 onError() 方法
                        listener.onError(e);
                    }
                } finally {
                    if (connection != null) {
                        connection.disconnect();
                    }
                }
            }
        }).start();
    }

}
```

sendHTTPRequest() 方法接收了两个参数，我们在调用它的时候还需要将 HttpCallbackListener 的实例传入

```java
HttpUtil.sendHttpRequest(address, new HttpCallbackListener() {
    @Override
    public void onFinish(String response) {
        //在这里根据返回内容执行具体的逻辑
    }
    
    @Override
    public void onErrror(Exception e) {
        //在这里对异常情况进行处理
    }
});
```

上述使用 HttpURLConnection 的写法总体来说还是比较复杂的，使用 OkHttp 方法会变得简单，在 HttpUtil 中加入一个 sendOkHttpRequest() 方法

```java
public class HttpUtil {
    
    ...
    
    //在 sendOkHttpRequest() 方法中有一个 okhttp3.Callback 参数，这个是 OkHttp 库中自带的一个回调接口，类似于我们刚才自己编写的 HttpCallbackListener
    public static void sendOkHttpRequest(String address, okhttp3.Callback callback) {
        OkHttpClient client = new OkHttpClient();
        Request request = new Request().Builder
                .url(address)
                .build();
        //在 client.newCall() 方法之后没有像之前一样一直调用 execute() 方法，而是调用了一个 enqueue() 方法，并把 okhttp3.Callback 参数传入。
        //OkHttp 在 enqueue() 方法内部已经帮我们写好了子线程了， 然后会在子线程中去执行 HTTP 请求，并将最终的请求结果回调到 okhttp3.Callback 当中
        client.newCall(request).enqueue(callback);
    }

}
```

在调用 sendOkHttpRequest() 方法的时候就可以这样写：

```java
HttpUtil.sendHttpRequest("http://www.baidu.com", new okhttp3.Callback(){
    
    @Override
    public void onResponse(Call call, Response reponse) throws IOException {
        //得到服务器返回的具体内容
        String responseData = response.body().string(); 
    }
    
    @Override
    public void onFailure(Call call, IOException e) {
        //在这里对异常情况进行处理
    }
    
});
```

注意，不管是使用 HttpURLConnection 还是 OkHttp ，最终的回调接口都还是在子线程中运行的，因此我们不可以在这里执行任何的 UI 操作，除非借助 runOnUIThread() 方法来进行线程转换





## Android 多线程编程

当我们需要执行一些耗时操作的时候，需要将这类操作放在子线程里去运行，不然会导致主线程被阻塞住，从而影响用户的正常使用



### 线程的基本用法

定义一个线程只需要新建一个类继承自 Thread，然后重写父类的 run() 方法，并在里面编写耗时逻辑即可

```java
class MyThread extends Thread {
    @Override
    public void run() {
        //处理具体的逻辑
    }
}
```

启动这个线程只需要 new 出 MyThread 的实例，然后调用它的 start() 方法，这样 run() 方法中的代码就会在子线程当中运行

```java
new  MyThread().start();
```

使用继承的方式耦合性有点高，更多的时候我们都会选择使用实现 Runnable 接口的方式来定义一个线程

```java
class MyThread implements Runnable {
    @Override
    public void run() {
        //处理具体的逻辑
    }
}
```

如果使用了上面这种写法，启动线程的方法也需要进行相应的改变：

```java
MyThread myThread = new MyThread();
//Thread 的构造函数接收一个 Runnable 参数，而我们 new 出来的 MyThread 正是一个是实现了 Runnable 接口的对象，所以可以直接将它传入到 Thread 的构造函数里，接着调用 Trhead 的 start() 方法，run() 方法中的代码就会在子线程当中运行
new Thread(myThread).start();
```

如果不想专门定义一个类去实现 Runnable 接口，也可以使用匿名类的方式，这种写法更为常见

```java
new Thread(new Runnable() {
    @Override
    public void run() {
        //处理具体的逻辑
    }
});
```



### 在子线程中更新 UI

和许多其它的 GUI 库一样，Android 的 UI 也是线程不安全的，如果想要更新应用程序里的元素，则必须在主线程中进行，否则就会出现异常

新建 AndroidThreadTest 项目，修改 activity_main.xml

```java
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

	//当点击 Button 后可以把 TextView 中显示的字符串改成 Nice to meet you
    <Button
        android:id="@+id/change_text"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Change Text" />
    
    //在屏幕正中央显示一个 Hello world 字符串
    <TextView
        android:id="@+id/text"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_centerInParent="true"
        android:text="Hello world"
        android:textSize="20sp" />

</RelativeLayout>
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener{
    
    private TextView text;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        text = findViewById(R.id.text);
        Button changeText = findViewById(R.id.change_text);
        changeText.setOnClickListener(this);
    }
    
    //在 Change Text 按钮的点击事件里面开启了一个线程
    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.change_text:
                new Thread(new Runnable() {
                    @Override
                    public void run() {
                        //在子线程中调用了 TextView 的 setText() 方法将显示的字符串改成 Nice to meet you
                        text.setText("Nice to meet you");
                    }
                }).start();
                break;
            default:
                break;
        }
    }
    
}
```

当点击按钮之后会发现程序已经崩溃了，观察 logcat 日志，这是由于在子线程中更新了 UI 所导致的

```java
android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.
```

由此证实 Android 确实是不允许在子线程中进行 UI 操作的

解决方法是异步消息处理，修改 MainActivity

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener{

    //先是定义一个整型常量 UPDATE_TEXT 用于表示更新 TextView 这个动作
    public static final int UPDATE_TEXT = 1;

    private TextView text;

    //新增一个 Handler 对象，并重写父类的 handleMessage() 方法，在这里对具体的 Message 进行处理
    private Handler handler = new Handler() {

        public void handleMessage(Message msg) {
            //如果发现 Message 的 what 字段的值等于 UPDATE_TEXT，就将 TextView 显示的内容改成 Nice to meet you
            switch (msg.what) {
                case UPDATE_TEXT:
                    //在这里可以进行 UI 操作
                    text.setText("Nice to meet you");
                    break;
                default:
                    break;
            }
        }

    };

	...

    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.change_text:
                new Thread(new Runnable() {
                    @Override
                    public void run() {
                        //创建了一个 Message(android.os.Message) 对象，并将它的 what 字段的值指定为 UPDATE_TEXT，然后调用 Handle 的 sendMessage() 方法将这条 Message 方法发送出去
                        Message message = new Message();
                        message.what = UPDATE_TEXT;
                        handler.sendMessage(message);//将 Message 对象发送出去
                        //此时 handleMessage() 方法中的代码就是在主线程当中运行的了
                    }
                }).start();
                break;
            default:
                break;
        }
    }

}
```



### 解析异步消息处理机制

Android 中的异步消息处理主要是由 4 个部分组成：Message 、Handler 、MessageQueue 和 Looper

1. Message

Message 是在线程之间传递的消息，它可以在内部携带少量的信息，用于不同线程之间交换数据。上一小节中我们使用到 了 Message 的 what 字段，除此之外还可以使用 arg1 和 arg2 字段来携带一些整型数据，使用 obj 字段携带一个 Object 对象。

2. Handler

Handler 顾名思义也就是处理者的意思，它主要适用于发送和处理消息的。发送消息一般是使用 Handler 的 sendMessage() 方法，而发出的消息经过一系列地辗转处理后，最终会传递到 Handle 的 handleMessage()  方法中。

3. MessageQueue

MessageQueue 是消息队列的意思，它主要用于存放所有通过 Handler 发送的消息。这部分消息会一直存在于消息队列中，等待被处理。每个线程中只会有一个 MessageQueue 对象。

4. Looper

Looper 是每个线程中的 MessageQueue 的管家，调用 Looper 的 loop() 方法后，就会进入到一个无限循环当中，然后每当发现 MessageQueue 中存在一条消息，就会将它取出，并传递到 Handler 的 handleMessage() 方法中。每个线程中也只有一个 Looper 对象。



异步消息的流程：

首先需要在主线程当中创建一个 Handler 对象，并重写 handleMessage() 方法。然后当子线程中需要进行 UI 操作时，就创建一个 Message 对象，并通过 Handler 将这条消息发送出去。之后这条消息就会被添加到 MessageQueue 的队列中等待被处理，而 Looper 则会一直尝试从 MessageQueue 中取出待处理消息，最后分发回 Handler 的 hanleMessage() 方法中。由于 Handler 是在主线程中创建的，所以此时 handleMessage() 方法中的代码也会在主线程中运行，于是我们在这里就可以安心地进行 UI 操作了。

一条 Message 经过这样一个流程的辗转调用后，也就从子线程进入到了主线程，从不能更新 UI 变成了可以更新 UI，整个异步消息处理的核心思想也就是如此，而我们第九章使用的 runOnUIThread() 其实就是一个异步消息处理机制的接口封装，他虽然表面看起来用法更加简单，其实原理也是如此。



### 使用 AsyncTask

为了更加方便我们在子线程中对 UI 进行操作，Android 还提供了另外一些好用的工具，比如 AsyncTask，它的原理也是基于异步消息处理的机制，只是 Android 帮我们做了很好的封装而已。

AsyncTask 是一个抽象类，我们想使用它，就必须创建一个子类去继承它，在继承时我们可以为 AsyncTask 类指定 3 个泛型参数，基本用法：

- Params：在执行 AsyncTask 时需要传入的参数，可用于在后台任务中使用
- Progress：后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为进度单位
- Result：当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型

因此一个最简单的自定义 AsyncTask 可以写成如下方式：

```java
//第一个泛型参数指定为 Void 表示在执行 AsyncTask 的时候不需要传入参数给后台参数
//第二个泛型参数指定为 Integer 表示使用整数来作为进度显示单位
//第三个泛型参数指定为 Boolean 表示使用布尔型数据来反馈执行结果
class DownloadTTask extends AsyncTask<Void, Integer, Boolean>{
    ...
}
```

现在自定义的 DownloadTask 还是一个空任务，经常需要重写以下 4 个方法才能完成对任务的定制

1. onPreExecute()

这个方法会在后台任务开始执行之前调用，用于进行一些界面上的初始化操作，比如显示一条进度条对话框等

2. doInBackground(Params...)

这个方法中的所有代码都会在子线程中运行，我们应该在这里去处理所有的耗时任务。任务一旦完成就可以通过 return 语句来将任务的执行结果返回，如果 AsyncTask 的第三个泛型参数指定的是 Void，就不返回任务执行结果。注意，在这个方法中是不可以进行 UI 操作的，如果需要更新 UI 元素，比如说反馈当前任务的执行进度，可以调用 publishProgress(Progress...) 方法来完成

3. onProgressUpdate(Progress...)

当后台任务中调用了 publishProgress(Progress...) 方法后，onProgressUpdate(Progress...) 方法就会很快被调用，该方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对 UI 进行操作，利用参数中的数值就可以对界面元素进行相应的更新

4. onPostExecute(Result)

当后台任务执行完毕并通过 return 语句进行返回时，这个方法就很快会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据来进行一些 UI 操作，比如说提醒任务执行的结果，以及关闭掉进度条对话框等



因此一个比较完整的自定义 AsyncTask 就可以写成如下方式：

```java
public class DownloadTask extends AsyncTask<Void, Integer, Boolean> {
    
    //这个方法会在后台任务开始执行之前调用，用于进行一些界面上的初始化操作，比如显示一条进度条对话框等
    @Override
    protected void onPreExecute() {
        progressDialog.show();//显示进度对话框
    }
    
    //这个方法中的所有代码都会在子线程中运行，我们应该在这里去处理所有的耗时任务。任务一旦完成就可以通过 return 语句来将任务的执行结果返回，如果 AsyncTask 的第三个泛型参数指定的是 Void，就不返回任务执行结果。注意，在这个方法中是不可以进行 UI 操作的，如果需要更新 UI 元素，比如说反馈当前任务的执行进度，可以调用 publishProgress(Progress...) 方法来完成
    //在 doInBackground() 方法里去执行具体的耗时下载任务，使之不会影响主线程的运行
    @Override
    protected Boolean doInBackground(Void...params) {
        try {
            while (true) {
                int downloadPercent = doDownload();//这是一个虚构的方法
                //由于在这里不能进行 UI 操作，就将返回的下载进度传进 publishProgress()，这样 onProgressUpdate() 方法就很快会被调用，在这里就可以进行 UI 操作了
                publishProgress(downloadPercent);
                if (downloadPercent >= 100) {
                    break;
                }
            }
        } catch (Exception e) {
            return false;
        }
        return true;
    }
    
    //当后台任务中调用了 publishProgress(Progress...) 方法后，onProgressUpdate(Progress...) 方法就会很快被调用，该方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对 UI 进行操作，利用参数中的数值就可以对界面元素进行相应的更新
    @Override
    protected void onProgressUpdate(Integer...values) {
        //在这里更新下载速度
        progressDialog.setMessage("Downloaded " + values[0] + "%");
    }
    
    //当后台任务执行完毕并通过 return 语句进行返回时，这个方法就很快会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据来进行一些 UI 操作，比如说题型任务执行的结果，以及关闭掉进度条对话框等
    //当下载完成之后 doInBackground() 返回一个布尔型变量，这样 onPostExecute() 方法就会很快被调用，这个方法也是在主线程中运行的，然后我们根据下载的结果来弹出相应的 Toast 提示，从而完成整个 DownloadTask 任务
    @Override
    protected void onPostExecute(Boolean result) {
        progressDialog.dismiss();//关闭进度对话框
        //在这里提示下载结果
        if (result) {
            Toast.makeText(context, "Download successed", Toast.LENGTH_SHORT).show();
        } else {
            Toast.makeText(context, "Download failed", Toast.LENGTH_SHORT).show();
        }
    }
    
}
```

简单来说，使用 AsyncTask 就是在 doInBackground() 方法中去执行具体的耗时任务，在 onProgressUpdate() 方法中进行 UI 操作，在 onPostExecute() 方法中执行一些任务的收尾工作

如果想要启动这个任务，只需要编写：

```java
new DownloadTask().execute();
```



## Server

服务（Server）是 Android 中实现程序后台运行的解决方案，它非常适合去执行那些不需要和用户交互而且还需要长期运行的任务。服务的运行不依赖任何用户界面，即使程序被切换到后台，或者用户打开了另外一个应用程序，服务仍然能够保持正常运行。

不过需要注意的是，服务并不是运行在一个独立的进程当中，而是依赖于常见服务时所在的应用程序进程。当某个应用程序进程被杀掉时，所有依赖于进程的服务也会停止运行。

另外，也不要被服务的后台概念所迷惑，实际上服务并不会自动开启线程，所有的代码都是默认运行在主线程当中的。也就是说，我们需要在服务的内部手动创建子线程，并在这里执行具体的任务，否则就有可能出现主线程被阻塞的情况。



### 定义一个服务

新建一个 ServiceTest 项目，然后右击 com.example.servicetest -> New -> Service -> Service，我们将服务命名为 MyService，Exported 属性表示是否允许出了当前程序之外的其他程序访问这个服务，Enabled 属性表示是否启用这个服务，两个属性都勾选

观察 MyService

```java
//MyService 继承自 Service 类，说明这是一个服务
public class MyService extends Service {
    public MyService() {
    }

    //onBind() 这个方法是 Service 中唯一的一个抽象方法，所以必须在子类里实现它，目前暂时忽略
    @Override
    public IBinder onBind(Intent intent) {
        throw new UnsupportedOperationException("Not yet implemented");
    }
}
```

重写 Service 中的另外一些方法：

```java
public class MyService extends Service {
    public MyService() {
    }

    @Override
    public IBinder onBind(Intent intent) {
        // TODO: Return the communication channel to the service.
        throw new UnsupportedOperationException("Not yet implemented");
    }
    
    //onCreate() 方法会在服务创建的时候调用
    public void onCreate() {
        super.onCreate();
    }
    
    //onStartCommand() 方法会在每次服务启动的时候调用。如果希望服务一旦启动就立刻去执行某个动作，就可以将逻辑写在此方法里
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        return super.onStartCommand(intent, flags, startId);
    }
    
    //onDestroy() 方法会在服务销毁的时候调用。当服务销毁时，我们应该在此方法中回收那些不再使用的资源
    @Override
    public void onDestroy() {
        super.onDestroy();
    }
    
}
```

注意，每一个服务都需要在 AndroidManifest.xml 文件中注册才能生效，这是 Android 四大组件的共有特点

Android Studio 已经帮我们将这一步完成

```java
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.servicetest">

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        <service
            android:name=".MyService"
            android:enabled="true"
            android:exported="true">
        </service>
	    ...
    </application>

</manifest>
```

这样，一个服务就定义好了



### 启动和停止服务

定义好一个服务之后，接下来就应该考虑如何去启动以及停止这个服务。启动和停止的方法主要是借助 Intent 来实现的

修改 activity_main.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <Button
        android:id="@+id/start_service"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Start Service" />
    
    <Button
        android:id="@+id/stop_service"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Stop Service" />

</LinearLayout>
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener{

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        //在 onCreate() 方法中分别获取到了 Start Service 按钮和 Stop Service 按钮的实例，并给它们注册点击事件
        Button startService = findViewById(R.id.start_service);
        Button stopService = findViewById(R.id.stop_service);
        startService.setOnClickListener(this);
        stopService.setOnClickListener(this);
    }

    @Override
    public void onClick(View v) {
        switch (v.getId()) {
           //在 Start Service 按钮的点击事件里，我们构建出一个 Intent 对象，并调用 startService() 方法来启动 MyService 这个服务
            case R.id.start_service:
                Intent startIntent = new Intent(this, MyService.class);
                startService(startIntent);//启动服务
                break;
            //在 Stop Service 按钮的点击事件里，我们同样构建一个 Intent 对象，并调用 stopService() 方法来停止 MyService 这个服务
            case R.id.stop_service:
                Intent stopIntent = new Intent(this, MyService.class);
                stopService(stopIntent);//停止服务
            default:
                break;
        }
    }
    
}
```

startService() 和 stopService() 方法都是定义在 Context 类中的，所以我们可以直接调用这两个方法

注意，这里完全是由活动来决定服务何时停止的，如果没有点击 Stop Service 按钮，服务就会一直处于运行状态，除此之外，只需要在 MyService 的任何一个位置调用 stopSelf() 方法就能让这个服务自己停止下来

修改 MyService

```java
public class MyService extends Service {
    
    private static final String TAG = "MyService";

    public MyService() {
    }

    @Override
    public IBinder onBind(Intent intent) {
        throw new UnsupportedOperationException("Not yet implemented");
    }

    public void onCreate() {
        super.onCreate();
        Log.d(TAG, "onCreate executed");
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        Log.d(TAG, "onStartCommand executed");
        return super.onStartCommand(intent, flags, startId);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        Log.d(TAG, "onDestroy executed");
    }

}
```

观察 logcat 中的打印日志，也可以在设置中查找到服务确实已经启动了

onCreate() 方法是在服务第一次创建的时候调用，而 onStartCommand() 方法则是在每次启动服务的时候调用，由于刚才第一次点击 Start Service 按钮，服务此时还未创建过，所以两个方法都会执行，之后如果多次点击 Stat Service 按钮，你会发现只有 onStartCommand()方法可以得到执行



### 活动和服务进行通信

在启动了服务之后，活动与服务基本就没有什么关系了，之后服务会一直处于运行状态，但具体运行的是什么逻辑，活动就控制不了了。这就类似于活动通知了服务一下“你可以启动了！”，然后服务就去忙自己的事情了，但活动并不知道服务到底去做了什么事情，以及完成得如何

让活动和服务的关系更紧密一些，例如在活动中指挥服务去干什么服务就去干什么，这就需要借助刚刚忽略的 onBind() 方法

比如我们希望在 MyService 里提供一个下载功能，然后在活动中可以决定时间何时开始下载以及随时查看下载进度。实现这个功能的思路是创建一个专门的 Binder 对象来对下载功能进行管理。修改 MyService

```java
public class MyService extends Service {

    private static final String TAG = "MyService";
    
    //在 MyService 中创建 DownloadBinder 实例
    private DownloadBinder mBinder = new DownloadBinder();

    //新建一个 DownloadBinder 类，并让它继承自 Binder，然后在它的内部提供了开始下载以及查看下载进度的方法
    class DownloadBinder extends Binder {
        
        public void startDownload() {
            Log.d(TAG, "startDownload executed");
        }
        
        public int getProgress() {
            Log.d(TAG, "getProgress executed");
            return 0;
        }
        
    }

    //在 onBind() 方法里返回这个 DownloadBinder 实例
    @Override
    public IBinder onBind(Intent intent) {
        return mBinder;
    }

    ...

}
```

修改 activity_main.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <Button
        android:id="@+id/start_service"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Start Service" />

    <Button
        android:id="@+id/stop_service"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Stop Service" />

    //用于绑定服务
    <Button
        android:id="@+id/bind_service"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Bind Service" />
    
    //用于取消绑定服务
    <Button
        android:id="@+id/unbind_service"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Unbind Service" />

</LinearLayout>
```

当一个活动和服务绑定之后，就可以调用服务里的 Binder 提供的方法。修改 MainActivity

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener{

    private MyService.DownloadBinder downloadBinder;

    //创建一个 ServiceConnection 的匿名类，并重写了 onServiceConnected() 和 onServiceDisconnected() 
    private ServiceConnection connection = new ServiceConnection() {
        //在活动和服务成功绑定的时候调用
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            //通过向下转型得到 DownloadBinder 的实例，现在我们可以在活动中根据具体的场景来调用 DownloadBinder 中的任何 public 方法，即实现了只会服务干什么服务就去干什么的功能。这里只是做了个简单的测试，在 onServiceConnected() 方法中调用了 DownloadBinder 的 startDownload() 和 getProgress() 方法
            downloadBinder = (MyService.DownloadBinder) service;
            downloadBinder.startDownload();
            downloadBinder.getProgress();
        }

        //在活动和服务连接断开的时候调用
        @Override
        public void onServiceDisconnected(ComponentName name) {

        }
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button startService = findViewById(R.id.start_service);
        Button stopService = findViewById(R.id.stop_service);
        startService.setOnClickListener(this);
        stopService.setOnClickListener(this);
        Button bindService = findViewById(R.id.bind_service);
        Button unbindService = findViewById(R.id.unbind_service);
        bindService.setOnClickListener(this);
        unbindService.setOnClickListener(this);
    }

    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.start_service:
                Intent startIntent = new Intent(this, MyService.class);
                startService(startIntent);//启动服务
                break;
            case R.id.stop_service:
                Intent stopIntent = new Intent(this, MyService.class);
                stopService(stopIntent);//停止服务
            //当前活动和服务还没进行绑定，这个功能是在 Bind Service 按钮的点击事件里完成的
            case R.id.bind_service:
                //构建出一个 Intent 对象，然后调用 bindService() 方法将 MainActivity 和 MyService 进行绑定
                Intent bindIntent = new Intent(this, MyService.class);
                // bindService() 方法接收三个参数，第一个参数是 Intent，第二个参数是 ServiceConnevtion 的实例，第三个参数则是一个标志位，这里传入 BIND_AUTO_CREATE 表示在活动和服务进行绑定后自动创建服务。这里会使得 MyService 中的 onCreate() 方法得到执行，但 onStartCommand() 方法不会执行
                bindService(bindIntent, connection, BIND_AUTO_CREATE);//绑定服务
                break;
            case R.id.unbind_service:
                //调用 unbindService() 解除活动和服务之间的绑定
                unbindService(connection);//解绑服务
                break;
            default:
                break;
        }
    }

}
```

点击一下 Bind Service 按钮首先执行 MyService 的 onCreate() 方法，然后 startDownload() 和 getProgress() 方法都得到了执行，说明我们确实已经成功地调用了服务里提供的方法

另外需要注意的是，任何一个服务在整个应用程序范围内都是通用的，即 MyService 不仅可以和 MainActivity 绑定，还可以和任何一个其他的活动进行绑定，而且在绑定完成后他们都可以获取到相同的 DownloadBinder 实例



### 服务的生命周期

我们前面使用到的 onCreate() 、onStartCommand() 、onBind() 和 onDestroy() 等方法都是在服务的生命周期内可能回调的方法

一旦在项目的任何位置调用了 Context 的 startService() 方法，相应的服务就会启动起来，并回调 onStartCommand() 方法。如果这个服务之前还没有创建过，onCreate() 方法会优先于 onStartCommand() 方法执行。服务启动了之后会一直保持运行状态，直到 stopService() 或 stopSelf() 方法被调用。注意，虽然每调用一次 startService() 方法，onStartCommand() 就会执行一次，但实际上每个服务都只会存在一个实例，所以不管你调用了多少次 startService() 方法，只需调用一次 stopService() 或 stopSelf() 方法，服务就会停止下来。

另外，还可以调用 Context 的 bindService() 来获取一个服务的持久连接，这时就会回调服务中的 onBind() 方法执行。之后，调用方可以获取到 onBind() 方法里返回的 IBinder 对象的实例，这样就能自由地和服务进行通信了，只要调用方和服务之间的连接没有断开，服务就会一直保持运行状态

当调用了 startService() 方法后，又去调用了 stopService() 方法，这是服务中的 onDestroy() 方法就会执行，表示服务已经销毁了。类似地，当调用了 bindService() 方法后，又去调用 unbindService() 方法，onDestory()  方法也会执行，这两种情况都是很好理解的。但是当我们对一个服务及调用了 startService() 方法，又调用了 bindService() 方法的，这种情况下该如何才能让服务销毁掉呢？根据 Android 的机制，一个服务只要被启动或者绑定了之后，就会一直处于运行状态，必须要让以上两种条件同时满足，服务才能被销毁。所以，这种情况下要同时调用 stopService() 和 unbindService() 方法，onDestroy() 方法才会执行



### 使用前台服务

服务的系统优先级还是比较低的，当系统出现内存不足的情况时，就有可能会回收掉正在后台运行的服务。如果你希望服务可以一直保持运行状态，而不会由于系统内存不足的原因导致被回收，就可以考虑使用前台服务。前台服务和普通服务的最大区别在于，它会一直有一个正在运行的图标在系统的状态栏显示，下来状态栏后可以看到更加详细的信息，非常类似于通知的效果。

修改 MyService

```java
public class MyService extends Service {

	...

    public void onCreate() {
        super.onCreate();
        Log.d(TAG, "onCreate executed");
        Intent intent = new Intent(this, MainActivity.class);
        PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0);
        //构建出 Notification 对象后并没有使用 NotificationManager 来讲通知显示出来，而是调用了 startForeground() 方法
        Notification notification = new Notification.Builder(this)
                .setContentTitle("This is content title")
                .setContentText("This is content text")
                .setWhen(System.currentTimeMillis())
                .setSmallIcon(R.mipmap.ic_launcher)
                .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher))
                .setContentIntent(pi)
                .build();
        // startForeground() 方法接收两个参数，第一个参数是通知的 id，类似于 notify() 方法的第一个参数，第二个参数则是构建出的 Notification 对象，调用 startForeground() 方法后就会让 MyService 变成一个服务前台，并在系统状态栏显示出来
        startForeground(1, notification);
    }
	
    ...

}
```



### 使用 IntentService

服务中的代码都是默认运行在主线程当中的，如果直接在服务里去处理一些耗时的逻辑，就很容易出现 ANR (Application Not Responding) 的情况，这个时候就需要用到了 Android 多线程的技术，我们应该在服务的每个具体地方法里开启一个子线程，然后在这里去处理一个那些耗时的逻辑，一个标准的服务的写法如下：

```java
public class MyService extends Service {
    ...
    @Ovrride
    public int onStartCommand(Intent intent, int flags, int startId) {
        new Thread(new Runable() {
            @Override
            public void run() {
                //处理具体的逻辑
            }
        }).start();
     	return super.onStartCommand(intent, flags, startId);
    }
}
```

但是这种方法一旦启动之后就会一直处于运行状态，必须调用 stopService() 或者 stopSelf() 方法才能让服务停止下来

```java
public class MyService extends Service {
    ...
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        new Thread(new Runnable() {
            @Overrider
            public void run() {
                //处理具体逻辑
                stopSelf();
            }
        }).start();
        return super.onStartCommand(intent, flags, startId);
    }
}
```

这种写法并不复杂，但是总会有可能忘记开启线程，或者忘记调用 stopSelf() 方法。为了可以简单地创建一个异步的、会自动停止的服务，Android 专门提供了一个 IntentService 类

新建一个 MyIntentService 继承自 IntentService

```java
public class MyIntentService extends IntentService {

    private static final String TAG = "MyIntentService";
    
    //首先提供一个无参的构造函数，并且必须在其内部调用父类的有参构造函数
    public MyIntentService() {
        super("MyIntentService");//调用父类的有参构造函数
    }
    
    //在子类实现 onHandleIntent() 这个抽象方法，在这个方法中可以去处理一些具体的逻辑，而不用担心 ANR 问题，因为这个方法已经是在子线程中运行的了
    @Override
    protected void onHandleIntent(Intent intent) {
        //打印当前线程的 id，为确定开启了子线程
        Log.d(TAG, "Thread id is " + Thread.currentThread().getId());
    }
    
    @Override
    public void onDestroy() {
        super.onDestroy();
        //打印一行日志来确定服务是不是停止掉了
        Log.d(TAG, "onDestroy executed");
    }
    
}
```

修改 activity_main.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

	...

    <Button
        android:id="@+id/start_intent_service"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Start IntentService" />

</LinearLayout>
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener{

    ...

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        ...
        Button startIntentService = findViewById(R.id.start_intent_service);
        startIntentService.setOnClickListener(this);
    }

    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            ...
            case R.id.start_intent_service:
                //打印主线程的 id，用于于子线程的 id 作比较
                Log.d("MainActivity", "Thread id is " + Thread.currentThread().getId());
                Intent intentService = new Intent(this, MyIntentService.class);
                startService(intentService);
                break;
            default:
                break;
        }
    }

}
```

注意记得在 AndroidManifest.xml 里注册 Service

```java
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.servicetest">

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        
        <service android:name=".MyIntentService"/>
        
        ...

</manifest>
```



### 服务的最佳实践

下面综合运用一下服务来尝试实现下载功能，创建一个 ServiceBestPractice 项目，编辑 app/build.gradle，在 dependencies 闭包中添加 OkHttp 的依赖：

```java
implementation 'com.squareup.okhttp3:okhttp:3.4.1'
```

定义一个回调接口，用于对下载过程中的各种状态进行监听和回调。新建一个 DownloadListener 接口

```java
public interface DownloadListener {
    
    //用于通知当前的下载进度
    void onProgress(int progress);
    
    //用于通知下载成功事件
    void onSuccess();
    
    //用于通知下载失败事件
    void onFailed();
    
    //用于通知下载暂停事件
    void onPaused();
    
    //用于通知下载取消事件
    void onCanceled();
    
}
```

编写下载功能，新建一个 DownloadTask 继承自 AsyncTask

```java
//AsyncTask 中接收三个泛型参数，第一个泛型参数指定为 String，表示在执行 AsyncTask 的时候需要传入一个字符串参数给后台任务；第二个泛型参数指定为 Integer，表示使用整型数据来作为进度显示单位；第三个泛型参数指定为 Integer，则表示使用整型数据来反馈执行结果
public class DownloadTask extends AsyncTask<String, Integer, Integer> {

    //定义四个整型常量来表示下载的状态
    //下载成功
    public static final int TYPE_SUCCESS = 0;
    //下载失败
    public static final int TYPE_FAILED = 1;
    //暂停下载
    public static final int TYPE_PAUSED = 2;
    //取消下载
    public static final int TYPE_CANCELED = 3;

    private DownloadListener listener;

    private boolean isCanceled= false;

    private boolean isPaused = false;

    private int lastProgress;

    //在 DownloadTask 的构造函数中要求传入一个刚刚定义的 DownloadListener 参数，我们待会就会将下载的状态通过这个参数进行回调
    public DownloadTask(DownloadListener listener) {
        this.listener = listener;
    }

    //这个方法中的所有代码都会在子线程中运行，我们应该在这里去处理所有的耗时任务。任务一旦完成就可以通过 return 语句来将任务的执行结果返回，如果 AsyncTask 的第三个泛型参数指定的是 Void，就不返回任务执行结果。注意，在这个方法中是不可以进行 UI 操作的，如果需要更新 UI 元素，比如说反馈当前任务的执行进度，可以调用 publishProgress(Progress...) 方法来完成
    //doInBackground() 方法用于后台执行具体的下载逻辑
    @Override
    protected Integer doInBackground(String...params) {
        InputStream is = null;
        RandomAccessFile savedFile = null;
        File file = null;
        try {
            long downloadedLength = 0;//记录已下载的文件长度
            //首先从参数中获取到下载的 URL 地址
            String downloadUrl = params[0];
            //根据 URL 地址解析出了下载的文件名
            String fileName = downloadUrl.substring(downloadUrl.lastIndexOf("/"));
            //指定将文件下载到 Environment.DIRECTORY_DOWNLOADS 目录下，也就是 SD 卡的 Download 目录
            String directory = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getPath();
            file = new File(directory + fileName);
            //判断 Download 目录中是不是已经存在要下载的文件，如果已经存在的话则读取已下载的字节数，这样就可以在后面启用断点续传的功能
            if (file.exists()) {
                downloadedLength = file.length();
            }
            //调用 getContentLength() 方法来获取待下载文件的总长度
            long contentLength = getContentLength(downloadUrl);
            //如果文件长度等于 0 这说明文件有问题，直接返回 TYPE_FAILED。如果文件长度等于已下载的文件长度，那么就说明文件已经下载完了，直接返回 TYPE_SUCCESS
            if (contentLength == 0) {
                return TYPE_FAILED;
            } else if (contentLength == downloadedLength) {
                //已下载字节和文件总字节相等，说明已经下载完成了
                return TYPE_SUCCESS;
            }
            //使用 OkHttp 来发送一条网络请求，需要注意的是，这里在请求中添加了一个 header，用于告诉服务器我们想要从哪个字节开始下载，因为已下载过的部分就不需要再重新下载
            OkHttpClient client = new OkHttpClient();
            Request request = new Request.Builder()
                    //断点下载，指定从那个字节开始下载
                    .addHeader("RANGE", "bytes=" + downloadedLength + "-")
                    .url(downloadUrl)
                    .build();
            Response response = client.newCall(request).execute();
            if (response != null) {
                is = response.body().byteStream();
                savedFile = new RandomAccessFile(file, "rw");
                savedFile.seek(downloadedLength);//跳过已下载的字节
                byte[] b = new byte[1024];
                int total = 0;
                int len;
                //接下来读取服务器响应的数据，并使用 Java 的文件流方式，不断从网络上读取数据，不断写入到本地，一直到文件全部下载完成为止，这个过程中还要判断用户有没有触发暂停或者取消的操作，如果有的话则返回 TYPE_CANCELED 或 TYPE_PAUSED 来中断下载，如果没有的话则实时计算当前的下载速度，然后调用 publishProgress() 方法进行通知。
                while ((len = is.read(b)) != -1) {
                    if (isCanceled) {
                        return TYPE_CANCELED;
                    } else if (isPaused) {
                        return TYPE_PAUSED;
                    } else {
                        total += len;
                        savedFile.write(b, 0, len);
                        //计算已下载的百分比
                        int progress = (int) ((total + downloadedLength) * 100 / contentLength);
                        publishProgress(progress);
                    }
                }
                response.body().close();
                return TYPE_SUCCESS;
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                if (is != null) {
                    is.close();
                }
                if (savedFile != null) {
                    savedFile.close();
                }
                if (isCanceled && file != null) {
                    file.delete();
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return TYPE_FAILED;
    }
    
    private long getContentLength(String downloadUrl) throws IOException {
        OkHttpClient client = new OkHttpClient();
        Request request = new Request.Builder()
                .url(downloadUrl)
                .build();
        Response response = client.newCall(request).execute();
        if (response != null && response.isSuccessful()) {
            long contentLength = response.body().contentLength();
            response.body().close();
            return contentLength;
        }
        return 0;
    }
    
    //暂停个操作都是使用一个布尔型的变量来逆行控制的，调用 pauseDownload() 或 cancelDownload() 方法即可改变量的值
    public void pauseDownload() {
        isPaused = true;
    }    
    
    public void cancelDownload() {
        isCanceled = true;
    }
    
    //当后台任务中调用了 publishProgress(Progress...) 方法后，onProgressUpdate(Progress...) 方法就会很快被调用，该方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对 UI 进行操作，利用参数中的数值就可以对界面元素进行相应的更新
    //onProgressUpdate() 方法用于在界面更新当前的下载进度
    @Override
    protected void onProgressUpdate(Integer...values) {
        //首先从参数获取到当前的下载进度
        int progress = values[0];
        //和上一次的下载进度进行对比，如果有变化的话则调用 DownloadListener 的 onProgress() 方法来通知下载进度更新
        if (progress > lastProgress) {
            listener.onProgress(progress);
            lastProgress = progress;
        }
    }
    
    //当后台任务执行完毕并通过 return 语句进行返回时，这个方法就很快会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据来进行一些 UI 操作，比如说提醒任务执行的结果，以及关闭掉进度条对话框等
    //onPostExecute() 用于通知最终的下载结果
    @Override
    protected void onPostExecute(Integer status) {
        //根据参数中传入的下载状态来进行回调，下载成功就调用 DownloadListener 的 onSuccess() 方法，下载失败就调用 DownloadListener 的 onFailed() 方法，暂停下载就调用 onPaused() 方法，取消下载就调用 onCanceled() 方法
        switch (status) {
            case TYPE_SUCCESS:
                listener.onSuccess();
                break;
            case TYPE_FAILED:
                listener.onFailed();
                break;
            case TYPE_PAUSED:
                listener.onPaused();
                break;
            case TYPE_CANCELED:
                listener.onCanceled();
                break;
            default:
                break;
        }
    }
    
}
```

为了保证 DownloadTask 一直在后台运行，还需创建一个 下载的服务，右键新建一个 DownloadTask 的 Service

```java
public class DownloadService extends Service {

    private DownloadTask downloadTask;

    private String downloadUrl;

    //首先创建一个 DownloadListener 的匿名实例，并在匿名类中实现了 onProgress() 、onSuccess() 、onFailed() 、onCanceled() 和 onPaused() 五个方法
    private DownloadListener listener = new DownloadListener() {
        
        //在 onProgress() 方法中，我们调用 getNotification() 方法构建了一个用于显示下载进度的通知，然后调用 NotificationManager 的 notify() 方法去触发这个通知，这样就可以在下拉状态栏中实时看到当前下载的进度了
        @Override
        public void onProgress(int progress) {
            getNotificationManager().notify(1, getNotification("Downloading...", progress));
        }

        //在 onSuccess() 方法中，首先将正在下载的前台通知关闭，然后创建一个新的通知用于告诉用户下载成功了，其他几个方法也是类似
        @Override
        public void onSuccess() {
            downloadTask = null;
            //下载成功时将前台服务通知关闭，并创建一个下载成功的通知
            stopForeground(true);
            getNotificationManager().notify(1, getNotification("Download Success", -1));
            Toast.makeText(DownloadService.this, "Download Success", Toast.LENGTH_SHORT).show();
        }

        @Override
        public void onFailed() {
            downloadTask = null;
            //下载失败时将前台服务通知关闭，并创建一个下载失败的通知
            stopForeground(true);
            getNotificationManager().notify(1, getNotification("Download Failed", -1));
            Toast.makeText(DownloadService.this, "Download Failed", Toast.LENGTH_SHORT).show();
        }

        @Override
        public void onPaused() {
            downloadTask = null;
            Toast.makeText(DownloadService.this, "Paused", Toast.LENGTH_SHORT).show();
        }

        @Override
        public void onCanceled() {
            downloadTask = null;
            stopForeground(true);
            Toast.makeText(DownloadService.this, "Canceled", Toast.LENGTH_SHORT).show();
        }
    };

    //为了让 DownloadServer 和活动进行通信，创建 DownloadBinder，DownloadBinder 中提供了 startDownload() 、 pauseDownload() 和 cancelDownload() 三个方法分别用于开始下载，暂停下载和取消下载
    private DownloadBinder mBinder = new DownloadBinder();

    @Override
    public IBinder onBind(Intent intent) {
        return mBinder;
    }

    class DownloadBinder extends Binder {

        //在 startDownload() 创建了一个 DownloadTask 实例，把刚才的 DownloadListener 作为参数传入，然后调用 execute() 方法开启下载，并将下载文件的 URL 地址传入到 execute() 方法中，同时为了让这个下载服务成为一个前台服务，我们还调用了 startForeground() 方法，这样就会在系统状态栏中创建一个持续运行的通知了
        public void startDownload(String url) {
            if (downloadTask == null) {
                downloadUrl = url;
                downloadTask = new DownloadTask(listener);
                downloadTask.execute(downloadUrl);
                startForeground(1, getNotification("Downloading...", 0));
                Toast.makeText(DownloadService.this, "Downloading...", Toast.LENGTH_SHORT).show();
            }
        }

        //pauseDownload() 方法中的代码就是简单地调用了 DownloadTask 中的 pauseDownload() 方法
        public void pauseDownload() {
            if (downloadTask != null) {
                downloadTask.pauseDownload();
            }
        }

        //cancelDownload() 方法中调用了 DownloadTask 的 cancelDownload() 方法，需要注意的是，取消下载的时候我们需要将正在下载的文件删除掉
        public void cancelDownload() {
            if (downloadTask != null) {
                downloadTask.cancelDownload();
            }
            if (downloadUrl != null) {
                //取消下载时需要将文件删除，并将通知关闭
                String fileName = downloadUrl.substring(downloadUrl.lastIndexOf("/"));
                String directory = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getPath();
                File file = new File(directory + fileName);
                if (file.exists()) {
                    file.delete();
                }
                getNotificationManager().cancel(1);
                stopForeground(true);
                Toast.makeText(DownloadService.this, "Canceled", Toast.LENGTH_SHORT).show();
            }
        }

    }

    private NotificationManager getNotificationManager() {
        return (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
    }

    private Notification getNotification(String title, int progress) {
        Intent intent = new Intent(this, MainActivity.class);
        PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0);
        NotificationCompat.Builder builder = new NotificationCompat.Builder(this);
        builder.setSmallIcon(R.mipmap.ic_launcher);
        builder.setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher));
        builder.setContentIntent(pi);
        builder.setContentTitle(title);
        if (progress >= 0) {
            //当 progress 大于或等于 0 时才需显示下载速度
            builder.setContentText(progress + "%");
            //setProgress() 方法接收三个参数，第一个参数传入通知的最大进度，第二个参数传入通知的当前进度，第三个参数表示是否使用模糊进度条，这里传入 false，设置完 setProgress() 方法，通知上就会有进度条显示出来了
            builder.setProgress(100, progress, false);
        }
        return builder.build();
    }
        
}
```

修改 activity_main.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <Button
        android:id="@+id/start_download"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Start Download" />

    <Button
        android:id="@+id/pause_download"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Pause Download" />

    <Button
        android:id="@+id/cancel_download"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Cancel Download" />

</LinearLayout>
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener{

    private DownloadService.DownloadBinder downloadBinder;

    //创建一个 ServiceConnection 的匿名类，然后在 onServiceConnected() 方法中获取到 DownloadTask 实例，有了这个实例我们就可以在活动中调用服务提供的各种方法
    private ServiceConnection connection = new ServiceConnection() {
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            downloadBinder = (DownloadService.DownloadBinder) service;
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {

        }
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        //对各个按钮都进行了初始化操作并设置了点击事件
        Button startDownload = findViewById(R.id.start_download);
        Button pauseDownload = findViewById(R.id.pause_download);
        Button cancelDownload = findViewById(R.id.cancel_download);
        startDownload.setOnClickListener(this);
        pauseDownload.setOnClickListener(this);
        cancelDownload.setOnClickListener(this);
        Intent intent = new Intent(this, DownloadService.class);
        //注意 startService()、 bindService() 这两个方法至关重要，因为启动服务可以保证 DownloadService 一直在后台运行，绑定服务则可以让 MainActivity 和 DownloadService 进行通信，因此这两个方法都必不可少
        startService(intent);//启动服务
        bindService(intent, connection, BIND_AUTO_CREATE);//绑定服务
        //在 onCreate() 方法最后进行了 WRITE_EXTERNAL_STORAGE 的运行时权限申请， 因为下载文件是要下载到 SD 卡的 Download 目录下的，如果没有这个权限，我们整个程序都无法正常工作
        if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(MainActivity.this, new String[] {Manifest.permission.WRITE_EXTERNAL_STORAGE}, 1);
        }
    }

    @Override
    public void onClick(View v) {
        if (downloadBinder == null) {
            return;
        }
        switch (v.getId()) {
            //点击了开始按钮就调用 DownloadBinder 的 startDownload() 方法，这里可以传入任意的下载地址
            case R.id.start_download:
                String url = "http://raw.githubusercontent.com/guolindev/eclipse/master/eclipse-inst-win64.exe";
                downloadBinder.startDownload(url);
                break;
            case R.id.pause_download:
                downloadBinder.pauseDownload();
                break;
            case R.id.cancel_download:
                downloadBinder.cancelDownload();
                break;
            default:
                break;
        }
    }

    @Override
    public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
        switch (requestCode) {
            case 1:
                if (grantResults.length > 0 && grantResults[0] != PackageManager.PERMISSION_GRANTED) {
                    Toast.makeText(this, "拒绝权限无法使用程序", Toast.LENGTH_SHORT).show();
                    finish();
                }
                break;
            default:
        }
    }

    //需要注意，如果活动被销毁了，那么一定要记得对服务进行解绑，不然就有可能会造成内存泄漏，这里我们在 onDestroy() 方法中完成了解绑操作
    @Override
    protected void onDestroy() {
        super.onDestroy();
        unbindService(connection);
    }
    
}
```

在 AndroidManifest.xml 中声明使用到的权限

```java
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.servicebestpractice">

	//由于程序需要使用到网络和访问 SD 卡的功能，因此需要声明 INTERNET 和 WRITE_EXTERNAL_STORAGE 这两个权限
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        <service
            android:name=".DownloadService"
            android:enabled="true"
            android:exported="true"></service>

        <activity android:name=".MainActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>
```





## Material Design

Material Design 是解决 Android 平台界面风格不统一的问题

Material Design 的官方文章 http://material.google.com

新建一个 MaterialTest 项目



### Toolbar

Toolbar 是我们接触的第一个 Material 控件，它的另一个相关控件 ActionBar 就是我们编写的所有程序每个活动最顶部的那个标题栏

ActionBar 由于其设计的原因，被限定只能位于活动的顶部，从而不能实现一些 Material Design 的效果，因此官方现在已经不再建议使用 ActionBar，所以我们直接使用 Toolbar

Toolbar 的强大功能之处在于它不仅继承了 ActionBar 的所有功能，而且灵活性很高，可以配合其他空间来完成一些 Material Design 的效果

首先要知道任何一个新建的项目，默认都是会显示 ActionBar，其实这是根据项目中指定的主题来显示的，打开 AndroidManifest.xml

```java
<application
    android:allowBackup="true"
    android:icon="@mipmap/ic_launcher"
    android:label="@string/app_name"
    android:roundIcon="@mipmap/ic_launcher_round"
    android:supportsRtl="true"
    android:theme="@style/AppTheme">
    ...
</application>
```

可以看到这里使用 android:theme 属性指定了一个 AppTheme 的主题，那这个 AppTheme 在哪里定义的呢？打开 res/values/styles.xml 文件

```java
<resources>

    <!-- Base application theme. -->
    //这里定义了一个叫 AppTheme 的主题，然后指定它的 parent 主题是 Theme.AppCompat.Light.DarkActionBar。这个 DarkActionBar 是一个深色的 ActionBar 主题，我们之前所有的项目中自带的 ActionBar 就是因为指定了这个主题才出现的
    <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
        <!-- Customize your theme here. -->
        <item name="colorPrimary">@color/colorPrimary</item>
        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
        <item name="colorAccent">@color/colorAccent</item>
    </style>

</resources>
```

现在我们准备使用 Toolbar 来替代 ActionBar，因此需要指定一个不带 ActionBar 的主题，通常有 Theme.AppCompat.NoActionBar 和 Theme.AppCompat.Light.NoActionBar 表示淡色主题，它会将界面的主体颜色设成深色，陪衬颜色设成淡色。而 Theme.AppCompat.Light.NoActionBar 表示淡色主题，它会将界面的主体颜色设成淡色，陪衬颜色设成深色。由于我们之前的程序一直都是以淡色为主的，所以就选用淡色主题

```java
<resources>

    <!-- Base application theme. -->
    <style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar">
        <!-- Customize your theme here. -->
        <item name="colorPrimary">@color/colorPrimary</item>
        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
        <item name="colorAccent">@color/colorAccent</item>
    </style>

</resources>
```

AppTheme 其他属性

![](E:\Android笔记\第十二章笔记图片\微信图片_20190422003350.jpg)

现在我们已经把 ActionBar 隐藏起来了，那么接下来看一看怎么使用 Toolbar 来替代 ActionBar，修改 activity_main.xml

```java
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    //这里使用 xmlns:app 指定了一个新的命名空间
    //思考一下，正是由于每个布局文件都会使用 xmlns:android 来指定一个命名空间，因此我们才能一直使用 android:id 、android:layout_width 等写法，那么这里指定了 xmlns:app ，也就是说现在可以使用 app:attribute 这样的写法了。但是为什么这里要指定一个 xmlns:app 的命名空间呢？这是由于 Material Design 是在 Android 5.0 系统中才出现的，而很多的 Material 属性在 5.0 之前的系统中并不存在，那么为了能够兼容之前的老系统，我们就不能使用 android:attribute 这样的写法了， 而是应该使用 app:attribute
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

	//定义一个 Toolbar 控件，这个控件是由 appcompat-v7 库提供的。这里我们给 Toolbar 指定了一个 id ，将它的宽度设置为 match_parent，高度设置为 actionBar 的高度，背景色设置为 colorPrimary。不过由于我们刚才在 style.xml 中将程序的主题指定成了淡色主题，因此 Toolbar 现在也是淡色主题，而 Toolbar 上面的各种元素就会自动使用深色系，这是为了和主题颜色区别开。但是这个效果看起来就会很差，之前使用 ActionBar 时文字都是白色的，现在变成黑色的会很难看。那么为了能让 Toolbar 单独使用深色主题，这里我们使用 android:theme 属性，将 Toolbar 的主题指定成了 ThemeOverlay.AppCompat.Dark.ActionBar。但是这样又会出现新的问题，如果 Toolbar 中有菜单按钮，那么弹出的菜单项也会变成深色主题，这样就再次变得十分难看，于是这里使用了 app:popupTheme 属性单独将弹出的菜单项指定成了淡色主题
	//之所以使用 app:popupTheme 也是上面所讲的原因，为了兼容 Android 5.0 以下的系统
    <android.support.v7.widget.Toolbar
        android:id="@+id/toolbar"
        android:layout_width="match_parent"
        android:layout_height="?attr/actionBarSize"
        android:background="?attr/colorPrimary"
        android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar"
        app:popupTheme="@style/ThemeOverlay.AppCompat.Light" />

</FrameLayout>
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        //首先通过 findViewById() 得到 Toolbar 的实例，然后调用 setSupportActionBar() 方法并将 Toolbar 的实例传入，这样我们就做到既使用了 Toolbar，又让它外观与功能和 ActionBar 一致了
        Toolbar toolbar = findViewById(R.id.toolbar);
        setSupportActionBar(toolbar);
    }
}
```

虽然标题栏看上去和之前的标题栏没什么两样，但其实它已经是 Toolbar 而不是 ActionBar 了，因此它具备了实现 Material Design 效果的能力

修改标题栏上显示的文字内容，这段内容是在 AndroidManifest.xml 中指定的

```java
<application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        <activity android:name=".MainActivity"
            //给 activity 增加了一个 android:label 属性，用于指定在 Toolbar 中显示的文字内容，如果没有指定的话，会默认使用 application 中指定的 label 内容，也就是我们的应用名称
            android:label="Fruits">
            ...
        </activity>
    </application>
```

只有一个标题的 Toolbar 看起来太单调了，我们还可以再添加一些 action 按钮来让 Toolbar 更加丰富一些，这里提前准备一些 action 按钮来让 Toolbar 更加丰富一下，将提前准备好的一些图片放在 drawable-xxhdpi 目录下，右击 res 目录 -> New -> Directory 创建一个 menu 文件夹，右击 menu 文件夹 -> New -> Menu resource file，创建一个 toolbar.xml 文件，并修改：

```java
<menu xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto" >

    //通过 <item> 标签来定义 action 按钮，android:id 用于指定按钮的 id，android:icon 用于指定按钮的图标，android:title 用于指定按钮的文字
    <item
        android:id="@+id/backup"
        android:icon="@drawable/ic_backup"
        android:title="Backup"
	    //接着使用 app:showAsAction 来指定按钮的显示位置，有以下几种值可选：always 表示永远显示在 Toolbar 中，如果屏幕空间不够则不显示；ifRoom 表示屏幕空间足够的情况下显示在 Toolbar 中，不够的话就显示在菜单当中；never 则表示永远显示在菜单当中。注意，Toolbar 中的 action 按钮只会显示图标，菜单中的 action 按钮只会显示文字            
        app:showAsAction="always" />

    <item
        android:id="@+id/delete"
        android:icon="@drawable/ic_delete"
        android:title="Delete"
        app:showAsAction="ifRoom" />

    <item
        android:id="@+id/setting"
        android:icon="@drawable/ic_settings"
        android:title="Settings"
        app:showAsAction="never" />

</menu>
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

	...

    //在 onCreateOptionsMenu() 方法中加载了 toolbar.xml 这个菜单文件
    public boolean onCreateOptionsMenu(Menu menu) {
        getMenuInflater().inflate(R.menu.toolbar, menu);
        return true;
    }

    //在 onOptionsItemSelected() 方法中处理各个按钮的点击事件
    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.backup:
                Toast.makeText(this, "You clicked Backup", Toast.LENGTH_SHORT).show();
                break;
            case R.id.delete:
                Toast.makeText(this, "You clicked Delete", Toast.LENGTH_SHORT).show();
                break;
            case R.id.setting:
                Toast.makeText(this, "You clicked Settings", Toast.LENGTH_SHORT).show();
                break;
            default:
        }
        return true;
    }
    
}
```



### 滑动菜单



#### DrawerLayout

所谓的滑动菜单就是将一些菜单选项隐藏起来，而不是放置在主屏幕上，然后可以通过滑动的方式将菜单显示出来，这种方式既节省了屏幕空间，又实现了非常好的动画效果，是 Material Design 中推荐的做法

不过如果是全靠我们自己去实现上述功能，难度恐怕很大，幸运的是 Google 提供了一个 DrawerLayout 控件，借助这个控件，实现滑动菜单简单又方便

DrawerLayout 是一个布局，在布局中允许放入两个直接子控件，第一个子控件是主屏幕中显示的内容，第二个子控件是滑动菜单中显示的内容。修改 activity_main.xml

```java
//最外层的控件使用了 DrawerLayout，这个控件是由 support-v4 库提供的
<android.support.v4.widget.DrawerLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:id="@+id/drawer_layout"
    android:layout_width="match_parent"
    android:layout_height="match_parent" >

    //第一个子控件使用刚才的 Toolbar，用于作为主屏幕中显示的内容 
    <FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:app="http://schemas.android.com/apk/res-auto"
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <android.support.v7.widget.Toolbar
            android:id="@+id/toolbar"
            android:layout_width="match_parent"
            android:layout_height="?attr/actionBarSize"
            android:background="?attr/colorPrimary"
            android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar"
            app:popupTheme="@style/ThemeOverlay.AppCompat.Light" />

    </FrameLayout>
    
    //第二个子控件使用了一个 TextView，用于作为滑动菜单中显示的内容，其实使用什么都可以，DrawerLayout 并没有限制只能使用固定的控件
    <TextView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_gravity="start"
        android:text="This is menu"
        android:background="#FFF" />

</android.support.v4.widget.DrawerLayout>
```

但是关于第二个子控件有一点需要注意，layout_gravity 这个属性是必须指定的，因为我们需要告诉 DrawerLayout 滑动菜单是在屏幕的左边还是右边，指定 left 表示滑动菜单在左边，指定 right 表示滑动菜单在右边。这里我们指定了 start，表示会根据系统语言进行判断，如果系统语言是从左往右的，比如英语、汉语，滑动菜单就在左边，如果系统语言是从右往左的，比如阿拉伯语，滑动菜单就在右边

不过现在滑动菜单有点问题，因为只有在屏幕的左侧边缘滑动进行拖动才能将菜单拖出来，而很多用户可能根本就不知道有这个功能，为了提示用户有这个功能， Material Design 建议的做法是在 Toolbar 的最左边加入一个导航按钮，点击了按钮也会将滑动的菜单内容展示出来，这样就相当于给用户提供了两种打开滑动菜单的方式，防止一些用户不知道屏幕的左侧边缘是可以拖动的

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    private DrawerLayout mDrawerLayout;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Toolbar toolbar = findViewById(R.id.toolbar);
        setSupportActionBar(toolbar);
        //获取 DrawerLayout 实例
        mDrawerLayout = findViewById(R.id.drawer_layout);
        //调用 getSupportActionBar() 方法得到 ActionBar 实例，虽然这个 ActionBar 的具体实现是由 Toolbar 来完成的
        ActionBar actionBar = getSupportActionBar();
        if (actionBar != null) {
            //接着调用 ActionBar 的 setDisplayHomeAsUpEnabled() 方法让导航按钮显示出来，又调用了 setHomeAsUpIndicator() 方法来设置一个导航按钮图标。实际上，Toolbar 最左侧的这个按钮就叫做 HomeAsUp 按钮，它默认的图标是一个返回的箭头，含义是返回上一个活动。很明显，这里我们将它默认的样式和作用都进行了修改
            actionBar.setDisplayHomeAsUpEnabled(true);
            actionBar.setHomeAsUpIndicator(R.drawable.ic_menu);
        }
    }

    ...

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            //在 onOptionsItemSelected() 方法中中对 HomeAsUp 按钮的点击事件进行处理，HomeAsUp 按钮的 id 永远都是 android.R.id.home，然后调用 DrawerLayout 的 openDrawer() 来将滑动菜单展示出来，该方法要求传入一个 Gravity 参数，为了保证这里了的行为和 XML 中定义的一致，我们传入 GravityCompat.START
            case android.R.id.home:
                mDrawerLayout.openDrawer(GravityCompat.START);
                break;
			...
        }
        return true;
    }

}
```



#### NavigationView

我们现在做出的菜单还非常丑，事实上，我们可以在滑动菜单页面定制任意的布局，不过谷歌给我们提供了一种更好的方法——使用 NavigationView

NavigationView 是 Design Support 库中提供的一个控件，它不仅是严格按照 Material Design 的要求来进行设计的，而且还可以将滑动菜单页面的实现变得非常简单

首先将 Design Support 库引入到项目中，打开 app/build.gradle ，在 dependencies 中添加

```java
dependencies {
    //第一行是 Design Support 库
    implementation 'com.android.support:design:28.0.0'
    //第二行是一个开源项目 CircleImageView，它可以用来轻松实现图片图形化的功能
    // CircleImageView 的项目主页是 http://github.com/hdodenhof/CircleImageView
    implementation 'de.hdodenhof:circleimageview:2.1.0'
    ...
}
```

在开始使用 CircleImageView 之前， 我们还需要提前准备好两个东西：menu 和 headerLayout。menu 是用来在 NavigationView 中显示具体的菜单项的，headerLayout 则是用来在 NavigationView 中显示头部布局的

右击 menu 文件夹 -> New -> Menu resource file，创建一个 nav_menu.xml

```java
//首先在 <menu> 标签中嵌套了一个 <group> 标签，然后将 group 的 checkableBehavior 指定为 single 表示组中的所有菜单项只能单选
<menu xmlns:android="http://schemas.android.com/apk/res/android">
    <group android:checkableBehavior="single" >
        
        //定义了 5 个 item ，分别使用 android:id 属性指定菜单项的 id， android:icon 属性指定菜单项的图标， android:title 属性指定菜单项显示的文字

        <item
            android:id="@+id/nav_call"
            android:icon="@drawable/nav_call"
            android:title="Call" />

        <item
            android:id="@+id/nav_friends"
            android:icon="@drawable/nav_friends"
            android:title="Friends" />

        <item
            android:id="@+id/nav_location"
            android:icon="@drawable/nav_location"
            android:title="Location" />

        <item
            android:id="@+id/nav_mail"
            android:icon="@drawable/nav_mail"
            android:title="Mail" />

        <item
            android:id="@+id/nav_task"
            android:icon="@drawable/nav_task"
            android:title="Tasks" />
        
    </group>
</menu>
```

接下来应该准备 headerLayout 了，这是一个可以随意定制的布局，我们就在 headerLayout 中放置头像、用户名、邮箱地址这 3 项内容

右击 layout 文件夹 -> New -> Layout resource file，创建一个 nav_header.xml

```java
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent" 
    android:layout_height="180dp"
    android:padding="10dp"
    android:background="?attr/colorPrimary">
    
    // CircleImageView 是一个用于将图片圆形化的控件，它的用法和 ImageView 是完全一样，这里给它指定了一张图片作为头像，然后设置为居中显示
    <de.hdodenhof.circleimageview.CircleImageView
        android:id="@+id/icon_image"
        android:layout_width="70dp"
        android:layout_height="70dp"
        android:src="@drawable/nav_icon"
        android:layout_centerInParent="true"/>
    
    <TextView
        android:id="@+id/mail"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentBottom="true"
        android:text="tonygreendev@gmail.com"
        android:textColor="#FFF"
        android:textSize="14sp" />
    
    <TextView
        android:id="@+id/username"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_above="@+id/mail"
        android:text="Tony Green" 
        android:textColor="#FFF"
        android:textSize="14sp" />

</RelativeLayout>
```

修改 activity_main.xml

```java
<android.support.v4.widget.DrawerLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:id="@+id/drawer_layout"
    android:layout_width="match_parent"
    android:layout_height="match_parent" >

    <FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:app="http://schemas.android.com/apk/res-auto"
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <android.support.v7.widget.Toolbar
            android:id="@+id/toolbar"
            android:layout_width="match_parent"
            android:layout_height="?attr/actionBarSize"
            android:background="?attr/colorPrimary"
            android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar"
            app:popupTheme="@style/ThemeOverlay.AppCompat.Light" />

    </FrameLayout>

	//将之前的 TextView 换成 NavigationView，这样滑动菜单中显示的内容也就变成了 NavigationView
    <android.support.design.widget.NavigationView
        android:id="@+id/nav_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_gravity="start"
        //通过 app:menu 和 app:headerLayout 将刚才准备好的 menu 和 headerLayout 设置了进去，这样 NavigationView 就定义完成了
        app:menu="@menu/nav_menu"
        app:headerLayout="@layout/nav_header" />

</android.support.v4.widget.DrawerLayout>
```

NavigationView 虽然定义完成了，但我们还需要去处理菜单项的点击事件才行，修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    private DrawerLayout mDrawerLayout;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Toolbar toolbar = findViewById(R.id.toolbar);
        setSupportActionBar(toolbar);
        mDrawerLayout = findViewById(R.id.drawer_layout);
        //首先获取 NavigationView 实例
        NavigationView navView = findViewById(R.id.nav_view);
        ActionBar actionBar = getSupportActionBar();
        if (actionBar != null) {
            actionBar.setDisplayHomeAsUpEnabled(true);
            actionBar.setHomeAsUpIndicator(R.drawable.ic_menu);
        }
        //然后调用它的 setCheckedItem() 方法将 Call 菜单项设置为默认选中
        navView.setCheckedItem(R.id.nav_call);
        //接着调用 setNavigationItemSelectedListener() 方法来设置一个菜单选中事件的监听器，当用户点击了任意菜单项时，就会回调到 onNavigationItemSelected() 方法中，我们可以在这个方法中写相应的逻辑处理，不过这里我们并没有附加任何逻辑，只是调用了 DrawerLayout 的 closeDrawers() 方法将滑动菜单关闭
        navView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() {
            @Override
            public boolean onNavigationItemSelected(MenuItem item) {
                mDrawerLayout.closeDrawers();
                return true;
            }
        });
    }

	...

}
```



### 悬浮按钮和可交互提示

立面设计是 Material Design 中一条非常重要的设计思想，也就是说，按照 Material Design 的理念，应用程序的界面不仅仅只是一个平面，而应该是有立体效果的

官方给出的示例中，最简单且最具代表性的立面设计就是悬浮按钮了，这种按钮不属于平面的一部分，而是位于另外一个维度的，因此给人一种悬浮的感觉



#### FloatingActionButton

FloatingActionButton 是 Design Support 库中提供的一个控件，这个控件可以帮助我们比较轻松地实现悬浮按钮的效果

它默认会使用 colorAccent 来作为按钮的颜色，我们还可以通过给按钮指定一个图标来表明这个按钮的作用是什么

修改 activity_main.xml

```java
<android.support.v4.widget.DrawerLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:id="@+id/drawer_layout"
    android:layout_width="match_parent"
    android:layout_height="match_parent" >

    <FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:app="http://schemas.android.com/apk/res-auto"
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <android.support.v7.widget.Toolbar
            android:id="@+id/toolbar"
            android:layout_width="match_parent"
            android:layout_height="?attr/actionBarSize"
            android:background="?attr/colorPrimary"
            android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar"
            app:popupTheme="@style/ThemeOverlay.AppCompat.Light" />

        //在主屏幕中加入了一个 FloatingActionButton
        <android.support.design.widget.FloatingActionButton
            android:id="@+id/fab"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            // layout_gravity 属性指定将这个控件放置于屏幕的右下角，其中 end 的工作原理和之前的 start 是一样的，即如果系统语言是从左往右的，那么 end 就表示在右边，如果系统语言是从右往左的，那么 end 就表示在左边
            android:layout_gravity="bottom|end"
            //通过 layout_margin 属性给控件的四周留点边距，紧贴着屏幕边缘是不好看的，最后通过 src 属性给 FloatingActionButton 设置了一个图标
            android:layout_margin="16dp"
            android:src="@drawable/ic_done" />

    </FrameLayout>

	...

</android.support.v4.widget.DrawerLayout>
```

仔细观察会发现按钮下面有阴影，这就是悬浮所带来的投影，其实我们还可以指定 FloatingActionButton 的悬浮高度

```java
<android.support.design.widget.FloatingActionButton
    android:id="@+id/fab"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_gravity="bottom|end"
    android:layout_margin="16dp"
    android:src="@drawable/ic_done"
    //使用 app:elevation 属性给 FloatingActionButton 指定一个高度值，高度值越大，投影范围也越大，但是投影效果越淡，高度值越小，投影范围也越小，但是投影效果越浓，一般 FloatingActionButton 默认效果就已经足够了
    app:elevation="8dp" />
```

FloatingActionButton 处理点击事件，修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    private DrawerLayout mDrawerLayout;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
		...
        //其实 FloatingActionButton 和 Button 没有什么两样，都是调用 setOnClickListener() 方法来注册一个监听器，当点击按钮时，就会执行监听器中的 onClick() 方法，这里我们在 onClick() 方法中弹出了一个 Toast
        FloatingActionButton fab = findViewById(R.id.fab);
        fab.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                Toast.makeText(MainActivity.this, "FAB clicked", Toast.LENGTH_SHORT).show();
            }
        });
    }
}
```



#### Snackbar

一个 Design Support 库提供的更加先进的提示工具 —— Snackbar

首先要明确，Snackbar 并不是 Toast 的替代品，它们两者之间有着不同的应用场景

Toast 的作用是告诉用户现在发生了什么事情，但同时用户只能被动接收这个事情，因为没有什么办法能让用户选择

而 Snackbar 则在这方面进行了扩展，它允许在提示当中加入一个可交互按钮，当用户点击按钮的时候可以执行一些额外的操作逻辑。打个比方，如果我们在执行删除操作的时候只弹出一个 Toast 提示，那么用户是误删了某个重要数据的话肯定十分抓狂吧，但是如果我们增加了一个 Undo 按钮，就相当于给用户提供了一种弥补措施，从而大大降低了事故发生的概率，提升了用户的体验

Snackbar 的用法也非常简单，它和 Toast 基本相似，只不过可以额外增加一个按钮的点击事件，修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    private DrawerLayout mDrawerLayout;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
		...
        FloatingActionButton fab = findViewById(R.id.fab);
        fab.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                //调用 Snackbar 的 make() 方法来创建一个 Snackbar 对象
                // make() 的方法第一个参数需要传入一个 View，只要当前界面布局的任意一个 View 都可以，Snackbar 会使用这个 View 来自动查找最外层的布局，用于展示 Snackbar。第二个参数就是 Snackbar 中显示的内容，第三个参数是 Snackbar 显示的时长。这些都和 Toast 类似
                //接着又调用一个 setAction() 方法来设置一个动作，从而让 Snackbar 不仅仅是一个提示，而是可以和用户进行交互的，这里我们在动作按钮的点击事件里面弹出一个 Toast 提示，最后调用 show() 方法让 Snackbar 显示出来
                Snackbar.make(view, "Data deleted", Snackbar.LENGTH_SHORT)
                        .setAction("Undo", new View.OnClickListener() {
                            @Override
                            public void onClick(View v) {
                                Toast.makeText(MainActivity.this, "Data restored", Toast.LENGTH_SHORT).show();
                            }
                        })
                    	.show();
            }
        });
    }

	...

}
```

你会发现运行后 Snackbar 会将我们的悬浮按钮遮挡住，虽然 Snackbar 过一会就会消失，解决的方法只需要借助 CoordinatorLayout 就可以解决



#### CoordinatorLayout

CoordinatorLayout 可以说是一个加强版的 FrameLayout，这个布局也是由 Design Support 库提供的，它的普通情况下和 FrameLayout 基本一致，也有一些 Material Design

事实上，CoordinatorLayout 可以监听其所有子控件的各种事件，然后自动帮助我们做出最为合理的响应。举个简单的例子，刚才弹出的 Snackbar 提示将悬浮按钮遮挡住了，而如果我们能让 CoordinatorLayout 监听到 Snackbar 的弹出事件，那么它会自动将内部的 FloatingActionButton 向上偏移，从而确保不会被 Snackbar 遮挡到

使用 CoordinatorLayout 也非常简单，只需要将原来的 FrameLayout 替换一下就好了，修改 activity_main.xml

```java
<android.support.v4.widget.DrawerLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:id="@+id/drawer_layout"
    android:layout_width="match_parent"
    android:layout_height="match_parent" >

    //由于 CoordinatorLayout 本身就是加强版的 FrameLayout，因此这种替换不会有任何的副作用
    <android.support.design.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:app="http://schemas.android.com/apk/res-auto"
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <android.support.v7.widget.Toolbar
            android:id="@+id/toolbar"
            android:layout_width="match_parent"
            android:layout_height="?attr/actionBarSize"
            android:background="?attr/colorPrimary"
            android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar"
            app:popupTheme="@style/ThemeOverlay.AppCompat.Light" />

        <android.support.design.widget.FloatingActionButton
            android:id="@+id/fab"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="bottom|end"
            android:layout_margin="16dp"
            android:src="@drawable/ic_done"
            app:elevation="8dp" />

    </android.support.design.widget.CoordinatorLayout>

    ...

</android.support.v4.widget.DrawerLayout>
```

回头思考一下，刚才说 CoordinatorLayout 可以监听其所有子控件的各种事件，但是 Snackbar 好像并不是 CoordinatorLayout 的子控件吧，为什么它会被监听到呢？

其实道理很简单，我们在 Snackbar 的 make() 方法中传入的第一个参数，这个参数就是用来指定 Snackbar 是基于那个 View 来触发的，刚才我们传入的是 FloatingActionButton 本身，而 FloatingActionButton 是 CoordinatorLayout 中的子控件，因此这个事件就理所应当能被监听到了。你可以自己实验一下，如果给 Snackbar 的 make() 方法传入一个 DrawerLayout，那么 Snackbar 就会再次遮挡住悬浮按钮，因为 DrawerLayout 不是 CoordinatorLayout 的子控件，CoordinatorLayout 也无法监听到 Snackbar 的弹出和隐藏事件了

```java
FloatingActionButton fab = findViewById(R.id.fab);
fab.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View view) {
        Snackbar.make(mDrawerLayout, "Data deleted", Snackbar.LENGTH_SHORT)
                .setAction("Undo", new View.OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        Toast.makeText(MainActivity.this, "Data restored", Toast.LENGTH_SHORT).show();
                    }
                })
                .show();
    }
});
```



### 卡片式布局

卡片式布局也是 Materials Design 中提出的一个新的概念，它可以让页面中的元素看起来就像在卡片中一样，并且还能拥有圆角和投影



#### CardView

CardView 是用于实现卡片布局效果的重要控件，由 appcompat-v7 库提供，实际上，CardView 也是一个 FrameLayout，只是额外提供了圆角和阴影等效果

CardView 的基本用法

```java
//定义一个 CardView 布局
<android.support.v7.widget.CardView
	android:layout_width="match_parent"
	android:layout_height="wrap_content"
    //通过 app:cardCornerRadius 属性指定卡片圆角的弧度，数值越大，圆角的弧度也越大
	app:cardCornerRadius="4dp"
    //通过 app:elevation 属性指定卡片的高度，高度值越大，投影范围也越大，但是投影效果越淡，高度值越小，投影范围也越小，但是投影效果越浓，这一点和 FloatingActionButton 是一致的
	app:elevation="5dp">
	// CardView 布局中放置了一个 TextView，那么这个 TextView 就会显示在一张卡片当中了
	<TextView
		android:id="@+id/info_text"
		android:layout_width="match_parent"
		android:layout_height="wrap_content" />
</android.support.v7.widget.CardView>	
```

使用 RecyclerView 来填充 MaterialTest 项目的主界面部分，在 app/build.gradle 中先声明 RecyclerView 和 CardView 的依赖库，同时添加了一个 Glide 库的依赖

```java
dependencies {
	...
    implementation 'com.android.support:recyclerview-v7:24.2.1'
    implementation 'com.android.support:cardview-v7:24.2.1'
    implementation 'com.github.bumptech.glide:glide:3.7.0'
}
```

修改 activity_main.xml

```java
<android.support.v4.widget.DrawerLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:id="@+id/drawer_layout"
    android:layout_width="match_parent"
    android:layout_height="match_parent" >

    <android.support.design.widget.CoordinatorLayout 
        xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:app="http://schemas.android.com/apk/res-auto"
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <android.support.v7.widget.Toolbar
            android:id="@+id/toolbar"
            android:layout_width="match_parent"
            android:layout_height="?attr/actionBarSize"
            android:background="?attr/colorPrimary"
            android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar"
            app:popupTheme="@style/ThemeOverlay.AppCompat.Light" />

        //在 CoordinatorLayout 中添加了一个 RecyclerView，给它指定一个 id，然后将高度和宽度设置为 match_parent 使得 RecyclerView 占满整个布局空间
        <android.support.v7.widget.RecyclerView
            android:id="@+id/recycler_view"
            android:layout_width="match_parent"
            android:layout_height="match_parent" />

        <android.support.design.widget.FloatingActionButton
            android:id="@+id/fab"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="bottom|end"
            android:layout_margin="16dp"
            android:src="@drawable/ic_done"
            app:elevation="8dp" />

    </android.support.design.widget.CoordinatorLayout>

	...

</android.support.v4.widget.DrawerLayout>
```

定义一个实体 Fruit 类

```java
public class Fruit {
    
    private String name;
    
    private int imageId;
    
    public Fruit(String name, int imageId) {
        this.name = name;
        this.imageId = imageId;
    }

    public String getName() {
        return name;
    }

    public int getImageId() {
        return imageId;
    }
}
```

Fruit 类中只有两个字段，name 表示水果的名字，imageId 表示水果对应图片资源的 id

然后需要为 RecyclerView 的子项制定一个我们自定义的布局，在 layout 目录下新建 fruit_item.xml 

```java
//使用 CardView 作为子项的最外层布局，从而使得 RecyclerView 中的每个元素都是在卡片当中的。CardView 由于是一个 FrameLayout，因此它没有什么方便的定位方式，这里我们只好在 CardView 中再嵌套一个 LinearLayout，然后在 LinearLayout 中放置具体的内容
<android.support.v7.widget.CardView
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_margin="5dp"
    app:cardCornerRadius="4dp" >

    <LinearLayout
        android:orientation="vertical"
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

            <ImageView
                android:id="@+id/fruit_image"
                android:layout_width="match_parent"
                android:layout_height="100dp"
                // scaleType 这个属性可以指定图片的缩放模式
                //由于各张水果图片的长宽比例可能都不一致，为了让所有的图片都能充满整个 ImageView，这里使用了 centerCrop 模式，它可以让图片保持原有比例填充满 ImageView，并将超出的部分裁减掉
                android:scaleType="centerCrop" />

            <TextView
                android:id="@+id/fruit_name"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center_horizontal"
                android:layout_margin="5dp"
                android:textSize="16sp" />
    </LinearLayout>

</android.support.v7.widget.CardView>
```

接下来为 RecyclerView 准备适配器，新建 FruitAdapter 类

```java
public class FruitAdapter extends RecyclerView.Adapter<FruitAdapter.ViewHolder> {

    private Context mContext;

    private List<Fruit> mFruitList;

    static class ViewHolder extends RecyclerView.ViewHolder {
        CardView cardView;
        ImageView fruitImage;
        TextView fruitName;

        public ViewHolder(View view) {
            super(view);
            cardView = (CardView) view;
            fruitImage = view.findViewById(R.id.fruit_image);
            fruitName = view.findViewById(R.id.fruit_name);
        }
    }

    public FruitAdapter(List<Fruit> fruitList) {
        mFruitList = fruitList;
    }

    @Override
    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        if (mContext == null) {
            mContext = parent.getContext();
        }
        View view = LayoutInflater.from(mContext).inflate(R.layout.fruit_item, parent, false);
        return new ViewHolder(view);
    }

    @Override
    public void onBindViewHolder(ViewHolder holder, int position) {
        Fruit fruit = mFruitList.get(position);
        holder.fruitName.setText(fruit.getName());
        //使用 Glide 来加载水果图片
        //首先调用 Glide.with() 方法并传入一个 Context、Activity 或 Fragment 参数，然后调用 load() 方法去加载图片，可以是一个 URL 地址，也可以是一个本地路径，或者是一个资源 id，最后调用 into() 方法将图片设置到某一个 ImageView 中就可以了
        //使用 Glide 而不是传统的设置图片的方式是因为这次我们从网上找到的这些水果图片像素都非常高，如果不进行压缩就直接显示的话就会引起内存溢出，而使用 Glide 就完全不需要担心这回事，因为 Glide 在内部做了许多非常复杂的逻辑操作，其中就包括了图片压缩，我们只需要安心按照 Glide 的标准去加载图片就可以了
        Glide.with(mContext)
                .load(fruit.getImageId())
                .into(holder.fruitImage);
    }

    @Override
    public int getItemCount() {
        return mFruitList.size();
    }
    
}
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    private DrawerLayout mDrawerLayout;

    //定义一个数组，数组里面存放了很多个 Fruit 的实例，每个实例都代表一种水果
    private Fruit[] fruits = {new Fruit("Apple", R.drawable.apple), new Fruit("Banana", R.drawable.banana),
                                new Fruit("Orange", R.drawable.orange), new Fruit("Watermelon", R.drawable.watermelon),
                                new Fruit("Pear", R.drawable.pear), new Fruit("Grape", R.drawable.grape),
                                new Fruit("Pineapple", R.drawable.pineapple), new Fruit("Strawberry", R.drawable.strawberry),
                                new Fruit("Cherry", R.drawable.cherry), new Fruit("Mango", R.drawable.mango)};

    private List<Fruit> fruitList = new ArrayList<>();

    private FruitAdapter adapter;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        ...
        initFruits();
        //在第三章中我们已经学过了 LinearLayoutManager 和 StaggeredGridLayoutManager ，现在使用了 GridLayoutManager 终于将所有的布局方式补齐了
        // GridLayoutManager 的用法也没有什么特别之处，它的构造函数接收两个参数，第一个是 Context，第二个是列数，这里我们希望每一行中会有两列数据
        RecyclerView recyclerView = findViewById(R.id.recycler_view);
        GridLayoutManager layoutManager = new GridLayoutManager(this,2);
        recyclerView.setLayoutManager(layoutManager);
        adapter = new FruitAdapter(fruitList);
        recyclerView.setAdapter(adapter);
    }

    //在 initFruits() 方法中先是清空了一下 fruitList 中的数据，接着使用一个随机函数，从刚才定义的 Fruit 数组中随机天选一个水果放入到 fruitList 当中，这样每一次打开程序看到的水果数据都会是不同的
    private void initFruits() {
        fruitList.clear();
        for (int i = 0; i < 50; i ++) {
            Random random = new Random();
            int index = random.nextInt(fruits.length);
            fruitList.add(fruits[index]);
        }
    }

}
```

运行后发现 Toolbar 被 RecyclerView 给挡住了，解决需要借助到另外一个工具了——AppBarLayout



#### AppBarLayout

RecyclerView 为什么会把 Toolbar 给挡住呢？其实并不难理解，由于 RecyclerView 和 Toolbar 都是放置在 CoordinatorLayout 中的，而前面已经说过， CoordinatorLayout 就是一个加强版的 FrameLayout，那么 FrameLayout 中的所有控件在不进行明确定位的情况下，默认都会摆放在布局的左上角，从而也就产生了遮挡现象。其实这已经不是我们第一次遇到这种情况了，我们在 第三章第三小节的学习中早就见识过控件与控件之间遮挡的效果

传统情况下，使用偏移是唯一的解决方法，即让 RecyclerView 向下偏移一个 Toolbar 的高度，从而不会遮挡 Toolbar

由于我们使用的是 CoordinatorLayout，因此自然会有更加巧妙的方法，这里我们使用 Design Support 库中提供的另外一个工具—— AppBarLayout，它实际上是一个垂直方向的 LinearLayout，它在内部做了很多滚动事件的封装，并应用了一些 Material Design 的设计理念

我们解决覆盖的问题只需要两步就可以了，第一步将 Toolbar 嵌套到 AppBarLayout 中，第二步给 RecyclerView 指定一个布局行为，修改 activity_main.xml

```java
<android.support.v4.widget.DrawerLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:id="@+id/drawer_layout"
    android:layout_width="match_parent"
    android:layout_height="match_parent" >

    <android.support.design.widget.CoordinatorLayout
        xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:app="http://schemas.android.com/apk/res-auto"
        android:layout_width="match_parent"
        android:layout_height="match_parent">

		//首先定义了一个 AppBarLayout，并将 Toolbar 放置在了 AppBarLayout 里面
        <android.support.design.widget.AppBarLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content" >

            <android.support.v7.widget.Toolbar
                android:id="@+id/toolbar"
                android:layout_width="match_parent"
                android:layout_height="?attr/actionBarSize"
                android:background="?attr/colorPrimary"
                android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar"
                app:popupTheme="@style/ThemeOverlay.AppCompat.Light" />

        </android.support.design.widget.AppBarLayout>

        <android.support.v7.widget.RecyclerView
            android:id="@+id/recycler_view"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            //然后在 RecyclerView 中使用 app:layout_behavior 属性指定了一个布局行为，其中 appbar_scrolling_view_behavior 这个字符串也是由 Design Support 库提供的
            app:layout_behavior="@string/appbar_scrolling_view_behavior" />

        <android.support.design.widget.FloatingActionButton
            android:id="@+id/fab"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="bottom|end"
            android:layout_margin="16dp"
            android:src="@drawable/ic_done"
            app:elevation="8dp" />

    </android.support.design.widget.CoordinatorLayout>

    ...

</android.support.v4.widget.DrawerLayout>
```

AppBarLayout 到底能实现什么样的 Material Design 效果呢？当 AppBarLayout 接收到滚动事件的时候，它内部的子控件其实是可以指定如何去影响这些事件的，通过 app:layout_scrollFlags 属性就能实现，修改 activity_main.xml

```java
<android.support.v4.widget.DrawerLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:id="@+id/drawer_layout"
    android:layout_width="match_parent"
    android:layout_height="match_parent" >

    <android.support.design.widget.CoordinatorLayout
        xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:app="http://schemas.android.com/apk/res-auto"
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <android.support.design.widget.AppBarLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content" >

            <android.support.v7.widget.Toolbar
                android:id="@+id/toolbar"
                android:layout_width="match_parent"
                android:layout_height="?attr/actionBarSize"
                android:background="?attr/colorPrimary"
                android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar"
                app:popupTheme="@style/ThemeOverlay.AppCompat.Light"
                //在 Toolbar 中添加了一个 layout_scrollFlags 属性，并将这个属性的值指定成了 scroll|enterAlways|snap
                // scroll 表示当 RecyclerView 向上滚动的时候，Toolbar 会跟着一起向上滚动并实现隐藏
                // enterAlways 表示当 RecyclerView 向下滚动的时候，Toolbar 会跟着一起向下滚动并重新显示
                // snap 表示当 Toolbar 还没有完全隐藏或显示的时候，会根据当前滚动的距离，自动选择是隐藏还是显示
                app:layout_scrollFlags="scroll|enterAlways|snap"/>

        </android.support.design.widget.AppBarLayout>

   	...

</android.support.v4.widget.DrawerLayout>
```

像这种功能，如果是使用  ActionBar 的话那就完全不可能实现的，Toolbar 的出现为我们提供了更多的可能



### 下拉刷新

SwipeRefreshLayout 就是用于实现下拉刷新功能的核心类，它是由 support-v4 库提供的，我们把想要实现下拉刷新功能的控件放置到 SwipeRefreshLayout 中，就可以迅速让这个控件支持下拉刷新，那么在 MaterialTest 项目中，应该支持下拉刷新的功能的控件自然就是 RecyclerView 了

修改 activity_main.xml

```java
//在 RecyclerView 的外面又嵌套了一层 SwipeRefreshLayout，这样 RecyclerView 就自动拥有下拉刷新功能了
<android.support.v4.widget.SwipeRefreshLayout
    android:id="@+id/swipe_refresh"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    //另外需要注意的是，由于 RecyclerView 现在变成了 SwipeRefreshLayout 的子控件，因此之前使用 app:layout_behavior 声明的布局行为现在也要移到 SwipeRefreshLayout 中才行
    app:layout_behavior="@string/appbar_scrolling_view_behavior" >

    <android.support.v7.widget.RecyclerView
        android:id="@+id/recycler_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />

</android.support.v4.widget.SwipeRefreshLayout>
```

虽然 RecyclerView 已经支持下拉刷新功能了，但是我们还要在代码中处理具体的刷新逻辑才行，修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    ...

    private SwipeRefreshLayout swipeRefreshLayout;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        ...
        //首先通过 findViewById() 方法拿到 SwipeRefreshLayout 的实例，然后调用 setColorSchemeResources() 方法来设置下拉刷新进度条的颜色，这里我们使用主题中的 colorPrimary 作为进度条的颜色，接着调用了 setOnRefreshListener() 方法来设置一下下拉刷新的监听器，当触发了下拉刷新操作的时候就会回调这个监听器的 onRefresh() 方法，我们在这里去处理具体的刷新逻辑就好了
        swipeRefreshLayout = findViewById(R.id.swipe_refresh);
        swipeRefreshLayout.setColorSchemeResources(R.color.colorPrimary);
        swipeRefreshLayout.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() {
            @Override
            //通常情况下，onRefresh() 方法中应该是去网络上请求最新的数据，然后再将这些数据展示出来，这里简单起见就不和网络进行交互，而是调用一个 refreshFruits() 方法进行本地刷新操作
            public void onRefresh() {
                refreshFruits();
            }
        });
    }

    // refreshFruits() 方法中先是开启了一个线程，然后将线程沉睡两秒钟，这样做是因为本地刷新操作速度非常快，如果不将线程沉睡的话，刷新立刻就结束了，从而看不到刷新的过程
    private void refreshFruits() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                //沉睡结束后使用了 runOnUiThread() 方法将线程切换回主线程，然后调用 initFruits() 方法重新生成数据，接着再调用 FruitAdapter 的 notifyDataSetChanged() 方法通知数据发生了变化，最后调用 SwipeRefreshLayout 的 setRefreshing() 方法并传入 false，用于表示刷新事件结束，并隐藏刷新进度条
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        initFruits();
                        adapter.notifyDataSetChanged();
                        swipeRefreshLayout.setRefreshing(false);
                    }
                });
            }
        }).start();
    }

    ...
    
}
```





### 可折叠式标题栏

虽然我们现在的标题栏是使用 Toolbar 来编写的，不过它看上去和传统的 ActionBar 其实没有什么两样，只不过可以响应 RecyclerView 的滚动事件来进行隐藏和显示。而 Material Design 中并没有限定标题栏必须是长这个样子的，事实上我们可以根据自己的喜好来定制标题栏的样式，我们就来实现一个可折叠式标题栏的效果，需要借助 CollapsingToolbarLayout 这个工具



#### CollapsingToolbarLayout

CollapsingToolbarLayout 是一个作用于 Toolbar 基础之上的布局，它也是由 Design Support 库提供的。 CollapsingToolbarLayout 可以让 Toolbar 的效果变得更加丰富，不仅仅是展示一个标题栏，而是能够实现非常华丽的效果

不过，CollapsingToolbarLayout 是不能独立存在的，它在设计的时候就被限定只能作为 AppBarLayout 的直接子布局来使用，而 AppBarLayout 又必须是 CoordinatorLayout 的子布局

首先我们需要一个额外的活动来作为水果的详情展示界面，右击 com.example.materialtest 包 -> New -> Activity -> Empty Activity，创建一个 FruitActivity，并将布局名指定成 activity_fruit.xml，然后开始编写水果详情展示界面的布局

由于整个布局比较复杂，这里准备采用分段编写的方式，activity_fruit.xml 中的内容主要分为两部分，一个是水果标题栏，一个是水果内容详情

```java
//首先实现标题栏部分，这里使用 CoordinatorLayout 来作为最外层布局
<android.support.design.widget.CoordinatorLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    //注意始终要定义一个 xmlns:app 的命名空间，在 Material Design 的开发中会经常用到它
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

</android.support.design.widget.CoordinatorLayout>
```

接着在 CoordinatorLayout 中嵌套一个 AppBarLayout

```java
<android.support.design.widget.CoordinatorLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    
    <android.support.design.widget.AppBarLayout
        android:id="@+id/appBar"
        android:layout_width="match_parent"
        android:layout_height="250dp">
    </android.support.design.widget.AppBarLayout>

</android.support.design.widget.CoordinatorLayout>
```

接下来在 AppBarLayout 中再嵌套一个 CollapsingToolbarLayout

```java
<android.support.design.widget.CoordinatorLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <android.support.design.widget.AppBarLayout
        android:id="@+id/appBar"
        android:layout_width="match_parent"
        android:layout_height="250dp">

        <android.support.design.widget.CollapsingToolbarLayout
            android:id="@+id/collapsing_toolbar"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            // android:theme 属性指定了一个 ThemeOverlay.AppCompat.Dark.ActionBar 的主题，其实对于这部分我们也并不陌生，因为之前在 activity_main.xml 中给 Toolbar 指定的也是这个主题，只不过这里要实现更加高级的 Toolbar 效果，因此需要将这个主题的指定提到上一层来
            android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar"
            // app:contentScrim 属性用于指定 CollapsingToolbarLayout 在趋于折叠状态以及折叠之后的背景色，其实 CollapsingToolbarLayout 在折叠之后就是一个普通的 Toolbar，那么背景色就应该是 colorPrimary
            app:contentScrim="?attr/colorPrimary"
            // app:layout_scrollFlags 其实我们也是见过的，只不过之前是给 Toolbar 指定的，现在已到外面来了，其中，scroll 表示 CollapsingToolbarLayout 会随着水果内容详情的滚动一起滚动，exitUntilCollapsed 表示当 CollapsingToolbarLayout 随着滚动完成折叠之后就保留在界面上，不再移出屏幕
            app:layout_scrollFlags="scroll|exitUntilCollapsed" >
        </android.support.design.widget.CollapsingToolbarLayout>

    </android.support.design.widget.AppBarLayout>

</android.support.design.widget.CoordinatorLayout>
```

在 CollapsingToolbarLayout 中定义标题栏的具体内容

```java
<android.support.design.widget.CoordinatorLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <android.support.design.widget.AppBarLayout
        android:id="@+id/appBar"
        android:layout_width="match_parent"
        android:layout_height="250dp">

		//在 CollapsingToolbarLayout 中定义了一个 ImageView 和 Toolbar，也就意味着，这个高级版的标题栏将是由普通的标题栏加上图片组合而成的
        <android.support.design.widget.CollapsingToolbarLayout
            android:id="@+id/collapsing_toolbar"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar"
            app:contentScrim="?attr/colorPrimary"
            app:layout_scrollFlags="scroll|exitUntilCollapsed" >
            
            <ImageView
                android:id="@+id/fruit_image_view"
                android:layout_width="match_parent"
                android:layout_height="match_parent"
                android:scaleType="centerCrop"
                // app:layout_collapseMode 用于指定当前控件在 CollapsingToolbarLayout 折叠过程中的折叠模式，其中 Toolbar 指定成 pin，表示在折叠的过程中位置始终保持不变，ImageView 指定成 parallax，表示会在折叠过程中缠身一定的错位偏移，这种模式的视觉效果会非常好
                app:layout_collapseMode="parallax" />
            
            <android.support.v7.widget.Toolbar
                android:id="@+id/toolbar"
                android:layout_width="match_parent"
                android:layout_height="?attr/actionBarSize"
                app:layout_collapseMode="pin" />
            
        </android.support.design.widget.CollapsingToolbarLayout>

    </android.support.design.widget.AppBarLayout>

</android.support.design.widget.CoordinatorLayout>
```

这样我们就将水果标题栏的界面编写完成了，下面开始编写水果内容详情部分，继续修改 activity_fruit.xml

```java
<android.support.design.widget.CoordinatorLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <android.support.design.widget.AppBarLayout
        android:id="@+id/appBar"
        android:layout_width="match_parent"
        android:layout_height="250dp">

        <android.support.design.widget.CollapsingToolbarLayout
            android:id="@+id/collapsing_toolbar"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar"
            app:contentScrim="?attr/colorPrimary"
            app:layout_scrollFlags="scroll|exitUntilCollapsed" >

            <ImageView
                android:id="@+id/fruit_image_view"
                android:layout_width="match_parent"
                android:layout_height="match_parent"
                android:scaleType="centerCrop"
                app:layout_collapseMode="parallax" />

            <android.support.v7.widget.Toolbar
                android:id="@+id/toolbar"
                android:layout_width="match_parent"
                android:layout_height="?attr/actionBarSize"
                app:layout_collapseMode="pin" />

        </android.support.design.widget.CollapsingToolbarLayout>

    </android.support.design.widget.AppBarLayout>

	//水果内容详情的最外层布局使用了一个 NestedScrollView，注意它和 AppBarLayout 是平级的，我们在第九章第二节学过了 ScrollView 用法，它允许使用滚动的方式来查看屏幕以外的数据，而 NestedScrollView 在此基础上还增加了嵌套响应滚动事件的功能，由于 CoordinatorLayout 本身已经可以响应滚动事件了，因此我们在它的内部就需要使用 NestedScrollView 或 RecyclerView 这样的布局。
    <android.support.v4.widget.NestedScrollView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        //另外这里还通过 app:layout_behavior 属性指定了一个布局行为，这和之前 RecyclerView 中的用法是一模一样的，在 NestedScrollView 中使用 app:layout_behavior 属性指定了一个布局行为，其中 appbar_scrolling_view_behavior 这个字符串也是由 Design Support 库提供的
        //另外需要注意的是，由于 NestedScrollView 现在变成了 CoordinatorLayout 的子控件，因此之前使用 app:layout_behavior 声明的布局行为现在也要移到 CoordinatorLayout 中才行
        app:layout_behavior="@string/appbar_scrolling_view_behavior" >
    </android.support.v4.widget.NestedScrollView>

</android.support.design.widget.CoordinatorLayout>
```

不管是在 ScrollView 还是 NestedScrollView，它们的内部都只允许存在一个直接子布局，因此，如果我们想要在里面放入很多东西的话，通常都会先嵌套一个 LinearLayout，然后再在 LinearLayout 中放入具体内容就可以了，例如：

```java
<android.support.v4.widget.NestedScrollView
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    app:layout_behavior="@string/appbar_scrolling_view_behavior" >
    
    <LinearLayout
        android:orientation="vertical"
        android:layout_width="match_parent"
        android:layout_height="wrap_content">
    </LinearLayout>
            
</android.support.v4.widget.NestedScrollView>
```

接下来在 LinearLayout 中放入具体的内容，这里准备使用一个 TextView 来显示水果的内容详情，并将在 TextView 放在一个卡片式布局当中

```java
<android.support.v4.widget.NestedScrollView
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    app:layout_behavior="@string/appbar_scrolling_view_behavior" >

    <LinearLayout
        android:orientation="vertical"
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

		//为了让界面更美观，CardView 和 TextView 都加了一些边距，其中 CardView 的 marginTop 加了 35dp 的边距是为了下面要编写的东西留出空间
        <android.support.v7.widget.CardView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginBottom="15dp"
            android:layout_marginLeft="15dp"
            android:layout_marginRight="15dp"
            android:layout_marginTop="35dp"
            app:cardCornerRadius="4dp" >

            <TextView
                android:id="@+id/fruit_content_text"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_margin="10dp" />

        </android.support.v7.widget.CardView>

    </LinearLayout>

</android.support.v4.widget.NestedScrollView>
```

准备在 activity_fruit.xml 中加入一个悬浮按钮表示评论作用

```java
<android.support.design.widget.CoordinatorLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    
    ...
    
    // FloatingActionButton 和 AppBarLayout 以及 NestedScrollView 是平级的
	<android.support.design.widget.FloatingActionButton
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_margin="16dp"
        android:src="@drawable/ic_comment"
        // app:layout_anchor 属性指定了一个锚点，我们将锚点设置为 AppBarLayout，这样悬浮按钮就会出现在水果标题栏的区域内，接着又使用 app:layout_anchorGravity 属性将悬浮按钮定位在标题栏区域的右下角
        app:layout_anchor="@id/appBar"
        app:layout_anchorGravity="bottom|end">
        
    </android.support.design.widget.FloatingActionButton>

</android.support.design.widget.CoordinatorLayout>
```

接下来开始编写功能逻辑，修改 FruitActivity

```java
public class FruitActivity extends AppCompatActivity {

    public static final String FRUIT_NAME = "fruit_name";

    public static final String FRUIT_IMAGE_ID = "fruit_image_id";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_fruit);
        //通过 Intent 获取到了传入的水果名和水果图片的资源 id，然后通过 findViewById() 方法获取各个控件的实例
        Intent intent = getIntent();
        String fruitName = intent.getStringExtra(FRUIT_NAME);
        int fruitImageId = intent.getIntExtra(FRUIT_IMAGE_ID, 0);
        Toolbar toolbar = findViewById(R.id.toolbar);
        CollapsingToolbarLayout collapsingToolbar = findViewById(R.id.collapsing_toolbar);
        ImageView fruitImageView = findViewById(R.id.fruit_image_view);
        TextView fruitContentText = findViewById(R.id.fruit_content_text);
        //将 Toolbar 作为 ActionBar 显示，并启用 HomeAsUpEnableed 按钮。由于 HomeAsUpEnableed 按钮的默认图标就是一个返回箭头，这正是我们所期望的，因此就不用再额外设置别的图标了
        setSupportActionBar(toolbar);
        ActionBar actionBar = getSupportActionBar();
        if (actionBar != null) {
            actionBar.setDisplayHomeAsUpEnabled(true);
        }
        //调用 CollapsingToolbarLayout 的 setTitle 方法将水果名设置成当前界面的标题，然后使用 Glide 加载传入的水果图片，并设置到标题栏的 ImageView 上
        collapsingToolbar.setTitle(fruitName);
        Glide.with(this)
                .load(fruitImageId)
                .into(fruitImageView);
        //接着需要填充水果的内容详情，这里使用了一个 generateFruitContent() 方法将水果名循环了 500 次，从而生成了一个表较长的字符串，将它设置到了 TextView 上
        String fruitContent = generateFruitContent(fruitName);
        fruitContentText.setText(fruitContent);
    }
    
    private String generateFruitContent(String fruitName) {
        StringBuilder fruitContent = new StringBuilder();
        for (int i = 0; i < 500; i++) {
            fruitContent.append(fruitName);
        }
        return fruitContent.toString();
    }
    
    //最后在 onOptionsItemSelected() 方法中处理了 HomeAsUp 按钮的点击事件，当点击了这个按钮时，就调用 finish() 方法关闭当前活动，从而返回上一个活动
    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home:
                finish();
                return true;
        }
        return super.onOptionsItemSelected(item);
    }
    
}
```

处理 RecyclerView 的点击事件，不然无法打开 FruitActivity，修改 FruitAdapter

```java
public class FruitAdapter extends RecyclerView.Adapter<FruitAdapter.ViewHolder> {

    ...
    
    @Override
    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        if (mContext == null) {
            mContext = parent.getContext();
        }
        View view = LayoutInflater.from(mContext).inflate(R.layout.fruit_item, parent, false);
        //给 CardView 注册了一个点击事件监听器，然后在点击事件中获取当前点击项的水果名和水果图片资源 id，把它们传入到 Intent 中，最后调用 startActivity() 方法启动 FruitActivity
        final ViewHolder holder = new ViewHolder(view);
        holder.cardView.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                int position = holder.getAdapterPosition();
                Fruit fruit = mFruitList.get(position);
                Intent intent = new Intent(mContext, FruitActivity.class);
                intent.putExtra(FruitActivity.FRUIT_NAME, fruit.getName());
                intent.putExtra(FruitActivity.FRUIT_IMAGE_ID, fruit.getImageId());
                mContext.startActivity(intent);
            }
        });
        return holder;
    }
	
    ...

}
```



#### 充分利用系统状态栏空间

在 Android 5.0 之前，我们是无法对状态栏的背景或颜色进行操作的，在 Android 5.0 及之后的系统中，使用背景图和状态栏融合的模式，在之前的系统使用普通模式

想要让背景图能够和系统状态栏融合，需要借助 android:fitsSystemWindows 这个属性来实现

在 CoordinatorLayout、AppBarLayout、CollapsingToolbarLayout 这种嵌套结构的布局中，将控件的 android:fitsSystemWindows 属性指定成 true，就表示该控件会出现在系统状态栏里。对应到我们的程序，那就是水果标题栏中的 ImageView 应该设置这个属性了。不过只给 ImageView 设置这个属性是没有用的，我们必须将 ImageView 布局结构中的所有父布局都设置上这个属性才可以，修改 activity_fruit.xml

```java
<android.support.design.widget.CoordinatorLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:fitsSystemWindows="true" >

    <android.support.design.widget.AppBarLayout
        android:id="@+id/appBar"
        android:layout_width="match_parent"
        android:layout_height="250dp"
        android:fitsSystemWindows="true" >

        <android.support.design.widget.CollapsingToolbarLayout
            android:id="@+id/collapsing_toolbar"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar"
            app:contentScrim="?attr/colorPrimary"
            app:layout_scrollFlags="scroll|exitUntilCollapsed"
            android:fitsSystemWindows="true" >

            <ImageView
                android:id="@+id/fruit_image_view"
                android:layout_width="match_parent"
                android:layout_height="match_parent"
                android:scaleType="centerCrop"
                app:layout_collapseMode="parallax"
                android:fitsSystemWindows="true" />
                
     ...

</android.support.design.widget.CoordinatorLayout>
```

但是即使我们将 android:fitsSystemWindows 属性都设置好了还是没有用的，因为还必须在程序的主题中将状态栏颜色指定成透明色才行

指定成透明色的方法很简单，在主题中将 android:statusBarColor 属性的值指定成 @android:color/transparent 就可以了。但问题在于，android:statusBarColor 这个属性是从 API 21 也就是 Android 5.0 开始才有的，之前的系统是无法指定这个属性的，那么，系统的差异型功能实现就要从这里开始了

右击 res 目录 -> New -> Directory，创建一个 values-v21 目录，然后右击 values-v21 目录 -> New -> Values resource file ，创建一个 styles.xml 文件

```java
//这里专门定义了一个 FruitActivityTheme 主题，它是专门给 FruitActivity 使用的
<resources>
    
    // FruitActivityTheme 的 parent 主题是 AppTheme，也就是说，它继承了 AppTheme 中的所有特性。然后我们在 FruitActivityTheme 中将状态栏的颜色指定成透明色，由于 values-v21 目录是只有 Android 5.0 及以上的系统才会去读取的，因此这么声明是没有问题的
    <style name="FruitActivityTheme" parent="AppTheme">
        <item name="android:statusBarColor">@android:color/transparent</item>
    </style>
    
</resources>
```

但是在 Android 5.0 之前的系统却无法是别 FruitActivityTheme 这个主题，因此我们还需要对 values/style.xml 文件进行修改

```java
<resources>

    <!-- Base application theme. -->
    <style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar">
        <!-- Customize your theme here. -->
        <item name="colorPrimary">@color/colorPrimary</item>
        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
        <item name="colorAccent">@color/colorAccent</item>
    </style>
    
    //可以看到这里也定义了一个 FruitActivityTheme 主题，并且 parent 主题也是 AppTheme，但是它的内部是空的，因为 Android 5.0 之前的系统是无法指定状态栏的颜色，因此这里什么都不用做就可以了
    <style name="FruitActivityTheme" parent="AppTheme">
        
    </style>

</resources>
```

最后，我们还需要让 FruitActivity 使用这个主题才可以，修改 AndroidManifest.xml

```java
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.materialtest">

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        <activity android:name=".FruitActivity"
            //使用 android:theme 属性单独给 FruitActivity 指定了 android:theme 这个主题
            android:theme="@style/FruitActivityTheme">
        </activity>
    	...
    </application>
</manifest>
```



## 基于位置的服务

基于位置的服务简称 LBS，有了 Android 系统作为载体，我们可以利用定位出的位置进行许多丰富多彩的操作

首先要清楚，基于位置服务所围绕的核心就是要先确定出用户所在的位置。通常有两种技术方式可以实现：一种是通过 GPS 定位，一种是通过网路定位。

GPS 定位的工作原理是基于手机内置的 GPS 硬件直接和卫星交互来获取当前的经纬度信息，这种定位方式精确度非常高，但缺点是只能在室外使用，室内基本无法接收到卫星的信号。

网络定位的工作原理是根据手机当前网络附近的三个基站进行测速，一次计算出手机和每个基站之间的距离，再通过三角定位确定出一个大概位置，这种定位方式精确度一般，但有点是在室内室外都可以使用。

Android 对于这两种定位方式都提供了相应的 API 支持，但国内 Google 的网络服务在国内无法使用，GPS 虽不需要网络，又只能在室外才可以使用，室内会出现无法定位的问题，因此我们可以使用国内第三方公司的 SDK，有百度、高德，本章我们学习百度在 LBS 的功能



### 申请 API Key

想要在自己的应用程序里使用百度的 LBS 功能，首先必须申请一个 API Key

SHA1 指的是打开程序时所用签名文件的 SHA1 指纹，可以通过 Android Studio 右侧工具栏 Gradle -> 项目名 -> :app -> Tasks -> android，双击 signingReport 就可以找到 SHA1 的字段



### 准备 LBS SDK

先下载百度 LBS 开方平台的 SDK

解压后会有一个 libs 目录，libs 目录下的内容又分为两部分，BaiduLBS_Android.jar 这个文件是 Java 层要使用到的，其中他子目录下的 so 文件是 Native 层要用到的。so 文件使用 C/C++ 语言进行编写，然后再用 NDK 编译出来的

把 Jar 包放在 app模块 libs 目录下是用来存放所有的 Jar 包

在 src/main 目录下右击 -> New -> Directory，创建一个 jniLibs 的目录，这里就是专门用来存放 so 文件的（即压缩包里其他所有目录）

虽然 app/build.gradle 默认将所有以 .jar 结尾的文件添加到当前项目的引用中

```java
dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])
	...
}
```

由于我们是直接将 Jar 包复制到 libs 目录下的，并没有修改 gradle 文件，因此不会弹出 Sync Now，所以记得点击 Android Studio 顶部工具栏的 Sync 按钮，不然项目将无法使用到 Jar 包中提供的任何接口

![](E:\Android笔记\第十一章笔记图片\微信截图_20190423000006.jpg)

![](E:\Android笔记\第十一章笔记图片\微信截图_20190423015610.jpg)

点击 Sync 按钮之后，libs 目录下的 jar 文件就会多出一个向右的箭头，这就表示项目已经能引用到这些 Jar 包了

![](E:\Android笔记\第十一章笔记图片\微信截图_20190423001028.jpg)



## 全局获取 Context 的技巧

我们许多操作都是在活动中进行的，而活动本身就是一个 Context 对象，但是当逻辑代码脱离 Activity 类你又恰恰需要使用 Context，你也许会为此伤脑筋

例如在第九章的最佳实践环节，我们编写了一个 HttpUtil 类，在这里将一些通用的网络操作封装了起来

```java
public class HttpUtil {

    //首先给 sendHttpRequest() 方法添加了一个 HttpCallbackListener 参数
    public static String sendHttpRequest(final String address, final HttpCallbackListener listener) {
        //在方法的内部开启一个子线程，然后在子线程里去执行具体的网络操作
        new Thread(new Runnable() {
            @Override
            public void run() {
                HttpURLConnection connection = null;
                try {
                    URL url = new URL(address);
                    connection = (HttpURLConnection) url.openConnection();
                    connection.setRequestMethod("GET");
                    connection.setConnectTimeout(8000);
                    connection.setReadTimeout(8000);
                    connection.setDoInput(true);
                    connection.setDoOutput(true);
                    InputStream in = connection.getInputStream();
                    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
                    StringBuilder response = new StringBuilder();
                    String line;
                    while ((line = reader.readLine()) != null) {
                        response.append(line);
                    }
                    //子线程中是无法通过 return 语句来返回数据的，因此我们将服务器响应的数据传入了 HttpCallbackListener 的 onFinish() 方法中
                    if (listener != null) {
                        //回调 onFinish() 方法
                        listener.onFinish(response.toString());
                    }
                } catch (Exception e) {
                    //如果出现了异常，就将异常原因传入到 onError() 方法中
                    if (listener != null) {
                        //回调 onError() 方法
                        listener.onError(e);
                    }
                } finally {
                    if (connection != null) {
                        connection.disconnect();
                    }
                }
            }
        }).start();
    }

}
```

这里使用 sendHttpRequest() 方法发送 HTTP 请求显然是没有问题的，并且我们还可以在回调方法中处理服务器返回的数据。但现在我们想对 sendHttpRequest() 方法进行一些优化，当检测到网络不存在的时候就给用户一个 Toast 提示，并且不再执行后面的代码。看似一个挺简单的功能，可是却存在一个问题，弹出的 Toast 需要一个 Context 参数，而我们 HttpUtil 类中显然是获取不到 Context 对象的，这该怎么办呢？

其实想要快速解决这个问题的方法也很简单，大不了在 sendHttpRequest() 方法中添加一个 Context 参数不就行了吗，于是可以将 HttpUtil 中的代码进行如下修改：

```java
public class HttpUtil{
    public static String sendHttpRequest(final Context context, final String address, final HttpCallbackListener listener) {
        if (!isNetworkAvailable(){
            Toast.makeText(context, "network is unavailable", Toast.LENGTH_SHORT).show();
            return;
        })
        new Thread(new Runnable() {
            @Override
            public void run() {
                ...
            }
        }).start();
    }
    private static boolean isNetworkAvailable() {
        ...
    }
}
```

可以看到，这里在方法中添加了一个 Context 参数，并且假设有一个 isNetworkAvailable() 方法用于判断当前网络是否可用，如果不可用的话就弹出 Toast 提示，并将方法 return 掉。

虽说这也确实是一种解决方案，但是却有点推卸责任的嫌疑，因为我们将获取 Context 的任务转移给了 sendHttpRequest() 方法的调用方，至于调用方能不能得到 Context 对象，那就不是我们需要考虑的问题了

由此可以看出，在某些情况下，获取 Context 并非是一件那么容易的事，有时候还是挺伤脑筋的。不过别担心，下面这种技巧可以让你在项目的任何地方都能够轻松地获取到 Context

**Android 提供了一个 Application 类，每当应用程序启动的时候，系统就自动将这个类进行初始化，而我们可以定制一个自己的 Application 类，以便于管理程序内一些全局的状态信息，比如说全局 Context**

定制自己的一个 Application，首先创建一个 MyApplication 类继承 Application

```java
public class MyApplication extends Applicaiton {

	private static Context context;
    
    //重写了父类的 onCreate() 方法，并通过调用 getApplicationContext() 方法得到了一个应用程序级别的 Context
    @Override
    public void onCreate() {
        context = getApplicaitonContext();
    }
    
    //然后又提供了一个静态的 getContext() 方法，在这里将刚才获取到的 Context 进行返回
    public static Context getContext() {
        return context;
    }
    
}
```

接下来我们需要告知系统，当程序启动的时候应该初始化 MyApplication 类，而不是默认的 Appliication 类。这一步很简单，在 AndroidManifest.xml 文件的 <application> 标签下进行指定就可以了

```java
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.networktest">

    <uses-permission android:name="android.permission.INTERNET" />

    <application
    	//注意这里在指定 MyApplication 的时候一定要加上完整的包名，不然系统就无法找到这个类
        android:name="com.example.networktest.MyApplication"
        ...>
    </application>

</manifest>
```

这样我们就已经实现了一种全局获取 Context 的机制，之后不管你想在项目的任何地方使用 Context，只需要调用一下 MyApplication.getContext() 就可以了

对 sendHttpRequest() 代码进行优化：

```java
public class HttpUtil{
    public static String sendHttpRequest(final String address, final HttpCallbackListener listener) {
        if (!isNetworkAvailable(){
            Toast.makeText(MyApplication.getContext(), "network is unavailable", Toast.LENGTH_SHORT).show();
            return;
        })
        new Thread(new Runnable() {
            @Override
            public void run() {
                ...
            }
        }).start();
    }
    private static boolean isNetworkAvailable() {
        ...
    }
}
```

可以看到，sendHttpRequest() 方法不需要再通过传参的方式来得到 Context 对象，而是调用一下 MyApplication.getContext() 方法就可以了

我们再回顾一下第六章第五小节学过的内容，当时为了让 LitePal 可以正常工作，要求必须在 AndroidManifest.xml 中配置如下内容：

```java
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.litepaltest">

    <application
    	//将项目的配置为 org.litepal.LitePalApplication，这样才能让 LitePal 的所有功能都可以正常工作
        android:name="org.litepal.LitePalApplication"
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">

	    ...

    </application>

</manifest>
```

其实道理也是一样的，因为经过这样的配置之后，LitePal 就能在内部自动获取到 Context 了

不过你可能会产生疑问，如果我们已经配置过了自己的 Application 怎么办？这样岂不是和 LitePalApplication 冲突了？没错，任何一个项目都只能配置一个 Application，对于这种情况，LitePal 提供了很简单的解决方案，那就是在我们自己的 Application 中去调用 LitePal 的初始化方法就可以了，代码如下：

```java
public class MyApplication extends Applicaiton {

	private static Context context;
    
    @Override
    public void onCreate() {
        context = getApplicaitonContext();
        //使用这种写法，就相当于我们把全局的 Context 对象通过参数传递给了 LitePal，效果和在 AndroidManifest.xml 中配置 LitePalApplication 是一模一样的
        LitePal.initialize(context);
    }
    
    public static Context getContext() {
        return context;
    }
    
}
```





## 使用 Intent 传递对象

Intent 的用法你已经比较熟悉了，我们可以借助它来启动活动、发送广播、启动服务等，在进行上述操作的时候，我们还可以在 Intent 中添加一些数据，以达到传值的效果，比如在 FirstActivity 中添加如下代码：

```java
Intent intent = new Intent(FirstActivity.this, SecondActivity.class);
intent.putExtra("string_data", "hello");
intent.putExtra("int_data", 100);
startActivity(intent);
```

这里调用了 Intent 的 putExtra() 方法来添加要传递的数据，之后在 SecondActivity 中就可以得到这些值了，代码如下：

```java
getIntent().getStringExtra("string_data");
getIntent().getIntExtra("int_data", 0);
```

其中 putEXtra() 方法中所支持的数据类型是有限的，虽然常用的一些数据类型它都会支持，但是当你想去传递一些自定义对象的时候，就会发现无从下手，接下来就来学习一下 Intent 来传递的技巧



### Serializable 方式

使用 Intent 来传递对象的方式通常有两种：Serializable 和 Parcelable

Serializable 是序列化的意思，表示将一个对象转换成可存储或可传输的状态，序列化的对象可以在网络上进行传输，也可以存储到本地。至于序列化的方法也很简单，只需要让一个类去实现 Serializable 这个接口就可以了

比如有一个 Person 类，其中包含了 name 和 age 这两个字段，想要序列化就可以这样写：

```java
//其中，get 、set 方法都是用于赋值和读取字段数据的，最重要的部分是在第一行，这里让 Person 类去实现了 Serializable 接口，这样所有的 Person 对象都是可序列化了
public class Person implements Serializable{
    
    private String name;
    
    private int age;
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public int getAge() {
        return age;
    }
    
    public void setAge(int age) {
        this.age = age;
    }
    
}
```

接下来在 FirstActivity 中的写法就非常简单：

```java
Person person = new Person();
person.setName("Tom");
person.setAge(20);
Intent initent = new Intent(FirstActivity.this, SecondActivity.class);
intent.putExtra("person_data", person);
startActivity(intent);
```

首先创建一个 Person 的实例，然后就直接将它传入到了 putExtra() 方法中，由于 Person 类实现了 Serializable 接口所以才可以这么写

接下来在 SecondActivity 中获取这个对象也很简单：

```java
Person person = (Person) getIntent().getSerialzableExtra("person_data");
```

这里调用了 getSerialzableExtra() 方法来获取通过参数传递过来的序列化对象，接着再将它向下转型成 Person 对象，这样我们就成功实现了使用 Intent 来传递对象的功能了



### Parcelable 方式i

Parcelable 方式的实现原理是将一个完整的对象进行分解，而分解后的每一部分都是 Intent 所支持的数据类型，这样也就实现传递对象的功能了

修改 Person

```java
//首先让 Person 类去实现了 Parcelable 接口，这样就必须重写 describeContents() 和 writeToParcel() 这两个方法
public class Person implements Parcelable{
    
    private String name;
    
    private int age;
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public int getAge() {
        return age;
    }
    
    public void setAge(int age) {
        this.age = age;
    }
    
    // describeContents() 方法直接返回 0 就好了
    @Override
    public int describeContents() {
        return 0;
    }
    
    // writeToParcel() 方法中我们需要调用 Parcel 的 writeXXX() 方法，将 Person 类中的字段一一写出，注意字符串型数据就调用 writeString() 方法，整型数据就调用 writeInt() 方法，以此类推
    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeString(name);		//写出 name
        dest.writeInt(age);		    //写出 age
    }
    
    //除此之外，我们还必须在 Person 类中提供一个名为 CREATOR 的常量，这里创建了一个 Parcelable.Creator 接口的一个实现，并将泛型指定为 Person，接着需要重写 createFromParcel() 和 newArray() 这两个方法
    @Override
    public static final Parcelable.Creator<Person> CREATOR = new Parcelable.Creator<Person>() {
        
        //在 createFromParcel() 方法中我们要去读取刚才写出的 name 和 age 字段，并创建一个 Person 对象进行返回，其中 name 和 age 都是调用 Parcel 的 readXXX() 方法读取到的
        //注意，这里读取的顺序一定要和刚才写出的顺序完全相同
        @Override
        public Person createFromParcel(Parcel source) {
            Person person = new Person();
            person.name = source.readString();			//读取 name
            person.age = source.readInt();				//读取 age
            return person;
        }
        
        // new 出一个 Person 数组，并使用方法中传入的 size 作为数组大小就可以了
        @Override
        public Person[] newArray(int size) {
            return new  Person[size];
        }
        
    };
    
}
```

接下来在 FirstActivity 中我们仍然可以使用相同的代码来传递 Person 对象

```java
Person person = new Person();
person.setName("Tom");
person.setAge(20);
Intent initent = new Intent(FirstActivity.this, SecondActivity.class);
intent.putExtra("person_data", person);
startActivity(intent);
```

只不过在 SecondActivity 中获取对象的时候需要稍加改动

```java
Person person = (Person) getIntent().getParcelableExtra("person_data");
```





## 调试 Android 程序

调试允许我们逐行地执行代码，并可以实时观察内存中的数据，从而能够比较轻易地查出问题的原因

在要调试的代码行左边点击一下就可以添加断点，如果想取消，再次点击一下就可以了。接着点击工具栏中运行按钮旁边的 Debug 按钮，就会使用调试模式来启动程序，等到程序运行起来的时候，首先会看到一个提示框，这个框很快就会自动消失，当加了断点的程序运行到的时候，这时 Android Studio 就会自动打开 Debug 窗口，接下来每按一次 F8 键，代码就回向下执行一行，并且通过 Variables 视图还可以看到内存中的数据。调试完之后点击 Debug 窗口中的 Stop 按钮来结束调试即可

这种调试方式虽然完全可以正常工作，但是在调教模式下，程序的运行效率将会大大地降低，如果你的断点在比较靠后的位置，需要执行很多的操作才能运行到这个断点，那么前面这些操作就都会有一些卡顿的感觉

Android 还提供了另外一种调试的方式，可以让程序随时进入到调试模式，这次不需要选择调试模式来启动程序了，就是用正常的方式来启动程序，由于现在不是在调试模式下，程序运行速度比较快，然后点击 Android Studio 顶部的工具栏的 Attach debugger to process 按钮，此时会弹出一个选择提示框，选择我们当前程序的进程点击 OK，这会这个进程就进入到了调试模式了，当执行到响应的代码后，之后的流程就都是相同的了





## 创建定时任务

Android 中的定时任务一般有两种实现方式，一种是使用 Java API 里提供的 Timer 类，一种是使用 Android 的 Alarm 机制

这两种方式在多数情况下都能实现类似的效果，但 Timer 有一个明显的短板，它并不太适用于那些需要长期在后台运行的定时任务。我们都知道，为了能让电池更加耐用，每种手机都会有自己的休眠策略，Android 手机就会在长时间不操作的情况下自动让 CPU 进入到睡眠状态，这就有可能导致 Timer 中的定时任务无法正常运行。而 Alarm 则具有唤醒 CPU 的功能，它可以保证在大多数情况下需要执行定时任务的时候 CPU 都能正常工作。需要注意，这里唤醒 CPU 和唤醒屏幕完全不是一个概念，千万不要混淆



### Alarm 机制

Alarm 机制的用法主要是借助了 AlarmManager 类来实现的，这个类和 NotificationManager 有点类似，都是通过调用 Context 的 getSystemService() 方法来获取实例的，只是这里需要传入的参数是 Context.ALARM_SERVICE。因此，获取一个 AlarmManager 的实例就可以写成：

```java
AlarmManager manager = (AlarmManager) getSystemService(Context.ALARM_SERVICE);
```

接下来使用 se() 方法就可以设置一个定时任务了。比如你想要设定一个任务在 10 秒钟后执行：

```java
long triggerAtTime = SystemClock.elapsedRealtime() + 10 * 1000;
manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtTime, pendigIntent);
```

set() 方法中需要传入 3 个参数，第一个参数是一个整型参数，用于指定 AlarmManager 的工作类型，有 4 种值可以选，分别是 ELAPSED_REALTIME、ELAPSED_REALTIME_WAKEUP、RTC 和 RTC_WAKEUP

- ELAPSED_REALTIME：表示让定时任务的触发时间从系统开机开始算起，但不会唤醒 CPU
- ELAPSED_REALTIME_WAKEUP：同样表示让定时任务的触发时间从系统开机开始算起，但会唤醒 CPU
- RTC：表示让定时任务的触发时间从 1970 年 1 月 1 日 0 点开始算起，但不会唤醒 CPU
- RTC_WAKEUP：同样表示让定时任务的出发时间从 1970 年 1 月 1 日 0 点开始算起，但会唤醒 CPU

使用 SystemClock.elapsedRealtime() 方法可以获取到系统开机至今所经历时间的毫秒数，使用 System.currentTimeMillis() 方法可以获取到 1970 年 1 月 1 日 0 点至今所经历时间的毫秒数

第二个参数就是定时任务触发的时间，以毫秒为单位，传入的时间要和第一个参数所使用的时间要一致

第三个参数是一个 PendingIntent，这里我们一般会调用 getService() 方法或者 getBroadcast() 方法来获取一个能够执行服务或广播的 PendingIntent。这样当定时任务被触发的时候，服务的 onStartCommand() 方法或广播接收器的 onReceive() 方法就可以得到执行

了解完 set() 方法的每个参数之后，你应该也能想到，设定一个任务在 10 秒钟后执行也可以写成：

```java
long triggerAtTime = System.currentTimeMillis() + 10 * 1000;
manager.set(AlarmManager.RTC_WAKEUP, triggerAtTime, pendingIntent);
```

那么，如果我们要实现一个长时间在后台运行的服务该怎么做呢？其实很简单，首先新建一个普通的服务，比如把它取名交 LongRunningService，然后将触发定时任务的代码写到 onStartCommand() 方法中

```java
public class LongRunningService extends Service {
    
    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }
    
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        //先在 onStartCommand() 方法中开启一个子线程
        new Thread(new Runnable() {
            @Override
            public void run() {
                //在这里执行具体的操作逻辑
            }
        }).start();
        //创建线程之后的代码就是我们刚刚讲解的 Alarm 机制的用法，先是获取到了 AlarmManager 的实例，然后定义任务的触发时间为一小时后，再使用 PendingIntent 指定处理定时任务的服务为 LongRunningService，最后调用 set() 方法完成设定
        AlarmManager manager = (AlarmManager) getSystemService(ALARM_SERVICE);
        int anHout = 60 * 60 * 1000;//这是一个小时的毫秒数
        long triggerAtTime = SystemClock.elapsedRealtime() + anHour;
        Intent i = new Intent(this, LongRunningService.class);
        PendingIntent pi = PendingIntent.getService(this, 0, i, 0);
        manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtTime, pi);
        return super.onStartCommand(intent, flags, startId);        
    }
        
}
```

这样我们就将一个长时间在后台定时运行的服务成功实现了，因为一旦启动了 LongRunningService，就会在 onStartCommand() 方法里设定一个定时任务，这样一小时后将会再次启动 LongRunningService，从而形成了一个永久的循环，保证 LongRunningService 的 onStartCommand() 方法可以每隔一个小时就执行一次

最后，只需要在你想要启动定时服务的时候调用如下代码即可：

```java
Intent intent = new Intent(context, LongRunningService.class);
context.startService(intent);
```

另外需要注意的是，从 Android 4.4 开始，Alarm 任务的触发时间将会变得不准确，有可能会延迟一段时间后任务才能得到执行，这并不是 bug，而是系统在耗电性方面进行的优化。系统会自动检测目前有多少 Alarm 任务存在，然后将触发时间相近的几个任务放在一起执行，这就可以大幅度地减少 CPU 被唤醒的次数，从而有效延长电池的使用时间

当然，如果你要求 Alarm 任务的执行时间必须准确无误，Android 仍然提供了解决方案，使用 AlarmManager 的 setExact() 方法来替代 set() 方法，就基本可以保证任务能够准时执行了



### Doze 模式

在 Android 6.0 系统中，谷歌加入了一个全新的 Doze 模式，从而可以及大幅度地延长电池的使用寿命

首先看一下到底什么是 Doze 模式，当用户的设备是 Android 6.0 或以上系统时，如果该设备未插接电源，处于静止状态（Android 7.0 中删除了这一条件），且屏幕关闭了一段时间之后，就会进入 Doze 模式，在 Doze 模式下，系统会对 CPU 、网络、Alarm 等活动进行限制，从而延长了电池的使用寿命

当然，系统并不会一直处于 Doze 模式，而是会间歇性地退出 Doze 模式一小段时间，在这段时间中，应用就可以去完成他们的同步操作、Alarm 任务等等

随着设备进入 Doze 模式的时间越长，间歇性地退出 Doze 模式的时间间隔也会越长，因为如果设备长时间不适用的话，是没必要频繁退出 Doze 模式来执行同步等操作的

下面具体看下 Doze 模式下有哪些功能会受到限制

- 网络访问被禁止
- 系统忽略唤醒 CPU 或者屏幕操作
- 系统不再执行 WiFi 扫描
- 系统不再执行同步服务
- Alarm 任务将会在下次退出 Doze 模式的时候执行

注意其中的最后一条，也就是说在 Doze 模式下，我们的 Alarm 任务将会变得不准时，当然，这在大多数的情况下是合理的，因为只有当用户长时间不适用手机的时候才会进入 Doze 模式，通常在这种情况下对 Alarm 任务的准时性要求并没有那么高

不过，如果你真的有非常特殊的需求，要求 Alarm 任务即在 Doze 模式下也必须正常执行，Android 还是提供了解决方案，调用 AlarmManager 的 setAndAllowWhileIdle() 或 setExatAndAllowWhileIdle() 方法就能让定时任务即使在 Doze 模式下也能正常执行了，这两个方法之间的区别和 set() 、setExact() 方法之间的区别是一样的





## 多窗口模式编程

Android 7.0 引入了一个非常有特色的功能——多窗口模式，它允许我们在同一个屏幕中同时打开两个应用程序



### 进入多窗口模式

手机进入后台任务切换界面就可以看到进入多窗口模式的功能了

在多窗口模式下，整个应用的界面会缩小很多，那么编写程序时就应该多考虑使用 match_parent 属性、RecyclerView 、ListView、ScrollView 等控件来让应用的界面能够更好地适配各种不同尺寸的屏幕，尽量不要出现屏幕尺寸变化过大时界面就无法正常显示的情况



### 多窗口模式下的生命周期

其实多窗口模式并不会改变活动原有的生命周期，只是会将用户最近交互过的那个活动设置为运行状态，而将多窗口模式下另外一个可见的活动设置为暂停状态。如果这时用户又去和暂停的活动进行交互，那么该活动就变成了运行状态，之前处于运行状态的活动变成暂停状态

为了理解，首先打开 MaterialTest 项目，修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    private static final String TAG = "MaterialTest";

    ...
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Log.d(TAG, "onCreate: ");
		...
    }
    
    ...
    
    @Override
    protected void onStart() {
        super.onStart();
        Log.d(TAG, "onStart: ");
    }
    
    @Override
    protected void onResume() {
        super.onResume();
        Log.d(TAG, "onResume: ");
    }
    
    @Override
    protected void onPause() {
        super.onPause();
        Log.d(TAG, "onPause: ");
    }
    
    @Override
    protected void onStop() {
        super.onStop();
        Log.d(TAG, "onStop: ");
    }
    
    @Override
    protected void onDestroy() {
        super.onDestroy();
        Log.d(TAG, "onDestroy: ");
    }
    
    @Override
    protected void onRestart() {
        super.onRestart();
        Log.d(TAG, "onRestart: ");
    }
    
}
```

在 Activity 的 7 个生命周期回调方法中分别打印了一句日志

然后点击 Android Studio 导航栏上的 File -> Open Recent -> LBSTest ，重新打开 LBSTest 项目，修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    private static final String TAG = "LBSTest";

    ...

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Log.d(TAG, "onCreate: ");
		...
    }

    @Override
    protected void onResume() {
        super.onResume();
        Log.d(TAG, "onResume: ");
        mapView.onResume();
    }

    @Override
    protected void onPause() {
        super.onPause();
        Log.d(TAG, "onPause: ");
        mapView.onPause();
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        Log.d(TAG, "onDestroy: ");
        mLocationClient.stop();
        mapView.onDestroy();
    }

    @Override
    protected void onStart() {
        super.onStart();
        Log.d(TAG, "onStart: ");
    }


    @Override
    protected void onStop() {
        super.onStop();
        Log.d(TAG, "onStop: ");
    }


    @Override
    protected void onRestart() {
        super.onRestart();
        Log.d(TAG, "onRestart: ");
    }

	...

}
```

同样也是在 Activity 的 7 个生命周期回调方法中分别打印了一句日志，注意这两处日志的 TAG 是不一样的以方便我们区分

了解了多窗口模式下活动的生命周期规则，那么我们在编写程序的时候，就可以将一些关键性的点考虑进去了。比如说，在多窗口模式下，用户仍然可以看到处于暂停状态的应用，那么像视频播放器之类的应用在此时就应该能继续播放视频才对。因此，我们最好不要在活动的 onPause() 方法中去处理视频播放器的暂停逻辑，而是应该在 onStop() 方法中去处理，并且在 onStart() 方法恢复视频的播放

另外，针对于进入多窗口模式时活动会被重新创建，如果你想改变这一默认行为，可以在 AndroidManifest.xml 中对活动进行如下配置：

```java
	    <activity
            android:name=".MainActivity"
            android:label="Fruits"
            //加入了这行配置之后，不管是进入多窗口模式还是横屏切换，活动都不会被重新创建，而是会将屏幕发生变化的事件通知到 Activity 的 onConfigurationChanged() 方法当中。因此，如果你想在屏幕发生变化的时候进行相应的逻辑处理，那么在活动中重写 onConfigurationChanged() 方法即可
            android:configChanges="orientation|keyboardHidden|screenSize|screenLayout">
            ...
        </activity>
```



### 禁用多窗口模式

禁用多窗口模式非常简单，只需要在 AndroidManifest.xml 的 <application> 或 <activity> 标签中加入如下属性即可：

```java
android:resizeableActivity=["true" | "false"]
```

其中 true 表示应用支持多窗模式，false 表示应用不支持多窗口模式，如果不配置这个属性，那么默认值为 true

现在我们将 MaterialTest 程序设置为不支持多窗口模式：

```java
<application
        ...
        android:resizeableActivity="false">
</application>
```

虽说 android:resizeableActivity 这个属性的用法很简单，但是这个属性只有当项目的 targetSkdVersion 指定成 24 或者更高的时候才会有用，否则这个属性是无效的。比如：如果当项目的 targetSdkVersion 指定成 23，这个时候进入多窗口模式，虽说界面依旧弹出一个 Toast 提示，但还是进入了多窗口模式，因为有很多老项目他们的 targetSdkVersion 都没有指定到 24，针对这种情况，还有一种解决方案，Android 规定，如果项目指定的 targetSdkVersion 低于 24，并且活动是不允许横屏切换的，那么该应用也将不支持多窗口模式了

默认情况下，我们的应用都是可以随着手机的旋转自由地横竖屏切换，如果想要让应用不允许横竖屏切换，那么就需要在 AndroidManifest.xml 的 <activity> 标签中加入：

```java
android:screenOrientation=["portrait" | "landscape"]
```

portrait：表示活动只支持竖屏

landscape：表示活动只支持横屏

当然 android:screenOrientation 属性中还有很多其他可选值





## Lambda 表达式

Java 8 中着实引入了一些非常有特色功能，如 Lamdba 表达式、stream API 、接口默认实现，等等

stream API 和接口默认实现等新特性都只支持 Android 7.0 及以上的系统，而 Lamdba 表达式最低兼容到 Android 2.3 系统，基本上可以算是覆盖所有的 Android 手机

Lambda  表达式本质上是一种匿名方法，它既没有方法名，也即没有访问修饰符和返回值类型，使用它来编写代码将会更加简洁，也更加易读

如果想使用 Lambda，首先我们需要在 app/build.gradle 中添加如下配置：

```java
android {
	...
	defaultConfig {
		...
		jackOptions.enabled = true
	}
	compileOptions {
		sourceCompatibility JavaVersion.VERSION_1_8
		targetCompatibility JavaVersion.VERSION_1_8
	}
	...
}
```

之后就可以使用 Lambda 表达式来编写代码，比如传统情况下开启一个线程的写法如下：

```java
new Thread(new Runnable() {
	@Override
	public void run() {
		//处理具体的逻辑
	}
}) .start();
```

而是用 Lambda 表达式则可以这样写：

```java
new Thread(() -> {
	//处理具体逻辑
}).start();
```

Lambda 表达式的写法明显要更加精简

之所以可以这么写，是因为 Thread 类的构造函数接收的参数是一个 Runnable 接口，并且该接口中只有一个待实现方法

查看一下 Runnable 接口的源码：

```java
public interface Runnable {
    /**
     * When an object implementing interface <code>Runnable</code> is used
     * to create a thread, starting the thread causes the object's
     * <code>run</code> method to be called in that separately executing
     * thread.
     * <p>
     * The general contract of the method <code>run</code> is that it may
     * take any action whatsoever.
     *
     * @see     java.lang.Thread#run()
     */
    public abstract void run();
}
```

所以，凡是只有一种待实现方法的接口，都可以使用 Lambda 表达式的写法，比如通常创建一个类似于上述接口的匿名类实现需要这样写：

```java
Runnable runnable = new Runnable() {
	@Override
	public void run() {
		//添加具体的实现
	}
}；
```

有了 Lambda 之后：

```java
Runnable runnable1 = () -> {
	//添加具体的实现
};
```

了解了 Lambda 之后我们尝试自定义一个接口，然后在使用 Lambda 表达式的方式进行实现

新建一个接口 MyListener

```java
public interface MyListener {
	String doSomething(String a, int b);
}
```

MyListener 接口中也只有一个待实现方法，这和 Runnable 接口的结构是基本一致的，唯一不同的是，MyListener 中的 doSomething() 方法是有参数并且有返回值的，那么我们就来看一看这种情况下该如何使用 Lambda 表达式进行实现

其实这种写法也是比较相似的，使用 Lambda 表达式创建 MyListener 接口的匿名实现写法如下：

```java
MyListener listener = (String a, int b) -> {
	String result = a + b;
	return result;
}
```

doSomething() 方法的参数直接写在括号里面就可以了，而返回值则仍然像往常一样，写在具体实现的最后一项既可

另外 Java 还可以根据上下文自动推断出 Lambda 表达式中的参数类型，因此上面的代码也可以简化成：

```java
MyListener listener = (a, b) -> {
	String result = a + b;
	return result;
}
```

Java 会自动推断出参数 a 是 String 类型，参数 b 是 int 类型，从而使得我们的代码变得更加精简了

举个具体的例子，比如现在有一个方法接收 MyListener 参数的：

```java
public void hello(MyListener listener) {
	String a = "Hello Lambda";
	int b = 1024;
	String result = listener.doSomething(a, b);
	Log.d("TAG", result);
}  
```

在调用 hello() 方法的时候就可以这样写：

```java
hello((a, b) -> {
	String result = a + b;
	return result;
});
```

那么 doSomething() 方法就会将 a 和 b 两个参数进行相加，从而最终的打印结果就会是 "Hello Lambda2024"

Android 中其实只要是符合接口中只有一个待实现方法这个规则的功能，都是可以使用 Lambda 表达式来编写的

除了刚才举例说明的开启子线程之外，还有像设置点击事件的功能也是非常适合使用 Lambda 的，传统用法：

```java
Button button = findViewById(R.id.button);
button.setOnClickListener(new View.OnClickListener() {
	@Override
	public void onClick(View v) {
		//处理点击事件
	}
})；
```

使用 Lambda 表达式：

```java
Button button = findViewById(R.id.button);
button.setOnClickListener((v) -> {
	//处理点击事件
})；
```

另外，当接口的实现方法有且只有一个参数的时候，我们还可以进一步简化，将参数外面的括号去掉

```java
Button button = findViewById(R.id.button);
button.setOnClickListener(v -> {
	//处理点击事件
});
```







## 生成正式签名的 APK 文件

APK 文件只有签名后才可以在 Android 系统上安装。Android Studio 使用了一个默认的 keystore 文件帮我们自动进行了签名，点击 Android Studio 右侧工具栏的 Gradle -> 项目名 -> :app -> Tasks -> android，双击 signingReport，也就是说我们通过 Android Studio 来运行的程序都是使用了这个 debug.keystore 文件来签名的



### 使用 Android Studio 生成

点击 Android Studio 导航栏的 build -> Generate Signed APK，输入操作系统密码后点击 Create new，在 Validity 那一栏填写的是 keystore 文件的有效时长，单位是年



### 使用 Gradle 生成

编辑配置 app/build.gradle

```java
android {
    compileSdkVersion 28
    defaultConfig {
        applicationId "com.coolweather.android"
        minSdkVersion 15
        targetSdkVersion 28
        versionCode 1
        versionName "1.0"
    }
    //在 android 闭包中添加一个 signingConfigs 闭包，然后在 signingConfigs 比包中又添加了一个 config 闭包，接着在 config 闭包中配置 keystore 文件的各种信息
    signingConfigs {
        config {
            //用于指定 keystore 文件的位置
            storeFile file('D:/Android/aNaN/aNaN.jks')
            //用于指定密码
            storePassword '123456'
            //用于指定别名
            keyAlias 'aNaNdev'
            //用于指定别名密码
            keyPassword '123456'
        }
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
            //在 buildTypes 下面的 release 比包中应用了刚才添加的签名配置，这样当生成正式版 APK 文件的时候就会自动使用我们刚才配置的签名信息来进行签名了
            signingConfig signingConfigs.config
        }
    }
}
```

点击右侧工具栏的 Gradle -> 项目名 -> :app -> Tasks -> build

其中 assembleDebug 用于生成测试版的 APK 文件，assembleRelease 用于生成正式版的 APK 文件，assemble 用于生成测试版和正式版的 APK 文件，在生成 APK 文件之前，要先双击 clean 这个 Task 来清理一下当前项目，然后双击 assembleRelease

目前 keystore 文件的所有信息都是以明文的形式直接配置在 build.gradle 中的，这样不太安全，Android 推荐的做法是将这类敏感的数据配置在一个独立的文件里面，然后再在 build.gradle 中去读取这些数据

下面我们按照这种方式实现。Android Studio 项目的的根目录下有一个 gradle.properties 文件，它是专门来配置全局键值对数据的，我们在 gradle.properties 文件中添加：

```java
KEY_PATH=D:/Android/aNaN/aNaN.jks
KEY_PASS=123456
ALIAS_NAME=aNaNdev
ALIAS_PASS=123456
```

编辑 app/build.gradle

```java
signingConfigs {
    config {
        storeFile file(KEY_PATH)
        storePassword KEY_PASS
        keyAlias ALIAS_NAME
        keyPassword ALIAS_PASS
    }
}
```



### 生成多渠道 APK 文件

修改 app/build.gradle

```java
android {
    compileSdkVersion 28
    defaultConfig {
        applicationId "com.coolweather.android"
        minSdkVersion 15
        targetSdkVersion 28
        versionCode 1
        versionName "1.0"
    }
    //添加了一个 productFlavors 闭包，然后在比包中添加所有的渠道配置就可以了
    //注意，Gradle 中的配置规定不能以数字开头，因此这里将 360 的渠道名配置成了 qihoo
    //渠道名的闭包中可以复写 defaultConfig 中的任何一个属性，比如这里将 applicationId 属性进行了复写，最终生成的渠道 APK 文件的报名也将各不相同
    productFlavors {
        qihoo {
            applicationId "com.coolweather.android.qihoo"
        }
        baidu {
            applicationId "com.coolweather.android.baidu"
        }
    }
	...
}
```

在 app/src 目录下（mian 的平级目录）新建一个 baidu 目录，然后在 baidu 目录下再新建 java 和 res 这两个目录。如需复写 AndroidManifest.xml 文件就在 baidu 目录下新建一个该文件