# 第十章：后台默默的劳动者——探究服务









## 服务是什么

服务（Server）是 Android 中实现程序后台运行的解决方案，它非常适合去执行那些不需要和用户交互而且还需要长期运行的任务。服务的运行不依赖任何用户界面，即使程序被切换到后台，或者用户打开了另外一个应用程序，服务仍然能够保持正常运行。

不过需要注意的是，服务并不是运行在一个独立的进程当中，而是依赖于常见服务时所在的应用程序进程。当某个应用程序进程被杀掉时，所有依赖于进程的服务也会停止运行。

另外，也不要被服务的后台概念所迷惑，实际上服务并不会自动开启线程，所有的代码都是默认运行在主线程当中的。也就是说，我们需要在服务的内部手动创建子线程，并在这里执行具体的任务，否则就有可能出现主线程被阻塞的情况。









## Android 多线程编程

当我们需要执行一些耗时操作的时候，需要将这类操作放在子线程里去运行，不然会导致主线程被阻塞住，从而影响用户的正常使用





### 线程的基本用法

定义一个线程只需要新建一个类继承自 Thread，然后重写父类的 run() 方法，并在里面编写耗时逻辑即可

```java
class MyThread extends Thread {
    @Override
    public void run() {
        //处理具体的逻辑
    }
}
```





启动这个线程只需要 new 出 MyThread 的实例，然后调用它的 start() 方法，这样 run() 方法中的代码就会在子线程当中运行

```java
new  MyThread().start();
```









使用继承的方式耦合性有点高，更多的时候我们都会选择使用实现 Runnable 接口的方式来定义一个线程

```java
class MyThread implements Runnable {
    @Override
    public void run() {
        //处理具体的逻辑
    }
}
```





如果使用了上面这种写法，启动线程的方法也需要进行相应的改变：

```java
MyThread myThread = new MyThread();
//Thread 的构造函数接收一个 Runnable 参数，而我们 new 出来的 MyThread 正是一个是实现了 Runnable 接口的对象，所以可以直接将它传入到 Thread 的构造函数里，接着调用 Trhead 的 start() 方法，run() 方法中的代码就会在子线程当中运行
new Thread(myThread).start();
```





如果不想专门定义一个类去实现 Runnable 接口，也可以使用匿名类的方式，这种写法更为常见

```java
new Thread(new Runnable() {
    @Override
    public void run() {
        //处理具体的逻辑
    }
});
```





### 在子线程中更新 UI

和许多其它的 GUI 库一样，Android 的 UI 也是线程不安全的，如果想要更新应用程序里的元素，则必须在主线程中进行，否则就会出现异常





新建 AndroidThreadTest 项目，修改 activity_main.xml

```java
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

	//当点击 Button 后可以把 TextView 中显示的字符串改成 Nice to meet you
    <Button
        android:id="@+id/change_text"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Change Text" />
    
    //在屏幕正中央显示一个 Hello world 字符串
    <TextView
        android:id="@+id/text"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_centerInParent="true"
        android:text="Hello world"
        android:textSize="20sp" />

</RelativeLayout>
```





修改 MainActivity

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener{
    
    private TextView text;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        text = findViewById(R.id.text);
        Button changeText = findViewById(R.id.change_text);
        changeText.setOnClickListener(this);
    }
    
    //在 Change Text 按钮的点击事件里面开启了一个线程
    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.change_text:
                new Thread(new Runnable() {
                    @Override
                    public void run() {
                        //在子线程中调用了 TextView 的 setText() 方法将显示的字符串改成 Nice to meet you
                        text.setText("Nice to meet you");
                    }
                }).start();
                break;
            default:
                break;
        }
    }
    
}
```

当点击按钮之后会发现程序已经崩溃了，观察 logcat 日志，这是由于在子线程中更新了 UI 所导致的

```java
 android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.
```

由此证实 Android 确实是不允许在子线程中进行 UI 操作的





解决方法是异步消息处理，修改 MainActivity

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener{

    //先是定义一个整型常量 UPDATE_TEXT 用于表示更新 TextView 这个动作
    public static final int UPDATE_TEXT = 1;

    private TextView text;

    //新增一个 Handler 对象，并重写父类的 handleMessage() 方法，在这里对具体的 Message 进行处理
    private Handler handler = new Handler() {

        public void handleMessage(Message msg) {
            //如果发现 Message 的 what 字段的值等于 UPDATE_TEXT，就将 TextView 显示的内容改成 Nice to meet you
            switch (msg.what) {
                case UPDATE_TEXT:
                    //在这里可以进行 UI 操作
                    text.setText("Nice to meet you");
                    break;
                default:
                    break;
            }
        }

    };

	...

    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.change_text:
                new Thread(new Runnable() {
                    @Override
                    public void run() {
                        //创建了一个 Message(android.os.Message) 对象，并将它的 what 字段的值指定为 UPDATE_TEXT，然后调用 Handle 的 sendMessage() 方法将这条 Message 方法发送出去
                        Message message = new Message();
                        message.what = UPDATE_TEXT;
                        handler.sendMessage(message);//将 Message 对象发送出去
                        //此时 handleMessage() 方法中的代码就是在主线程当中运行的了
                    }
                }).start();
                break;
            default:
                break;
        }
    }

}
```





### 解析异步消息处理机制

Android 中的异步消息处理主要是由 4 个部分组成：Message 、Handler 、MessageQueue 和 Looper



1.Message

Message 是在线程之间传递的消息，它可以在内部携带少量的信息，用于不同线程之间交换数据。上一小节中我们使用到 了 Message 的 what 字段，除此之外还可以使用 arg1 和 arg2 字段来携带一些整型数据，使用 obj 字段携带一个 Object 对象。



2.Handler

Handler 顾名思义也就是处理者的意思，它主要适用于发送和处理消息的。发送消息一般是使用 Handler 的 sendMessage() 方法，而发出的消息经过一系列地辗转处理后，最终会传递到 Handle 的 handleMessage()  方法中。



3.MessageQueue

MessageQueue 是消息队列的意思，它主要用于存放所有通过 Handler 发送的消息。这部分消息会一直存在于消息队列中，等待被处理。每个线程中只会有一个 MessageQueue 对象。



4.Looper

Looper 是每个线程中的 MessageQueue 的管家，调用 Looper 的 loop() 方法后，就会进入到一个无限循环当中，然后每当发现 MessageQueue 中存在一条消息，就会将它取出，并传递到 Handler 的 handleMessage() 方法中。每个线程中也只有一个 Looper 对象。





异步消息的流程：

首先需要在主线程当中创建一个 Handler 对象，并重写 handleMessage() 方法。然后当子线程中需要进行 UI 操作时，就创建一个 Message 对象，并通过 Handler 将这条消息发送出去。之后这条消息就会被添加到 MessageQueue 的队列中等待被处理，而 Looper 则会一直尝试从 MessageQueue 中取出待处理消息，最后分发回 Handler 的 hanleMessage() 方法中。由于 Handler 是在主线程中创建的，所以此时 handleMessage() 方法中的代码也会在主线程中运行，于是我们在这里就可以安心地进行 UI 操作了。

一条 Message 经过这样一个流程的辗转调用后，也就从子线程进入到了主线程，从不能更新 UI 变成了可以更新 UI，整个异步消息处理的核心思想也就是如此，而我们第九章使用的 runOnUIThread() 其实就是一个异步消息处理机制的接口封装，他虽然表面看起来用法更加简单，其实原理也是如此。





### 使用 AsyncTask

为了更加方便我们在子线程中对 UI 进行操作，Android 还提供了另外一些好用的工具，比如 AsyncTask，它的原理也是基于异步消息处理的机制，只是 Android 帮我们做了很好的封装而已。





AsyncTask 是一个抽象类，我们想使用它，就必须创建一个子类去继承它，在继承时我们可以为 AsyncTask 类指定 3 个泛型参数，基本用法：

- Params：在执行 AsyncTask 时需要传入的参数，可用于在后台任务中使用
- Progress：后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为进度单位
- Result：当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型

因此一个最简单的自定义 AsyncTask 可以写成如下方式：

```java
//第一个泛型参数指定为 Void 表示在执行 AsyncTask 的时候不需要传入参数给后台参数
//第二个泛型参数指定为 Integer 表示使用整数来作为进度显示单位
//第三个泛型参数指定为 Boolean 表示使用布尔型数据来反馈执行结果
class DownloadTTask extends AsyncTask<Void, Integer, Boolean>{
    ...
}
```

现在自定义的 DownloadTask 还是一个空任务，经常需要重写以下 4 个方法才能完成对任务的定制



1.onPreExecute()

这个方法会在后台任务开始执行之前调用，用于进行一些界面上的初始化操作，比如显示一条进度条对话框等



2.doInBackground(Params...)

这个方法中的所有代码都会在子线程中运行，我们应该在这里去处理所有的耗时任务。任务一旦完成就可以通过 return 语句来将任务的执行结果返回，如果 AsyncTask 的第三个泛型参数指定的是 Void，就不返回任务执行结果。注意，在这个方法中是不可以进行 UI 操作的，如果需要更新 UI 元素，比如说反馈当前任务的执行进度，可以调用 publishProgress(Progress...) 方法来完成



3.onProgressUpdate(Progress...)

当后台任务中调用了 publishProgress(Progress...) 方法后，onProgressUpdate(Progress...) 方法就会很快被调用，该方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对 UI 进行操作，利用参数中的数值就可以对界面元素进行相应的更新



4.onPostExecute(Result)

当后台任务执行完毕并通过 return 语句进行返回时，这个方法就很快会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据来进行一些 UI 操作，比如说提醒任务执行的结果，以及关闭掉进度条对话框等





因此一个比较完整的自定义 AsyncTask 就可以写成如下方式：

```java
public class DownloadTask extends AsyncTask<Void, Integer, Boolean> {
    
    //这个方法会在后台任务开始执行之前调用，用于进行一些界面上的初始化操作，比如显示一条进度条对话框等
    @Override
    protected void onPreExecute() {
        progressDialog.show();//显示进度对话框
    }
    
    //这个方法中的所有代码都会在子线程中运行，我们应该在这里去处理所有的耗时任务。任务一旦完成就可以通过 return 语句来将任务的执行结果返回，如果 AsyncTask 的第三个泛型参数指定的是 Void，就不返回任务执行结果。注意，在这个方法中是不可以进行 UI 操作的，如果需要更新 UI 元素，比如说反馈当前任务的执行进度，可以调用 publishProgress(Progress...) 方法来完成
    //在 doInBackground() 方法里去执行具体的耗时下载任务，使之不会影响主线程的运行
    @Override
    protected Boolean doInBackground(Void...params) {
        try {
            while (true) {
                int downloadPercent = doDownload();//这是一个虚构的方法
                //由于在这里不能进行 UI 操作，就将返回的下载进度传进 publishProgress()，这样 onProgressUpdate() 方法就很快会被调用，在这里就可以进行 UI 操作了
                publishProgress(downloadPercent);
                if (downloadPercent >= 100) {
                    break;
                }
            }
        } catch (Exception e) {
            return false;
        }
        return true;
    }
    
    //当后台任务中调用了 publishProgress(Progress...) 方法后，onProgressUpdate(Progress...) 方法就会很快被调用，该方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对 UI 进行操作，利用参数中的数值就可以对界面元素进行相应的更新
    @Override
    protected void onProgressUpdate(Integer...values) {
        //在这里更新下载速度
        progressDialog.setMessage("Dpwnloaded " + values[0] + "%");
    }
    
    //当后台任务执行完毕并通过 return 语句进行返回时，这个方法就很快会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据来进行一些 UI 操作，比如说题型任务执行的结果，以及关闭掉进度条对话框等
    //当下载完成之后 doInBackground() 返回一个布尔型变量，这样 onPostExecute() 方法就会很快被调用，这个方法也是在主线程中运行的，然后我们根据下载的结果来弹出相应的 Toast 提示，从而完成整个 DownloadTask 任务
    @Override
    protected void onPostExecute(Boolean result) {
        progressDialog.dismiss();//关闭进度对话框
        //在这里提示下载结果
        if (result) {
            Toast.makeText(context, "Download successed", Toast.LENGTH_SHORT).show();
        } else {
            Toast.makeText(context, "Download failed", Toast.LENGTH_SHORT).show();
        }
    }
    
}
```





简单来说，使用 AsyncTask 就是在 doInBackground() 方法中去执行具体的耗时任务，在 onProgressUpdate() 方法中进行 UI 操作，在 onPostExecute() 方法中执行一些任务的收尾工作

如果想要启动这个任务，只需要编写：

```java
new DownloadTask().execute();
```









## 服务的基本用法





### 定义一个服务

新建一个 ServiceTest 项目，然后右击 com.example.servicetest -> New -> Service -> Service，我们将服务命名为 MyService，Exported 属性表示是否允许出了当前程序之外的其他程序访问这个服务，Enabled 属性表示是否启用这个服务，两个属性都勾选





观察 MyService

```java
//MyService 继承自 Service 类，说明这是一个服务
public class MyService extends Service {
    public MyService() {
    }

    //onBind() 这个方法是 Service 中唯一的一个抽象方法，所以必须在子类里实现它，目前暂时忽略
    @Override
    public IBinder onBind(Intent intent) {
        throw new UnsupportedOperationException("Not yet implemented");
    }
}
```



重写 Service 中的另外一些方法：

```java
public class MyService extends Service {
    public MyService() {
    }

    @Override
    public IBinder onBind(Intent intent) {
        // TODO: Return the communication channel to the service.
        throw new UnsupportedOperationException("Not yet implemented");
    }
    
    //onCreate() 方法会在服务创建的时候调用
    public void onCreate() {
        super.onCreate();
    }
    
    //onStartCommand() 方法会在每次服务启动的时候调用。如果希望服务一旦启动就立刻去执行某个动作，就可以将逻辑写在此方法里
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        return super.onStartCommand(intent, flags, startId);
    }
    
    //onDestroy() 方法会在服务销毁的时候调用。当服务销毁时，我们应该在此方法中回收那些不再使用的资源
    @Override
    public void onDestroy() {
        super.onDestroy();
    }
    
}
```





注意，每一个服务都需要在 AndroidManifest.xml 文件中注册才能生效，这是 Android 四大组件的共有特点





Android Studio 已经帮我们将这一步完成

```java
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.servicetest">

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        <service
            android:name=".MyService"
            android:enabled="true"
            android:exported="true">
        </service>
	    ...
    </application>

</manifest>
```

这样，一个服务就定义好了





### 启动和停止服务

定义好一个服务之后，接下来就应该考虑如何去启动以及停止这个服务。启动和停止的方法主要是借助 Intent 来实现的





修改 activity_main.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <Button
        android:id="@+id/start_service"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Start Service" />
    
    <Button
        android:id="@+id/stop_service"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Stop Service" />

</LinearLayout>
```





修改 MainActivity

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener{

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        //在 onCreate() 方法中分别获取到了 Start Service 按钮和 Stop Service 按钮的实例，并给它们注册点击事件
        Button startService = findViewById(R.id.start_service);
        Button stopService = findViewById(R.id.stop_service);
        startService.setOnClickListener(this);
        stopService.setOnClickListener(this);
    }

    @Override
    public void onClick(View v) {
        switch (v.getId()) {
           //在 Start Service 按钮的点击事件里，我们构建出一个 Intent 对象，并调用 startService() 方法来启动 MyService 这个服务
            case R.id.start_service:
                Intent startIntent = new Intent(this, MyService.class);
                startService(startIntent);//启动服务
                break;
            //在 Stop Service 按钮的点击事件里，我们同样构建一个 Intent 对象，并调用 stopService() 方法来停止 MyService 这个服务
            case R.id.stop_service:
                Intent stopIntent = new Intent(this, MyService.class);
                stopService(stopIntent);//停止服务
            default:
                break;
        }
    }
    
}
```

startService() 和 stopService() 方法都是定义在 Context 类中的，所以我们可以直接调用这两个方法



注意，这里完全是由活动来决定服务何时停止的，如果没有点击 Stop Service 按钮，服务就会一直处于运行状态，除此之外，只需要在 MyService 的任何一个位置调用 stioSelf() 方法就能让这个服务自己停止下来





修改 MyService

```java
public class MyService extends Service {
    
    private static final String TAG = "MyService";

    public MyService() {
    }

    @Override
    public IBinder onBind(Intent intent) {
        throw new UnsupportedOperationException("Not yet implemented");
    }

    public void onCreate() {
        super.onCreate();
        Log.d(TAG, "onCreate executed");
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        Log.d(TAG, "onStartCommand executed");
        return super.onStartCommand(intent, flags, startId);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        Log.d(TAG, "onDestroy executed");
    }

}
```

观察 logcat 中的打印日志，也可以在设置中查找到服务确实已经启动了

onCreate() 方法是在服务第一次创建的时候调用，而 onStartCommand() 方法则是在每次启动服务的时候调用，由于刚才第一次点击 Start Service 按钮，服务此时还未创建过，所以两个方法都会执行，之后如果多次点击 Stat Service 按钮，你会发现只有 onStartCommand()方法可以得到执行





### 活动和服务进行通信

在启动了服务之后，活动与服务基本就没有什么关系了，之后服务会一直处于运行状态，但具体运行的是什么逻辑，活动就控制不了了。这就类似于活动通知了服务一下“你可以启动了！”，然后服务就去忙自己的事情了，但活动并不知道服务到底去做了什么事情，以及完成得如何

让活动和服务的关系更紧密一些，例如在活动中指挥服务去干什么服务就去干什么，这就需要借助刚刚忽略的 onBind() 方法

比如我们希望在 MyService 里提供一个下载功能，然后在活动中可以决定时间何时开始下载以及随时查看下载进度。实现这个功能的思路是创建一个专门的 Binder 对象来对下载功能进行管理。修改 MyService

```java
public class MyService extends Service {

    private static final String TAG = "MyService";
    
    //在 MyService 中创建 DownloadBinder 实例
    private DownloadBinder mBinder = new DownloadBinder();

    //新建一个 DownloadBinder 类，并让它继承自 Binder，然后在它的内部提供了开始下载以及查看下载进度的方法
    class DownloadBinder extends Binder {
        
        public void startDownload() {
            Log.d(TAG, "startDownload executed");
        }
        
        public int getProgress() {
            Log.d(TAG, "getProgress executed");
            return 0;
        }
        
    }

    //在 onBind() 方法里返回这个 DownloadBinder 实例
    @Override
    public IBinder onBind(Intent intent) {
        return mBinder;
    }

    ...

}
```





修改 activity_main.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <Button
        android:id="@+id/start_service"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Start Service" />

    <Button
        android:id="@+id/stop_service"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Stop Service" />

    //用于绑定服务
    <Button
        android:id="@+id/bind_service"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Bind Service" />
    
    //用于取消绑定服务
    <Button
        android:id="@+id/unbind_service"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Unbind Service" />

</LinearLayout>
```





当一个活动和服务绑定之后，就可以调用服务里的 Binder 提供的方法。修改 MainActivity

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener{

    private MyService.DownloadBinder downloadBinder;

    //创建一个 ServiceConnection 的匿名类，并重写了 onServiceConnected() 和 onServiceDisconnected() 
    private ServiceConnection connection = new ServiceConnection() {
        //在活动和服务成功绑定的时候调用
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            //通过向下转型得到 DownloadBinder 的实例，现在我们可以在活动中根据具体的场景来调用 DownloadBinder 中的任何 public 方法，即实现了只会服务干什么服务就去干什么的功能。这里只是做了个简单的测试，在 onServiceConnected() 方法中调用了 DownloadBinder 的 startDownload() 和 getProgress() 方法
            downloadBinder = (MyService.DownloadBinder) service;
            downloadBinder.startDownload();
            downloadBinder.getProgress();
        }

        //在活动和服务连接断开的时候调用
        @Override
        public void onServiceDisconnected(ComponentName name) {

        }
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button startService = findViewById(R.id.start_service);
        Button stopService = findViewById(R.id.stop_service);
        startService.setOnClickListener(this);
        stopService.setOnClickListener(this);
        Button bindService = findViewById(R.id.bind_service);
        Button unbindService = findViewById(R.id.unbind_service);
        bindService.setOnClickListener(this);
        unbindService.setOnClickListener(this);
    }

    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.start_service:
                Intent startIntent = new Intent(this, MyService.class);
                startService(startIntent);//启动服务
                break;
            case R.id.stop_service:
                Intent stopIntent = new Intent(this, MyService.class);
                stopService(stopIntent);//停止服务
            //当前活动和服务还没进行绑定，这个功能是在 Bind Service 按钮的点击事件里完成的
            case R.id.bind_service:
                //构建出一个 Intent 对象，然后调用 bindService() 方法将 MainActivity 和 MyService 进行绑定
                Intent bindIntent = new Intent(this, MyService.class);
                // bindService() 方法接收三个参数，第一个参数是 Intent，第二个参数是 ServiceConnevtion 的实例，第三个参数则是一个标志位，这里传入 BIND_AUTO_CREATE 表示在活动和服务进行绑定后自动创建服务。这里会使得 MyService 中的 onCreate() 方法得到执行，但 onStartCommand() 方法不会执行
                bindService(bindIntent, connection, BIND_AUTO_CREATE);//绑定服务
                break;
            case R.id.unbind_service:
                //调用 unbindService() 解除活动和服务之间的绑定
                unbindService(connection);//解绑服务
                break;
            default:
                break;
        }
    }

}
```

点击一下 Bind Service 按钮首先执行 MyService 的 onCreate() 方法，然后 startDownload() 和 getProgress() 方法都得到了执行，说明我们确实已经成功地调用了服务里提供的方法

另外需要注意的是，任何一个服务在整个应用程序范围内都是通用的，即 MyService 不仅可以和 MainActivity 绑定，还可以和任何一个其他的活动进行绑定，而且在绑定完成后他们都可以获取到相同的 DownloadBinder 实例









## 服务的生命周期

我们前面使用到的 onCreate() 、onStartCommand() 、onBind() 和 onDestroy() 等方法都是在服务的生命周期内可能回调的方法

一旦在项目的任何位置调用了 Context 的 startService() 方法，相应的服务就会启动起来，并回调 onStartCommand() 方法。如果这个服务之前还没有创建过，onCreate() 方法会优先于 onStartCommand() 方法执行。服务启动了之后会一直保持运行状态，直到 stopService() 或 stopSelf() 方法被调用。注意，虽然每调用一次 startService() 方法，onStartCommand() 就会执行一次，但实际上每个服务都只会存在一个实例，所以不管你调用了多少次 startService() 方法，只需调用一次 stopService() 或 stopSelf() 方法，服务就会停止下来。

另外，还可以调用 Context 的 bindService() 来获取一个服务的持久连接，这时就会回调服务中的 onBind() 方法执行。之后，调用方可以获取到 onBind() 方法里返回的 IBinder 对象的实例，这样就能自由地和服务进行通信了，只要调用方和服务之间的连接没有断开，服务就会一直保持运行状态

当调用了 startService() 方法后，又去调用了 stopService() 方法，这是服务中的 onDestroy() 方法就会执行，表示服务已经销毁了。类似地，当调用了 bindService() 方法后，又去调用 unbindService() 方法，onDestory()  方法也会执行，这两种情况都是很好理解的。但是当我们对一个服务及调用了 startService() 方法，又调用了 bindService() 方法的，这种情况下该如何才能让服务销毁掉呢？根据 Android 的机制，一个服务只要被启动或者绑定了之后，就会一直处于运行状态，必须要让以上两种条件同时满足，服务才能被销毁。所以，这种情况下要同时调用 stopService() 和 unbindService() 方法，onDestroy() 方法才会执行







## 服务的更多技巧





### 使用前台服务

服务的系统优先级还是比较低的，当系统出现内存不足的情况时，就有可能会回收掉正在后台运行的服务。如果你希望服务可以一直保持运行状态，而不会由于系统内存不足的原因导致被回收，就可以考虑使用前台服务。前台服务和普通服务的最大区别在于，它会一直有一个正在运行的图标在系统的状态栏显示，下来状态栏后可以看到更加详细的信息，非常类似于通知的效果。



修改 MyService

```java
public class MyService extends Service {

	...

    public void onCreate() {
        super.onCreate();
        Log.d(TAG, "onCreate executed");
        Intent intent = new Intent(this, MainActivity.class);
        PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0);
        //构建出 Notification 对象后并没有使用 NotificationManager 来讲通知显示出来，而是调用了 startForeground() 方法
        Notification notification = new Notification.Builder(this)
                .setContentTitle("This is content title")
                .setContentText("This is content text")
                .setWhen(System.currentTimeMillis())
                .setSmallIcon(R.mipmap.ic_launcher)
                .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher))
                .setContentIntent(pi)
                .build();
        // startForeground() 方法接收两个参数，第一个参数是通知的 id，类似于 notify() 方法的第一个参数，第二个参数则是构建出的 Notification 对象，调用 startForeground() 方法后就会让 MyService 变成一个服务前台，并在系统状态栏显示出来
        startForeground(1, notification);
    }
	
    ...

}
```





### 使用 IntentService

服务中的代码都是默认运行在主线程当中的，如果直接在服务里去处理一些耗时的逻辑，就很容易出现 ANR (Application Not Responding) 的情况，这个时候就需要用到了 Android 多线程的技术，我们应该在服务的每个具体地方法里开启一个子线程，然后在这里去处理一个那些耗时的逻辑，一个标准的服务的写法如下：

```java
public class MyService extends Service {
    ...
    @Ovrride
    public int onStartCommand(Intent intent, int flags, int startId) {
        new Thread(new Runable() {
            @Override
            public void run() {
                //处理具体的逻辑
            }
        }).start();
     	return super.onStartCommand(intent, flags, startId);
    }
}
```



但是这种方法一旦启动之后就会一直处于运行状态，必须调用 stopService() 或者 stopSelf() 方法才能让服务停止下来

```java
public class MyService extends Service {
    ...
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        new Thread(new Runnable() {
            @Overrider
            public void run() {
                //处理具体逻辑
                stopSelf();
            }
        }).start();
        return super.onStartCommand(intent, flags, startId);
    }
}
```



这种写法并不复杂，但是总会有可能忘记开启线程，或者忘记调用 stopSelf() 方法。为了可以简单地创建一个异步的、会自动停止的服务，Android 专门提供了一个 IntentService 类



新建一个 MyIntentService 继承自 IntentService

```java
public class MyIntentService extends IntentService {

    private static final String TAG = "MyIntentService";
    
    //首先提供一个无参的构造函数，并且必须在其内部调用父类的有参构造函数
    public MyIntentService() {
        super("MyIntentService");//调用父类的有参构造函数
    }
    
    //在子类实现 onHandleIntent() 这个抽象方法，在这个方法中可以去处理一些具体的逻辑，而不用担心 ANR 问题，因为这个方法已经是在子线程中运行的了
    @Override
    protected void onHandleIntent(Intent intent) {
        //打印当前线程的 id，为确定开启了子线程
        Log.d(TAG, "Thread id is " + Thread.currentThread().getId());
    }
    
    @Override
    public void onDestroy() {
        super.onDestroy();
        //打印一行日志来确定服务是不是停止掉了
        Log.d(TAG, "onDestroy executed");
    }
    
}
```



修改 activity_main.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

	...

    <Button
        android:id="@+id/start_intent_service"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Start IntentService" />

</LinearLayout>
```



修改 MainActivity

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener{

    ...

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        ...
        Button startIntentService = findViewById(R.id.start_intent_service);
        startIntentService.setOnClickListener(this);
    }

    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            ...
            case R.id.start_intent_service:
                //打印主线程的 id，用于于子线程的 id 作比较
                Log.d("MainActivity", "Thread id is " + Thread.currentThread().getId());
                Intent intentService = new Intent(this, MyIntentService.class);
                startService(intentService);
                break;
            default:
                break;
        }
    }

}
```



注意记得在 AndroidManifest.xml 里注册 Service

```java
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.servicetest">

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        
        <service android:name=".MyIntentService"/>
        
        ...

</manifest>
```









## 服务的最佳实践 —— 完整版的下载示例

创建一个 ServiceBestPractice 项目，编辑 app/build.gradle，在 dependencies 闭包中添加 OkHttp 的依赖：

```java
dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    implementation 'com.android.support:appcompat-v7:28.0.0'
    implementation 'com.android.support.constraint:constraint-layout:1.1.3'
        
    implementation 'com.squareup.okhttp3:okhttp:3.4.1'
    
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'com.android.support.test:runner:1.0.2'
    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
}
```



定义一个回调接口，用于对下载过程中的各种状态进行监听和回调。新建一个 DownloadListener 接口

```java
public interface DownloadListener {
    
    //用于通知当前的下载进度
    void onProgress(int progress);
    
    //用于通知下载成功事件
    void onSuccess();
    
    //用于通知下载失败事件
    void onFailed();
    
    //用于通知下载暂停事件
    void onPaused();
    
    //用于通知下载取消事件
    void onCanceled();
    
}
```



编写下载功能，新建一个 DownloadTask 继承自 AsyncTask

```java
//AsyncTask 中接收三个泛型参数，第一个泛型参数指定为 String，表示在执行 AsyncTask 的时候需要传入一个字符串参数给后台任务；第二个泛型参数指定为 Integer，表示使用整型数据来作为进度显示单位；第三个泛型参数指定为 Integer，则表示使用整型数据来反馈执行结果
public class DownloadTask extends AsyncTask<String, Integer, Integer> {

    //定义四个整型常量来表示下载的状态
    //下载成功
    public static final int TYPE_SUCCESS = 0;
    //下载失败
    public static final int TYPE_FAILED = 1;
    //暂停下载
    public static final int TYPE_PAUSED = 2;
    //取消下载
    public static final int TYPE_CANCELED = 3;

    private DownloadListener listener;

    private boolean isCanceled= false;

    private boolean isPaused = false;

    private int lastProgress;

    //在 DownloadTask 的构造函数中要求传入一个刚刚定义的 DownloadListener 参数，我们待会就会将下载的状态通过这个参数进行回调
    public DownloadTask(DownloadListener listener) {
        this.listener = listener;
    }

    //这个方法中的所有代码都会在子线程中运行，我们应该在这里去处理所有的耗时任务。任务一旦完成就可以通过 return 语句来将任务的执行结果返回，如果 AsyncTask 的第三个泛型参数指定的是 Void，就不返回任务执行结果。注意，在这个方法中是不可以进行 UI 操作的，如果需要更新 UI 元素，比如说反馈当前任务的执行进度，可以调用 publishProgress(Progress...) 方法来完成
    //doInBackground() 方法用于后台执行具体的下载逻辑
    @Override
    protected Integer doInBackground(String...params) {
        InputStream is = null;
        RandomAccessFile savedFile = null;
        File file = null;
        try {
            long downloadedLength = 0;//记录已下载的文件长度
            //首先从参数中获取到下载的 URL 地址
            String downloadUrl = params[0];
            //根据 UEL 地址解析出了下载的文件名
            String fileName = downloadUrl.substring(downloadUrl.lastIndexOf("/"));
            //指定将文件下载到 Environment.DIRECTORY_DOWNLOADS 目录下，也就是 SD 卡的 Download 目录
            String directory = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getPath();
            file = new File(directory + fileName);
            //判断 Download 目录中是不是已经存在要下载的文件，如果已经存在的话则读取已下载的字节数，这样就可以在后面启用断点续传的功能
            if (file.exists()) {
                downloadedLength = file.length();
            }
            //调用 getContentLength() 方法来获取待下载文件的总长度
            long contentLength = getContentLength(downloadUrl);
            //如果文件长度等于 0 这说明文件有问题，直接返回 TYPE_FAILED。如果文件长度等于已下载的文件长度，那么就说明文件已经下载完了，直接返回 TYPE_SUCCESS
            if (contentLength == 0) {
                return TYPE_FAILED;
            } else if (contentLength == downloadedLength) {
                //已下载字节和文件总字节相等，说明已经下载完成了
                return TYPE_SUCCESS;
            }
            //使用 OkHttp 来发送一条网络请求，需要注意的是，这里在请求中添加了一个 header，用于告诉服务器我们想要从哪个字节开始下载，因为已下载过的部分就不需要再重新下载
            OkHttpClient client = new OkHttpClient();
            Request request = new Request.Builder()
                    //断点下载，指定从那个字节开始下载
                    .addHeader("RANGE", "bytes=" + downloadedLength + "-")
                    .url(downloadUrl)
                    .build();
            Response response = client.newCall(request).execute();
            if (response != null) {
                is = response.body().byteStream();
                savedFile = new RandomAccessFile(file, "rw");
                savedFile.seek(downloadedLength);//跳过已下载的字节
                byte[] b = new byte[1024];
                int total = 0;
                int len;
                //接下来读取服务器响应的数据，并使用 Java 的文件流方式，不断从网络上读取数据，不断写入到本地，一直到文件全部下载完成为止，这个过程中还要判断用户有没有触发暂停或者取消的操作，如果有的话则返回 TYPE_CANCELED 或 TYPE_PAUSED 来中断下载，如果没有的话则实时计算当前的下载速度，然后调用 publishProgress() 方法进行通知。
                while ((len = is.read(b)) != -1) {
                    if (isCanceled) {
                        return TYPE_CANCELED;
                    } else if (isPaused) {
                        return TYPE_PAUSED;
                    } else {
                        total += len;
                        savedFile.write(b, 0, len);
                        //计算已下载的百分比
                        int progress = (int) ((total + downloadedLength) * 100 / contentLength);
                        publishProgress(progress);
                    }
                }
                response.body().close();
                return TYPE_SUCCESS;
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                if (is != null) {
                    is.close();
                }
                if (savedFile != null) {
                    savedFile.close();
                }
                if (isCanceled && file != null) {
                    file.delete();
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return TYPE_FAILED;
    }
    
    private long getContentLength(String downloadUrl) throws IOException {
        OkHttpClient client = new OkHttpClient();
        Request request = new Request.Builder()
                .url(downloadUrl)
                .build();
        Response response = client.newCall(request).execute();
        if (response != null && response.isSuccessful()) {
            long contentLength = response.body().contentLength();
            response.body().close();
            return contentLength;
        }
        return 0;
    }
    
    //暂停个操作都是使用一个布尔型的变量来逆行控制的，调用 pauseDownload() 或 cancelDownload() 方法即可改变量的值
    public void pauseDownload() {
        isPaused = true;
    }    
    
    public void cancelDownload() {
        isCanceled = true;
    }
    
    //当后台任务中调用了 publishProgress(Progress...) 方法后，onProgressUpdate(Progress...) 方法就会很快被调用，该方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对 UI 进行操作，利用参数中的数值就可以对界面元素进行相应的更新
    //onProgressUpdate() 方法用于在界面更新当前的下载进度
    @Override
    protected void onProgressUpdate(Integer...values) {
        //首先从参数获取到当前的下载进度
        int progress = values[0];
        //和上一次的下载进度进行对比，如果有变化的话则调用 DownloadListener 的 onProgress() 方法来通知下载进度更新
        if (progress > lastProgress) {
            listener.onProgress(progress);
            lastProgress = progress;
        }
    }
    
    //当后台任务执行完毕并通过 return 语句进行返回时，这个方法就很快会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据来进行一些 UI 操作，比如说提醒任务执行的结果，以及关闭掉进度条对话框等
    //onPostExecute() 用于通知最终的下载结果
    @Override
    protected void onPostExecute(Integer status) {
        //根据参数中传入的下载状态来进行回调，下载成功就调用 DownloadListener 的 onSuccess() 方法，下载失败就调用 DownloadListener 的 onFailed() 方法，暂停下载就调用 onPaused() 方法，取消下载就调用 onCanceled() 方法
        switch (status) {
            case TYPE_SUCCESS:
                listener.onSuccess();
                break;
            case TYPE_FAILED:
                listener.onFailed();
                break;
            case TYPE_PAUSED:
                listener.onPaused();
                break;
            case TYPE_CANCELED:
                listener.onCanceled();
                break;
            default:
                break;
        }
    }
    
}
```



为了保证 DownloadTask 一直在后台运行，还需创建一个 下载的服务，右键新建一个 DownloadTask 的 Service

```java
public class DownloadService extends Service {

    private DownloadTask downloadTask;

    private String downloadUrl;

    //首先创建一个 DownloadListener 的匿名实例，并在匿名类中实现了 onProgress() 、onSuccess() 、onFailed() 、onCanceled() 和 onPaused() 五个方法
    private DownloadListener listener = new DownloadListener() {
        
        //在 onProgress() 方法中，我们调用 getNotification() 方法构建了一个用于显示下载进度的通知，然后调用 NotificationManager 的 notify() 方法去触发这个通知，这样就可以在下拉状态栏中实时看到当前下载的进度了
        @Override
        public void onProgress(int progress) {
            getNotificationManager().notify(1, getNotification("Downloading...", progress));
        }

        //在 onSuccess() 方法中，首先将正在下载的前台通知关闭，然后创建一个新的通知用于告诉用户下载成功了，其他几个方法也是类似
        @Override
        public void onSuccess() {
            downloadTask = null;
            //下载成功时将前台服务通知关闭，并创建一个下载成功的通知
            stopForeground(true);
            getNotificationManager().notify(1, getNotification("Download Success", -1));
            Toast.makeText(DownloadService.this, "Download Success", Toast.LENGTH_SHORT).show();
        }

        @Override
        public void onFailed() {
            downloadTask = null;
            //下载失败时将前台服务通知关闭，并创建一个下载失败的通知
            stopForeground(true);
            getNotificationManager().notify(1, getNotification("Download Failed", -1));
            Toast.makeText(DownloadService.this, "Download Failed", Toast.LENGTH_SHORT).show();
        }

        @Override
        public void onPaused() {
            downloadTask = null;
            Toast.makeText(DownloadService.this, "Paused", Toast.LENGTH_SHORT).show();
        }

        @Override
        public void onCanceled() {
            downloadTask = null;
            stopForeground(true);
            Toast.makeText(DownloadService.this, "Canceled", Toast.LENGTH_SHORT).show();
        }
    };

    //为了让 DownloadServer 和活动进行通信，创建 DownloadBinder，DownloadBinder 中提供了 startDownload() 、 pauseDownload() 和 cancelDownload() 三个方法分别用于开始下载，暂停下载和取消下载
    private DownloadBinder mBinder = new DownloadBinder();

    @Override
    public IBinder onBind(Intent intent) {
        return mBinder;
    }

    class DownloadBinder extends Binder {

        //在 startDownload() 创建了一个 DownloadTask 实例，把刚才的 DownloadListener 作为参数传入，然后调用 execute() 方法开启下载，并将下载文件的 URL 地址传入到 execute() 方法中，同时为了让这个下载服务成为一个前台服务，我们还调用了 startForeground() 方法，这样就会在系统状态栏中创建一个持续运行的通知了
        public void startDownload(String url) {
            if (downloadTask == null) {
                downloadUrl = url;
                downloadTask = new DownloadTask(listener);
                downloadTask.execute(downloadUrl);
                startForeground(1, getNotification("Downloading...", 0));
                Toast.makeText(DownloadService.this, "Downloading...", Toast.LENGTH_SHORT).show();
            }
        }

        //pauseDownload() 方法中的代码就是简单地调用了 DownloadTask 中的 pauseDownload() 方法
        public void pauseDownload() {
            if (downloadTask != null) {
                downloadTask.pauseDownload();
            }
        }

        //cancelDownload() 方法中调用了 DownloadTask 的 cancelDownload() 方法，需要注意的是，取消下载的时候我们需要将正在下载的文件删除掉
        public void cancelDownload() {
            if (downloadTask != null) {
                downloadTask.cancelDownload();
            }
            if (downloadUrl != null) {
                //取消下载时需要将文件删除，并将通知关闭
                String fileName = downloadUrl.substring(downloadUrl.lastIndexOf("/"));
                String directory = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getPath();
                File file = new File(directory + fileName);
                if (file.exists()) {
                    file.delete();
                }
                getNotificationManager().cancel(1);
                stopForeground(true);
                Toast.makeText(DownloadService.this, "Canceled", Toast.LENGTH_SHORT).show();
            }
        }

    }

    private NotificationManager getNotificationManager() {
        return (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
    }

    private Notification getNotification(String title, int progress) {
        Intent intent = new Intent(this, MainActivity.class);
        PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0);
        NotificationCompat.Builder builder = new NotificationCompat.Builder(this);
        builder.setSmallIcon(R.mipmap.ic_launcher);
        builder.setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher));
        builder.setContentIntent(pi);
        builder.setContentTitle(title);
        if (progress >= 0) {
            //当 progress 大于或等于 0 时才需显示下载速度
            builder.setContentText(progress + "%");
            //setProgress() 方法接收三个参数，第一个参数传入通知的最大进度，第二个参数传入通知的当前进度，第三个参数表示是否使用模糊进度条，这里传入 false，设置完 setProgress() 方法，通知上就会有进度条显示出来了
            builder.setProgress(100, progress, false);
        }
        return builder.build();
    }
        
}
```



修改 activity_main.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <Button
        android:id="@+id/start_download"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Start Download" />

    <Button
        android:id="@+id/pause_download"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Pause Download" />

    <Button
        android:id="@+id/cancel_download"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Cancel Download" />

</LinearLayout>
```



修改 MainActivity

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener{

    private DownloadService.DownloadBinder downloadBinder;

    //创建一个 ServiceConnection 的匿名类，然后在 onServiceConnected() 方法中获取到 DownloadTask 实例，有了这个实例我们就可以在活动中调用服务提供的各种方法
    private ServiceConnection connection = new ServiceConnection() {
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            downloadBinder = (DownloadService.DownloadBinder) service;
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {

        }
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        //对各个按钮都进行了初始化操作并设置了点击事件
        Button startDownload = findViewById(R.id.start_download);
        Button pauseDownload = findViewById(R.id.pause_download);
        Button cancelDownload = findViewById(R.id.cancel_download);
        startDownload.setOnClickListener(this);
        pauseDownload.setOnClickListener(this);
        cancelDownload.setOnClickListener(this);
        Intent intent = new Intent(this, DownloadService.class);
        //注意 startService()、 bindService() 这两个方法至关重要，因为启动服务可以保证 DownloadService 一直在后台运行，绑定服务则可以让 MainActivity 和 DownloadService 进行通信，因此这两个方法都必不可少
        startService(intent);//启动服务
        bindService(intent, connection, BIND_AUTO_CREATE);//绑定服务
        //在 onCreate() 方法最后进行了 WRITE_EXTERNAL_STORAGE 的运行时权限申请， 因为下载文件是要下载到 SD 卡的 Download 目录下的，如果没有这个权限，我们整个程序都无法正常工作
        if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(MainActivity.this, new String[] {Manifest.permission.WRITE_EXTERNAL_STORAGE}, 1);
        }
    }

    @Override
    public void onClick(View v) {
        if (downloadBinder == null) {
            return;
        }
        switch (v.getId()) {
            //点击了开始按钮就调用 DownloadBinder 的 startDownload() 方法，这里可以传入任意的下载地址
            case R.id.start_download:
                String url = "http://raw.githubusercontent.com/guolindev/eclipse/master/eclipse-inst-win64.exe";
                downloadBinder.startDownload(url);
                break;
            case R.id.pause_download:
                downloadBinder.pauseDownload();
                break;
            case R.id.cancel_download:
                downloadBinder.cancelDownload();
                break;
            default:
                break;
        }
    }

    @Override
    public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
        switch (requestCode) {
            case 1:
                if (grantResults.length > 0 && grantResults[0] != PackageManager.PERMISSION_GRANTED) {
                    Toast.makeText(this, "拒绝权限无法使用程序", Toast.LENGTH_SHORT).show();
                    finish();
                }
                break;
            default:
        }
    }

    //需要注意，如果活动被销毁了，那么一定要记得对服务进行解绑，不然就有可能会造成内存泄漏，这里我们在 onDestroy() 方法中完成了解绑操作
    @Override
    protected void onDestroy() {
        super.onDestroy();
        unbindService(connection);
    }
    
}
```



在 AndroidManifest.xml 中声明使用到的权限

```java
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.servicebestpractice">

	//由于程序需要使用到网络和访问 SD 卡的功能，因此需要声明 INTERNET 和 WRITE_EXTERNAL_STORAGE 这两个权限
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        <service
            android:name=".DownloadService"
            android:enabled="true"
            android:exported="true"></service>

        <activity android:name=".MainActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>
```

