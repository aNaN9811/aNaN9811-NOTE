# 第六章：数据存储全方案——详解持久化技术

瞬时数据，就是指那些存储在内存当中，有可能会因为程序关闭或其他原因导致内存被回收而丢失的数据



### 持久化技术简介

数据持久化就是将那些内存中的瞬时数据保存到存储设备当中，保证即在手机或电脑关机的情况下这些数据仍然不会丢失，保存在内存中的数据是处于瞬时状态的，而保存在存储设备中的数据时处于持久状态的，持久化技术则提供了一种机制可以让数据在瞬时状态之间进行切换

Android 系统中主要提供了3种用于简单地实现数据持久化功能，即文件存储、SharedPreferences 存储以及数据库存储



### 文件存储

文件存储是 Android 中最基本的一种数据存储方式，它不对存储的内容进行任何格式化处理，所有的数据都是原封不动地保存到文件中，因而比较适合用于存储一些简单地文本数据或二进制数据，如果想要使用文件存储的方法来保存一些较为复杂的文本数据，就需要定义一套自己的格式规范，这样可以方便之后将数据从文件中重新解析出来



### 将数据存储到文件中

Context 类中提供了一个 openFileOutput() 方法，可以用于将数据存储到指定的文件中，该方法接收两个参数，第一个参数是文件名，在文件创建的时候使用的就是这个名称，注意这里的文件名不可以包含路径，因为所有的文件都是默认存储到  /data/data/<package name>/files/  目录下的。第二个参数是文件的操作模式，主要有两种模式可以选，MODE_PRIVATE 和 MODE_APPEND。其中，MODE_PRIVATE 表示当指定同样文件名的时候，所写入的内容将会覆盖原文件中的内容，而 MODE_APPEND 则表示如果该文件已存在，就往文件里面追加内容，不存在就创建新文件

openFileOutput() 方法返回的是一个 FileOutputStream 对象，得到这个对象之后就可以使用 Java 流的方式将数据写入到文件中了

创建 FilePersistenceTest 项目，修改 activity_main.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    //在布局中加入了一个 EditText 用于输入文本内容
    <EditText
        android:id="@+id/edit"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="Type something here"/>

</LinearLayout>
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    private EditText edit;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        //在 onCreate() 中获取 EditText 实例
        edit = (EditText) findViewById(R.id.edit);
    }

    //重写 onDestroy()，保证在活动销毁之前调用这个方法
    @Override
    protected void onDestroy(){
        super.onDestroy();
        //获取 EditText 中的内容
        String inputText = edit.getText().toString();
        //调用 save() 方法把输入的内容存储到文件中，文件命名为 data
        sava(inputText);
    }

    public void sava(String inputText){
        FileOutputStream out = null;
        BufferedWriter writer = null;
        try{
            
            //openFileOutput() 方法，可以用于将数据存储到指定的文件中，该方法接收两个参数
            //第一个参数是文件名，在文件创建的时候使用的就是这个名称，注意这里的文件名不可以包含路径，因为所有的文件都是默认存储到  /data/data/<package name>/files/  目录下的。
            //第二个参数是文件的操作模式，主要有两种模式可以选，MODE_PRIVATE 和 MODE_APPEND。其中，MODE_PRIVATE 表示当指定同样文件名的时候，所写入的内容将会覆盖原文件中的内容，而 MODE_APPEND 则表示如果该文件已存在，就往文件里面追加内容，不存在就创建新文件
            
            //openFileOutput() 方法返回的是一个 FileOutputStream 对象，得到这个对象之后就可以使用 Java 流的方式将数据写入到文件中了
            out = openFileOutput("data", Context.MODE_PRIVATE);
            //借助 FileOutputStream 对象构建出一个 OutputStreamWriter 对象，在借助这个对象构建出一个 BufferedWriter 对象，这样就可以通过 BufferedWriter 来讲文本内容写入到文件中
            writer = new BufferedWriter(new OutputStreamWriter(out));
            writer.write(inputText);
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (writer != null){
                    writer.close();
                }
            } catch (IOException e){
                e.printStackTrace();
            }
        }
    }

}
```

借助 Android Device Monitor 工具来查看，进入 File Explorer 标签页，找到  /data/data/com.example.filepersistencetest/files/ 目录，可以看到生成一个 data 文件



### 从文件中读取数据

Context 类中还提供了一个 openFileInput() 方法，用于从文件中读取数据，它只接收一个参数，即要读取的文件名，然后系统自动到 /data/data/com.example.filepersistencetest/files/ 目录下去加载这个文件，并返回一个 FileInputStream 对象，得到这个对象后再通过 Java 流的方式就可以将数据读取出来

首先通过 openFileInput() 方法获取到了一个 FileInputStream 对象，然后借助它有构建了一个 InputStreamReader 对象，接着再使用 InputStreamReader 构建出一个 BufferedReader 对象，这样就可以通过 BufferedReader 进行一行行地读取，把文件中所有的文本内容读取出来，并存放在一个 StringBuilder 对象中，最后将读取到的内容返回即可

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    private EditText edit;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        edit = (EditText) findViewById(R.id.edit);
        //在 onCreate() 方法中调用 load() 方法来读取文件中存储的文本内容
        String inputText = load();
        //如果读到的内容不为 null，就调用 EdiText 的 setText() 方法将内容填充到 EditText 里，并调用 setSelection() 方法将输入光标移动到文本的末尾位置以便于急需输入，然后弹出一句还原成功
        
        //对于非空判断的时候使用了 TextUtils.isEmpty() 方法，它可以一次性进行两种空值的判断，当传入的字符串等于 null 或者等于空字符串的时候，这个方法都会返回 true，从而使得我们不需要先单独判断这两种空值在使用逻辑运算符连接起来
        if (!TextUtils.isEmpty(inputText)){
            edit.setText(inputText);
            edit.setSelection(inputText.length());
            Toast.makeText(this, "Restoring successedd", Toast.LENGTH_SHORT).show();
        }
    }

	...

    public String load(){
        FileInputStream in = null;
        BufferedReader reader = null;
        StringBuilder content = new StringBuilder();
        try {
            //openFileInput() 方法，用于从文件中读取数据，它只接收一个参数，即要读取的文件名，然后系统自动到 /data/data/com.example.filepersistencetest/files/ 目录下去加载这个文件，并返回一个 FileInputStream 对象
            in = openFileInput("data");
            //借助 FileInputStream 构建了一个 InputStreamReader 对象，接着再使用 InputStreamReader 构建出一个 BufferedReader 对象，这样就可以通过 BufferedReader 进行一行行地读取，把文件中所有的文本内容读取出来，并存放在一个 StringBuilder 对象中，最后将读取到的内容返回即可
            reader = new BufferedReader(new InputStreamReader(in));
            String line = "";
            while((line = reader.readLine()) != null){
                content.append(line);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException e){
                    e.printStackTrace();
                }
            }
        }
        return content.toString();
    }

}
```

核心技术是使用 Context 类提供的 openFileInput() 和 openFileoutput() 方法，之后就是利用 Java 的各种流来进行读写操作



### SharedPreferences 存储

SharedPreferences 是使用键值对的方式来存储数据的，当保存一条数据的时候，需要给这条数据提供一个对应的键值对，这样在读取数据的时候就可以通过这个键把相应的值取出来，而且 SharedPreferences 还支持多种不同数据类型存储，如果存储的数据类型是整型，那么读取出来的数据也是整型的；如果存储的数据是一个字符串，那么读取出来的数据仍然是字符串



### 将数据存储到 SharedPreferences  中

使用 SharedPreferences 来存储数据，首先需要获取到 SharedPreferences  对象，Android 主要提供了 3 种方法用于得到 SharedPreferences  对象

- Context 类中的 getSharedPreferences() 方法

此方法接收两个参数，第一个参数用于指定 SharedPreferences 文件的名称，如果指定的文件不存在则会创建一个，SharedPreferences  文件都是存放在 /data/data/<package name>/shared_prefs/ 目录下的，第二个参数是用于指定操作模式，目前只有 MODE_PRIVATE 这一种模式可选，他是默认的操作模式，和直接传入 0 效果相同，表示只有当前的应用程序才可以对 SharedPreferences  文件进行读写

- Activity 类中的 getPreferences() 方法

该方法和 Context 中的 getSharedPreferences() 方法很相似，不过它只接收一个操作模式参数，因为使用这个方法时会将当前活动的类名作为 SharedPreferences  的文件名

- PreferenceManager 类中的 getDefaultSharedPreferences 

这是一个静态方法，接收一个 Context 参数，自动使用当前应用程序的包名作为前缀来命名 SharedPreferences  文件，得到了 SharedPreferences  对象之后就可以向 SharedPreferences  文件中存储数据了

新建 SharedPreferencesTest 项目，修改 activity_main.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

	//简单地放置一个按钮，用于将一些数据存储到 SharedPreferences 文件当中
    <Button
        android:id="@+id/save_data"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Save data"
        />
    
</LinearLayout>
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button saveData = (Button) findViewById(R.id.save_data);
        //给按钮注册一个点击事件，然后在点击事件中通过 getSharedPreferences() 方法指定 SharedPreferences 的文件名为 data，并得到了 SharedPreferences.Editor 对象，接着向这个对象添加了 3 条不同类型的数据，最后调用 apply 方法进行提交从而完成数据存储的操作
        saveData.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                //调用 SharedPreferences 对象的 edit() 方法来获取一个 SharedPreferences.Editor 对象
                SharedPreferences.Editor editor = getSharedPreferences("data", MODE_PRIVATE).edit();
                //向 SharedPreferences.Editor 中添加数据
                editor.putString("name", "Tom");
                editor.putInt("age", 28);
                editor.putBoolean("married", false);
                //调用 apply 方法进行提交从而完成数据存储的操作
                editor.apply();
            }
        });
    }
}
```

借助 File Explorer 来进行查看，进入 /data/data/sharedpreferencestest/shared_prefs/ 目录下，生成一个 data.xml 文件

SharedPreferences 文件是使用 XML 格式来对数据进行管理的



### 从 SharedPreferences  中读取数据

SharedPreferences 对象中提供了一系列 get 方法，用于对存储的数据进行读取，每种 get 方法都对应了 SharedPreferences.Editor 的一种 put 方法

这些 get 方法都接受两个参数，第一个参数是键，传入存储数据时使用的键就可以得到相应的值了；第二个参数是默认值，即表示当传入的键找不到对应的值时会以什么样的默认值进行返回

修改 activity_main.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <Button
        android:id="@+id/save_data"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Save data"
        />

    //增加一个还原数据的按钮，通过点击这个按钮来从 SharedPreferences 文件中读取数据
    <Button
        android:id="@+id/restore_data"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Restore data"
        />

</LinearLayout>
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        
        ...
        
        Button restoreData = (Button) findViewById(R.id.restore_data);
        restoreData.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                //首先通过 getSharedPreferences() 方法得到了 SharedPreferences 对象
                SharedPreferences pref = getSharedPreferences("data", MODE_PRIVATE);
                //调用了不同的 get 方法，第一个参数是键，传入存储数据时使用的键就可以得到相应的值了；第二个参数是默认值，即表示当传入的键找不到对应的值时会以什么样的默认值进行返回
                String name = pref.getString("name", "");
                int age = pref.getInt("age", 0);
                boolean married = pref.getBoolean("married", false);
                //最后通过 Log 这些值打印出来
                Log.d("MainActivity", "name is " + name);
                Log.d("MainActivity", "age is " + age);
                Log.d("MainActivity", "married is " + married);
            }
        });
    }
}
```



### 实现记住密码功能

打开 BroadcastTest，修改 activity_login.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

	...

    <LinearLayout
        android:orientation="horizontal"
        android:layout_width="match_parent"
        android:layout_height="wrap_content">
        //新控件 CheckBox，这是一个复选框控件，用户可以通过点击的方式进行选中取消
        <CheckBox
            android:id="@+id/remember_pass"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content" />
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textSize="18sp"
            android:text="Remember psaaword" />

    </LinearLayout>

    <Button
        android:id="@+id/login"
        android:layout_width="match_parent"
        android:layout_height="60dp"
        android:text="Login" />

</LinearLayout>
```

修改 LoginActivity

```java
public class LoginActivity extends BaseActivity{

    private SharedPreferences pref;

    private SharedPreferences.Editor editor;

    private EditText accountEdit;

    private EditText passwordEdit;

    private Button login;

    private CheckBox rememberPass;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_login);
        //获取 SharedPreferences 对象
        pref = PreferenceManager.getDefaultSharedPreferences(this);
        accountEdit = (EditText) findViewById(R.id.account);
        passwordEdit = (EditText) findViewById(R.id.password);
        rememberPass = (CheckBox) findViewById(R.id.remember_pass)
        login = (Button) findViewById(R.id.login);
        //调用 get 方法去获取 remember_password 这个键对应的值，一开始不存在对应的值，所以会使用默认值是 false，这样什么都不会发生
        boolean isRemember = pref.getBoolean("remember_password", false);
        if (isRemember) {
            //将账号和密码都设置到文本框中
            String account = pref.getString("account", "");
            String password = pref.getString("password", "");
            accountEdit.setText(account);
            passwordEdit.setText(password);
            rememberPass.setChecked(true);
        }
        login.setOnClickListener(new View.OnClickListener(){
            @Override
            public void onClick(View v){
                String account = accountEdit.getText().toString();
                String password = passwordEdit.getText().toString();
                //如果账号是 admin 且 密码是 123456，就认为登陆成功
                if(account.equals("admin") && password.equals("123456")){
                    editor = pref.edit();
                    //登录成功后，调用 CheckBox 的 isChecked() 方法来检查复选框是否被选中，如果选中了则表示用户想要记住密码，这时将 remember_password 设为 true，然后把 account 和 password 对应的值都存到 SharedPreferences 文件当中并提交。如果没用被选中，则调用 clear() 方法将 SharedPreferences 文件中的数据全部清除掉
                    if (rememberPass.isChecked()) {//检查复选框是否选中
                        editor.putBoolean("remember_password", true);
                        editor.putString("account", account);
                        editor.putString("password", password);
                    } else {
                        editor.clear();
                    }
                    editor.apply();
                    Intent intent = new Intent(LoginActivity.this, MainActivity.class);
                    startActivity(intent);
                    finish();
                } else {
                    Toast.makeText(LoginActivity.this, "account or password is invalid", Toast.LENGTH_SHORT).show();
                }
            }
        });
    }
}
```

此时密码以明文的形式存储在 SharedPreferences 文件中，正式的项目里需要结合一定的加密算法来对密码进行保护才行



### SQLite 数据库存储

SQLite 是一款轻量级的关系型数据库，它的运算速度非常快，占用资源很少，通常只需要几百 KB 的内存就足够了，它不仅支持标准的 SQL 语法，还遵循数据库的 ACID 事务，其又比一般的数据库简单得多，它甚至不用设置用户名和密码就可以使用，Android 把这个数据库嵌入到了系统当中



### 创建数据库

Android 为了让我们能够更加方便地管理数据库，专门提供了一个 SQLiteOpenHelper 帮助类，借助这个类就可以非常简单地对数据库进行创建和升级

SQLiteOpenHelper 是一个抽象类，想要使用它的话就需要创建一个自己的帮助类去继承它。SQLiteOpenHelper 中有两个抽象方法，分别是 onCreate() 和 onUpgrade()，我们必须在自己的帮助类里面重写这两个方法，然后分别在这两个方法中去实现创建、升级数据库的逻辑

SQLiteOpenHelper 还有两个非常重要的实例方法：getReadableDatabase() 和 getWritableDatabase()，这两个方法都可以创建或打开一个现有的数据库（如果数据库已存在则直接打开，否则创建新的数据库），并返回一个可对数据库进行读写操作的对象。不同的是当数据库不可写入的时候（如磁盘空间已满），getReadableDatabase() 方法返回的对象将以只读的方式去打开数据库，而 getWritableDatabase() 方法则将出现异常

SQLiteOpenHelper 中有两个构造方法可供重写，一般使用参数少一点的那个构造方法即可，这个构造方法中接收 4 个参数，第一个参数是 Context，必须要有它才能对数据库进行操作；第二个参数是数据库名，创建数据库时使用的就是这里指定的名称；第三个参数允许我们在查询数据的时候返回一个自定义的 Cursor，一般都是传入 null；第四个参数表示当前数据库的版本号，可用于对数据库进行升级操作，构建出 SQLiteOpenHelper 实例后，在调用它的 getReadableDatabase() 或 getWritableDatabase() 方法就能够创建数据库了，数据库文件会放在 /data/data/<package name>/database/ 目录下，此时重写的 onCreate() 方法也会得到执行，所以通常会在这里去处理一些创建表的逻辑

新建一个 DatabaseTest 项目，新建 MyDatabaseHelper 继承自 SQLiteOpenHelper

```java
public class MyDatabaseHelper extends SQLiteOpenHelper {
    
    //把建表语句定义成了一个字符串常量
    public static final String CREATE_BOOK = "create table Book ( "
            + "id integer primary key autoincrement, "
            + "author text, "
            + "price real, "
            + "pages integer, "
            + "name text) ";
    
    private Context mContext;
    
    //SQLiteOpenHelper 中有两个构造方法可供重写，一般使用参数少一点的那个构造方法即可，这个构造方法中接收 4 个参数，第一个参数是 Context，必须要有它才能对数据库进行操作；第二个参数是数据库名，创建数据库时使用的就是这里指定的名称；第三个参数允许我们在查询数据的时候返回一个自定义的 Cursor，一般都是传入 null；第四个参数表示当前数据库的版本号，可用于对数据库进行升级操作，构建出 SQLiteOpenHelper 实例后，在调用它的 getReadableDatabase() 或 getWritableDatabase() 方法就能够创建数据库了，数据库文件会放在 /data/data/<package name>/database/ 目录下，此时重写的 onCreate() 方法也会得到执行，所以通常会在这里去处理一些创建表的逻辑
    public MyDatabaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version){
        super(context, name, factory, version);
        mContext = context;
    }
    
    //在 onCreate() 方法中又调用了 SQLiteDatabase 的 execSQL() 方法去执行这条建表语句，并弹出一个 Toast 提示创建成功，这样保证数据库创建完成的时候还能成功创建 Book 表
    @Override
    public void onCreate(SQLiteDatabase db){
        db.execSQL(CREATE_BOOK);
        Toast.makeText(mContext, "Create succeeded", Toast.LENGTH_SHORT).show();
    }
    
    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion){
    }
    
}
```

修改 activity_main.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

	//加入一个按钮，用于创建数据库
    <Button
        android:id="@+id/create_database"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Create database" />

</LinearLayout>
```

修改 MainActivity 

```java
public class MainActivity extends AppCompatActivity {

    private MyDatabaseHelper dbHelper;
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        //在 onCreate() 方法中构建了一个 MyDatabaseHelper 对象，并且通过构造函数的参数将数据库名指定为 BookStore.db，版本号指定为 1
        dbHelper = new MyDatabaseHelper(this, "BookStore.db", null, 1);
        //在 createDatabase 按钮的点击事件里调用了 getWritableDatabase() 方法
        Button createDatabase = (Button) findViewById(R.id.create_database);
        createDatabase.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                dbHelper.getWritableDatabase();
            }
        });
    }
}
```

第一次点击 Create databse 按钮时，就会检测到当前程序中并没有 BOOKStore.db 这个数据库，于是会创建数据库并调用 MyDatabaseHelper 中的 onCreate() 方法，这样 Book 表也得到了创建，然后弹出一个 Toast 提示创建成功，再次点击按钮，会发现此时已经存在了 BookStore.db 数据库了，因此不会再创建一次，所以不会再有 Toast 弹出

使用 File Explorer 只能看到 databases 目录下出现一个 BookStore.db 文件，Book 表是无法通过 File Explorer 看到的，因此我们换成使用 adb shell 来对数据库和表的创建情况进行检查

adb 是 Android SDK 中自带的一个调试工具，该工具可以直接对连接在电脑上的手机或模拟器进行调试操作，让放在 sdk 的 platform-tools 目录下，在命令行中使用这个工具，需要把他的路径配置到环境变量里

输入 adb shell 出现 # 是超级管理员的意思是，也就是说现在你可以访问模拟器中的一切数据，如果命令行上是 $，那么表示你是普通管理员，输入 su 命令切换成超级管理员

使用 cd 命令进入到 /data/data/com.example.databasetest/databases/ 目录下，并使用 ls 命令查看到该目录里的文件

这个目录下出现了两个数据库文件，一个是我们创建的 BookStore.db 文件，另一个是 BookStore.db-journal 则是为了让数据库能够支持事务而产生的临时日志文件，通常情况下这个文件大小都是 0 字节

键入 sqlite3，后面加上数据库名即可打开数据库

打开数据库后就可以对数据库中的表进行管理，键入 .table 来查看数据库中有哪些表

其中有两张表， android_metadata 表是每个数据库中都会自动生成的，不用管它，另一张表 Book 就是我们在 MyDatabaseHelper 中创建的

通过 .schema 命令来查看检表语句

最后键入 .exit 或 .quit 命令可以退出数据库编辑，再键入 exit 命令就可以退出设备控制台



### 升级数据库

onUpgrade() 方法适用于对数据库进行升级的

修改 MyDatabaseHelper

```java
public class MyDatabaseHelper extends SQLiteOpenHelper {

    public static final String CREATE_BOOK = "create table Book ( "
            + "id integer primary key autoincrement, "
            + "author text, "
            + "price real, "
            + "pages integer, "
            + "name text)";

	//再添加一张 Category 的表
    public static final String CREATE_CATEGORY = "create table Category ( "
            + "id integer primary key autoincrement, "
            + "category_name text, "
            + "category_code integer)";

    private Context mContext;

    public MyDatabaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version){
        super(context, name, factory, version);
        mContext = context;
    }

    @Override
    public void onCreate(SQLiteDatabase db){
        db.execSQL(CREATE_BOOK);
        db.execSQL(CREATE_CATEGORY);
        Toast.makeText(mContext, "Create succeeded", Toast.LENGTH_SHORT).show();
    }

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion){
    }

}
```

运行后再点击按钮，不会弹出 Toast，运行 adb 工具再检查一下，Category 确实没有创建成功，因为 BookStore.db 数据库已经存在，之后无论再怎么点击按钮，MyDatabaseHelper 中的 onCreate() 方法都不会再次执行，因此新添加的表也就无法得到创建

一种方法是卸载程序，再重新运行，这是 BookStore.db 数据库不存在，再点击按钮就会执行 MyDatabaseHelper 中的 onCreate() 方法就会执行，做法和极端，可以运用 SQLiteOpenHelper 的升级功能轻松的解决这个问题

修改 MyDatabaseHelper 

```java
public class MyDatabaseHelper extends SQLiteOpenHelper {

    public static final String CREATE_BOOK = "create table Book ( "
            + "id integer primary key autoincrement, "
            + "author text, "
            + "price real, "
            + "pages integer, "
            + "name text)";

    public static final String CREATE_CATEGORY = "create table Category ( "
            + "id integer primary key autoincrement, "
            + "category_name text, "
            + "category_code integer)";

    private Context mContext;

    public MyDatabaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version){
        super(context, name, factory, version);
        mContext = context;
    }

    @Override
    public void onCreate(SQLiteDatabase db){
        db.execSQL(CREATE_BOOK);
        db.execSQL(CREATE_CATEGORY);
        Toast.makeText(mContext, "Create succeeded", Toast.LENGTH_SHORT).show();
    }

    // onUpgrade() 方法中执行了两条 DROP 语句，如果发现数据库中已经存在 Book 表或 Category 表，就将这两张表删除，再调用 onCreate() 方法，因为如果不删除数据库中存在了表，那么就会直接报错
    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion){
        db.execSQL("drop table if exists Book");
        db.execSQL("drop table if exists Category");
        onCreate(db);
    }

}
```

修改 SQLiteOpenHelper 的构造函数第四个参数，数据库的版本号，现在只要传入比 1 大的数就可以让 onUpgrade() 方法得到执行，修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    private MyDatabaseHelper dbHelper;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        //将数据库版本号指定为 2，表示我们对数据库进行了升级
        dbHelper = new MyDatabaseHelper(this, "BookStore.db", null, 2);
        Button createDatabase = (Button) findViewById(R.id.create_database);
        createDatabase.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                dbHelper.getWritableDatabase();
            }
        });
    }
}
```

重新运行程序后点击按钮出现了 Toast 提示创建成功，可通过 adb 进行验证表确实建立了



### 添加数据

对数据进行的操作无非有四种（CRUD），C 代表添加（Create），R 代表查询（Retrieve），U 代表更新（Update），D 代表删除（Delete），SQL语言添加数据使用 insert，查询数据使用 select，更新数据使用 update，删除数据用 delete

Android 提供了一系列的辅助性方法，使得不用去编写 SQL 语句也能完成所有的 CRUD 操作

调用 SQLiteOpenHelper 的 getReadableDatabase() 或 getWritableDatabase() 方法可以用于创建和升级数据库，不仅如此，这两个方法还都会返回一个 SQLiteDatabase 对象，借助这个对象就可以数据进行 CRUD 操作

向数据库的表中添加数据，SQLiteDatabase 中提供了一个 insert() 方法，它接收 3 个参数，第一个参数是表名，指定向那张表添加数据；第二个参数用于在未指定添加数据的情况下给某些可为空的列自动赋值 null，一般我们都用不到这个功能，直接传入 null 即可；第三个参数是一个 ContentValues 对象，它提供一系列的 put() 方法重载，用于向 ContentValues 中添加数据，只需要将表中的每个列名以及相应待添加数据传入即可

修改 activity_main.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <Button
        android:id="@+id/create_database"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Create database" />

    //新增了一个按钮，稍后在这个按钮的点击事件里编写添加数据的逻辑
    <Button
        android:id="@+id/add_data"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Add data" />

</LinearLayout>
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    private MyDatabaseHelper dbHelper;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        dbHelper = new MyDatabaseHelper(this, "BookStore.db", null, 2);
       
        ...
        
        Button addData = (Button) findViewById(R.id.add_data);
        addData.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                //先获取到 SQLiteDatabase 对象，然后使用 ContentValues 来对要添加的数据进行组装
                SQLiteDatabase db = dbHelper.getWritableDatabase();
                ContentValues values = new ContentValues();
                //id 那一列并没有给它赋值，因为在前面创建表的时候，我们就将 id 列设置为自增长，它的值会在入库的时候自动生成，所以不需要手动给它赋值
                //开始组装第一条程序
                values.put("name", "The Da Vinci Code");
                values.put("author", "Dan Brown");
                values.put("pages", 454);
                values.put("price", 16.96);
                //调用了 insert() 方法将数据添加到了表当中
                db.insert("Book", null, values);//插入第一条数据
                //开始组装第二条程序
                values.put("name", "The Lost Symbol");
                values.put("author", "Dan Brown");
                values.put("pages", 510);
                values.put("price", 19.95);
                db.insert("Book", null, values);//插入第二条数据
            }
        });
    }
}
```

点击一下 Add data 按钮，打开 BookStore.db，输入 select * from Book; 查询 Book 表中的数据



### 更新数据

SQLiteDatabase 中也提供了一个非常好用的 updata() 方法，用于对数据进行更新，这个方法接收 4 个参数，第一个参数和 insert() 方法一样是表名，在这里指定去更新哪张表里的数据；第二个参数是 ContentValues 对象，要把更新数据在这里组装进去；第三四个参数用于约束更新某一行或某几行中的数据，不指定的话默认就是更新所有行

修改 activity_main.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

	...

    //添加了一个用于更新数据的按钮
    <Button
        android:id="@+id/update_data"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Update data" />

</LinearLayout>
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    private MyDatabaseHelper dbHelper;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        dbHelper = new MyDatabaseHelper(this, "BookStore.db", null, 2);

		...

        Button updateData = (Button) findViewById(R.id.update_data);
        updateData.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                SQLiteDatabase db = dbHelper.getWritableDatabase();
                //构建一个 ContentValues 对象，并且给它指定了一组数据，说明我们只是想把价格这一列的数据更新成 10.99，然后调用了 SQLiteDatabase 的 update() 方法去执行具体的更新操作
                ContentValues values = new ContentValues();
                values.put("price", 10.99);
                //这里 update() 方法的第三、四个参数来指定具体更新到哪行，第三个参数对应的是 SQL 语句的 where 部分，表示更新所有 name 等于 ？的行，而 ？是一个占位符，可以通过第四个参数提供的一个字符串数组为第三个参数中的每个占位符指定相应的内容
                db.update("Book", values, "name = ?", new String[]{"The Da Vinci Code"});
                //以上代码意图是将名字是 The Da Vinci Code 的这本书的价格改成 10.99
            }
        });
    }
}
```



### 删除数据

SQLiteDatabase 中提供了一个 delete() 方法，专门用于删除数据，这个方法接收 3 个参数，第一个参数是表名，第二、三个参数又是用于约束删除某一行或某几行的数据，不指定的话默认就是删除所有行

修改 acticity_main.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

	...
    
    //添加一个按钮，用于删除数据
    <Button
        android:id="@+id/delete_data"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Delete data" />

</LinearLayout>
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    private MyDatabaseHelper dbHelper;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        dbHelper = new MyDatabaseHelper(this, "BookStore.db", null, 2);

        ...
        
        //在删除按钮的点击时间里指明去删除 Book 表中的数据，并通过第二、三个参数来指定仅删除那些页数超过 500 页的书
        Button deleteButton = (Button) findViewById(R.id.delete_data);
        deleteButton.setOnClickListener(new View.OnClickListener(){
            @Override
            public void onClick(View v){
                SQLiteDatabase db = dbHelper.getWritableDatabase();
                db.delete("Book", "pages > ?", new String[]{"500"});
            }
        });
    }
}
```



### 查询数据

SQLiteDatabase 提供了一个 query() 方法用于对数据进行查询，该方法最短的一个需要传入七个参数，第一个参数是表名；第二个参数是用于指定趣查询哪几列，如果不指定则默认查询所有列；第三、四个参数用于约束查询某一行或某几行的数据，不指定则默认查询所有行的数据；第五个参数用于指定需要去 group by 的列，不指定则表示不对查询结果进行 group by 操作；第六个参数用于对 group by 之后的数据进一步过滤，不指定则表示不进行过滤；第七个参数用于指定查询结果的排列方式，不指定则表示使用默认的排序方式

修改 activity_main.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

 	...

    //添加一个按钮用于查询数据
    <Button
        android:id="@+id/query_data"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Query data" />

</LinearLayout>
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    private MyDatabaseHelper dbHelper;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        dbHelper = new MyDatabaseHelper(this, "BookStore.db", null, 2);

	   ...

        //在查询按钮的点击事件里面调用了 SQLiteDatabase 的 query() 方法去查询数据
        Button queryButton = (Button) findViewById(R.id.query_data);
        queryButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                SQLiteDatabase db = dbHelper.getWritableDatabase();
                //查询 Book 表中的所有数据，只是使用了第一个参数指明去查询 Book 表，后面的参数全为 null，表示查询该表中的所有数据，查询之后得到了一个 Cursor 对象，接着调用它的 moveToFirst() 方法将数据的指针移动到了第一行的位置，然后进入到了一个循环当中去遍历查询到的每一行数据
                Cursor cursor = db.query("Book", null, null, null, null, null, null);
                if (cursor.moveToFirst()) {
                    //循环中通过 Cursor 的 getColumnIndex() 方法获取到某一列在表中对应的位置索引，然后将这个索引传入到相应取值方法中，就可以得到从数据库中读取到的数据，
                    do {
                        //遍历 Cursor 对象，取出数据并打印
                        String name = cursor.getString(cursor.getColumnIndex("name"));
                        String author = cursor.getString(cursor.getColumnIndex("author"));
                        int pages = cursor.getInt(cursor.getColumnIndex("pages"));
                        double price = cursor.getDouble(cursor.getColumnIndex("price"));
                        //使用 Log 的方式将取出的数据打印出来，借此来检查一下读取数据工作有没有成功完成
                        Log.d("MainActivity", "book name is " + name);
                        Log.d("MainActivity", "author name is " + author);
                        Log.d("MainActivity", "pages name is " + pages);
                        Log.d("MainActivity", "price name is " + price);
                    } while (cursor.moveToNext());
                }
                //调用 close() 方法来关闭 Cursor
                cursor.close();
            }
        });
    }
}
```



### 使用 SQL 操作数据库

添加、更新、删除均是

```java
db.execSQL(" ****** ");//***填写 SQL 语句
```

查询

```java
db.rawQuery(" ****** ");
```





### 使用 LitePal 操作数据库

新建一个 LitePalTest 项目



### LitePal 简介

LitePal 是一个开源的数据库框架，它采用了对象关系映射（ORM）的模式，并将我们平时开发最常用到的一些数据库功能进行封装，使得不用编写一行 SQL 语句就可以完成各种建表和增删改查的操作



### 配置 LitePal

大多数开源的项目都会将版本提交到 jcenter 上，我们只需要在 app/build.gradle 文件声明该开源库的引用就可以

编辑 app/build.gradle

```java
dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    implementation 'com.android.support:appcompat-v7:28.0.0'
    testImplementation 'junit:junit:4.12'
    //添加这一行声明中前面的部分是固定的，最后的 1.4.1 是版本号的意思
    implementation 'org.litepal.android:core:1.4.1'
}
```

右击 app/src/main 目录 -> New -> Directory，创建一个 asserts 目录，然后在 assets 目录下再新建一个 litepal.xml 文件，编辑 litepal.xml

```java
<?xml version ="1.0" encoding ="utf-8"?>
<litepal>
	//<dbname> 标签用于指定数据库名
    <dbname value="BookStore"></dbname>

	//<version> 标签用于指定数据库版本号
    <version value="1"></version>

	//<list> 用于指定所有的映射模型
    <list>
    </list>
</litepal>
```

 配置 LitePalApplication，修改 AndroidManifest.xml

```java
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.litepaltest">

    <application
    	//将项目的配置为 org.litepal.LitePalApplication，这样才能让 LitePal 的所有功能都可以正常工作
        android:name="org.litepal.LitePalApplication"
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">

	    ...

    </application>

</manifest>
```



### 创建和升级数据库

将 activity_main.xml 布局文件从 DatabaseTest 项目复制到 ListPalTest 项目中

LitePal 采用的是映射模式（ORM），我们使用的编程语言是面向对象语言，而使用的数据库则是关系型数据库，将面向对象的语言和面向关系的数据库之间建立一种映射关系，这就是对象关系映射

面向对象的思维来错做数据库，不用再和 SQL 语句打交道了

新建一个 Book 类

```java
public class Book {

    private int id;

    private String author;

    private double price;

    private int pages;

    private String name;

    public int getId(){
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getAuthor() {
        return author;
    }

    public void setAuthor(String author) {
        this.author = author;
    }

    public double getPrice() {
        return price;
    }

    public void setPrice(double price) {
        this.price = price;
    }

    public int getPages() {
        return pages;
    }

    public void setPages(int pages) {
        this.pages = pages;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

快速生成 getter 和 setter 方法

- code -> Generate
- Alt + Insert 键

shift 键将所有字段都选中

Book 类就会对应数据库中的 Book 表，列中的每一个字段分别对应了表中的没一个列，这就是对象关系映射最直观的体验，还需要将 Book 类添加到映射模型列表当中，修改 litepal.xml

```java
<litepal>
    <dbname value="BookStore"></dbname>

    <version value="1"></version>

    <list>
    	//使用 <mapping> 标签来声明我们要配置的映射模型类，注意一定要使用完整的类名，不管有多少模型需要映射，都是用同样的方法配置在 <list> 标签下即可
        <mapping class="com.example.litepaltest.Book"></mapping>
    </list>
</litepal>
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button createDatabase = (Button) findViewById(R.id.create_database);
        createDatabase.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                //调用 LitePal.getDatabase() 方法，只要点击一下按钮就会自动创建数据库
                LitePal.getDatabase();
            }
        });
    }
}
```

点击 CREATE DATABASE 按钮后可以看到新建了三张表，其中 android_metadata 不用管，table_schema 表是  LitePal 内部使用的， book 表就是根据我们定义的 Book 类以及类中的字段来自动生成的

SQLiteOpenHelper 升级数据库的时候我们需要先把之前的表 drop 掉，然后再重新建才行，这样会造成每升级一次数据库之前表中的数据就全没了。而 LitePal 只需要改你想要改的任何内容，然后再版本号加 1 就行,

修改 Book 

```java
package com.example.litepaltest;

public class Book {

	...

    private String press;

    public String getPress() {
        return press;
    }

    public void setPress(String press) {
        this.press = press;
    }

	...
	
}
```

添加一张 Category 表，只需要新建一个 Category 的类

```java
public class Category {
    
    private int id;
    
    private String categoryName;
    
    private int categoryCode;

    public void setId(int id) {
        this.id = id;
    }

    public void setCategoryName(String categoryName) {
        this.categoryName = categoryName;
    }

    public void setCategoryCode(int categoryCode) {
        this.categoryCode = categoryCode;
    }
}
```

添加了一个新的模型类，因此需要将它添加到映射模型列表中，修改 litepal.xml

```java
<?xml version ="1.0" encoding ="utf-8"?>
<litapal>
    <dbname value="BookStore"></dbname>

	//改完了想要改的东西之后只需要记得把版本号加 1 就行
    <version value="2"></version>

    <list>
        <mapping class="com.example.litepaltest.Book"></mapping>
        <mapping class="com.example.litepaltest.Category"></mapping>
    </list>
</litapal>
```

这样 book 表中新增了一个 press 列，category 表也创建成功了，LitePal 还自动帮我们保留了之前表中的所有数据



### 使用 LitePal 添加数据

LitePal 添加数据只需要创建出模型类的实例，再将所有的要存储的数据设置好，最后调用一下 save() 方法就可以

LitePal 进项表管理操作室不需要模型类有任何的继承结构，但是进行 CRUD 操作时就不行了，必须要继承自 DataSupport 类才行

修改 Book

```java
public class Book extends DataSupport {
	...
}
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
	    
        ...
            
        Button addData = (Button) findViewById(R.id.add_data);
        addData.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                //创建一个 Book 实例，再调用 Book 类中的各种 set 方法对数据进行设置，最后调用 book.save() 方法就能完成数据的添加操作
                Book book = new Book();
                book.setName("The Da Vinci Code");
                book.setAuthor("Dan Brown");
                book.setPages(454);
                book.setPrice(16.96);
                book.setPress("Unknow");
                book.save();
            }
        });
    }
}
```

点击一次 Add data 按钮数据就添加成功了



### 使用 LItePal 更新数据

使用 LitePal 更新数据的 API 接口比较多，最简单的一种更新方式就是对已存储的对象重新设值，然后调用 save() 方法即可

对于 LitePal，对象是否已存储就是根据 model.isSaved() 方法的结果来判断的，返回 true 就表示已存储，返回 false 就表示为存储。实际上只有两种情况下 model.isSaved() 方法才会返回 true，一种情况时已经调用过了 model.save() 方法去添加数据了，此时 model 会被认为是已存储的对象；另一种情况是 model 对象是通过 LitePal 提供的查询 API 查出来的，由于是从数据库中查到的对象，因此也会被认为是已存储的对象，接下来使用第一种方法

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        ...
        
        Button updateData = (Button) findViewById(R.id.update_data);
        updateData.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Book book = new Book();
                //添加了一条 Book 数据，然后调用 setPrice() 方法将这本书进行修改，之后再次调用 save() 方法，此时 LitePal 会发现当前的 Book 对象是已存储的，因此不会再向数据库中去添加一条新数据，而是会直接更新当前数据
                book.setName("The Lost Symbol");
                book.setAuthor("Dan Brown");
                book.setPages(510);
                book.setPrice(19.95);
                book.setPress("Unknow");
                book.save();
                book.setPrice(10.99);
                book.save();
            }
        });
    }
}
```

改方法限制性比较大，另一种方法，修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

		...

        Button updateData = (Button) findViewById(R.id.update_data);
        updateData.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Book book = new Book();
                book.setPrice(14.95);
                book.setPress("Anchor");
                //这里我们将指定书名是 The Lost Symbol 并且作者是 Dan Brown 的书价更新为 14.95，出版社更新为 Anchor
                book.updateAll("name = ? and author = ?", "The Lost Symbol", "Dan Brown");
            }
        });
    }
}
```

使用 updateAll() 方法时，当你想要把一个字段的值更新成默认值时，是不可以使用上面的方式来 set 数据的，因为 Java 中任何一种数据类型的字段都会有默认值，例如：int 类型的默认值是 0，boolean 类型的默认值是 false，String 类型的默认值是 null，当 new 一个对象时，其实所有字段都已经被初始化成了默认值，而此时只能通过 setToDefault() 方法然后传入相应的列名就可以实现了

```java
Book book = new Book();
book.setToDeafult("pages");
//这里 updateAll() 方法中没有指定约束条件，因此更新操作对所有数据都生效了
book.updateAll();
```



### 使用 LitePal 删除数据

LitePal 删除数据的方式主要有两种，第一种是直接调用已存储对象的 delete() 方法就可以了，即调用过 save() 方法的对象，或者通过 LitePal 提供的查询 API 查出来的对象都是可以直接使用 delete() 方法来删除数据的，下面使用另一种方法

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

		...

        Button deleteButton = (Button) findViewById(R.id.delete_data);
        deleteButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                //删除表中价格低于 15 的书
                //调用了 DataSupport.deleteAll() 方法来删除数据，第一个参数用于指定那张表中的数据，Book.class 意味着删除 Book 表中的数据，后面的参数用于指定约束条件，如果 DataSupport.deleteAll() 方法如果不指定约束条件就意味着删除表中的所有数据
                DataSupport.deleteAll(Book.class, "price < ?", "15");
            }
        });
    }
}
```



### 使用 LIitePal 查询数据

上面我们使用了 query() 方法

```java
Cursor cursor = db.query("Book", null, null, null, null, null, null);
```

LitePal 则是通过

```java
//调用 findAll() 方法，然后通过 Book.class 参数指定查询 Book 表就可以，另外 findAll() 方法的返回值时一个 Book 类型的 List 集合，我们不用向 Cursor 一样一个个去取值，LitePal 已经自动帮我们完成了赋值操作
List<Book> books = DataSupprot.findAll(Book.class);
```

修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

		...

        Button queryButton = (Button) findViewById(R.id.query_data);
        queryButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                List<Book> books = DataSupport.findAll(Book.class);
                for (Book book : books) {
                    Log.d("MainActivity", "book name is " + book.getName());
                    Log.d("MainActivity", "book author is " + book.getAuthor());
                    Log.d("MainActivity", "book pages is " + book.getPages());
                    Log.d("MainActivity", "book price is " + book.getPrice());
                    Log.d("MainActivity", "book press is " + book.getPress());
                }
            }
        });
    }
}
```

除了 findAll() 方法之外，还可以

```java
//查询 Book 表中的第一条数据
Book firstBook = DataSupport.findFrist(Book.class);
//查询 Book 表中最后一条数据
Book lastBook = DataSupprot.findLast(Book.class);
```

- select() 方法用于指定查询哪几列的数据，对应了 SQL 当中的 select 关键字，例如查询 name 和 author 这两列数据：

  ```java
  List<Book> books = DataSupport.select("name", "author").find(Book.class);
  ```

- where() 方法用于指定查询的约束条件，对应了 SQL 当中的 where 关键字，例如只查页数大雨 400 的数据：

  ```java
  List<Book> books = DataSupport.where("pages > ?", "400").find(Book.class);
  ```

- order() 方法用于指定结果的排列方式，对应了 SQL 当中的 order by 关键字，例如将查询结果按照暑假从高到低排序：

  ```java
  List<Book> books = DataSupport.order("price desc").find(Book.class);
  //desc 表示降序排列，asc 或者不写表示升序排列
  ```

- limit() 方法用于指定查询结果的数量，例如只查表中的前 3 条数据：

  ```java
  List<Book> books = DataSupport.limit(3).find(Book.class);
  ```

- offset() 方法用于指定查询结果的偏移量，例如查询表中的第 2 条、第 3 条、第 4 条数据：

  ```java
  List<Book> books = DataSupport.limit(3).offset(1).find(Book.class);
  //limit(3) 查询前 3 调数据，offset(1) 偏移了一个位置，就实现了查询表中的第 2 条、第 3 条、第 4 条数据
  ```

- 这 5 个方法还可以进行任意组合

  ```java
  //查询 Book 表中第 11~20 条满足页数大于 400 这个条件的 name、author 和 pages 这三列数据，并将查询结果按照页数升序排列
  List<Book> books = DataSupport.select("name", "author", "pages")
  						    .where("pages > ?", "400")
  						    .order("pages")
  						    .limit(10)
  						    .offset(10)
  						    .find(Book.class);
  ```

使用 LitePal 我们需要用到一个方法的时候直接连缀一下就可以，不需要的话可以不写，而不是像 query() 方法一样，不管需不需要用到都传要固定的参数进去才行

- LitePal 仍然支持原生的 SQL 语句来进行查询

  ```java
  //第一个参数用于指定 SQL 语句，后面的参数用于之地你给占位符的值
  Cursor c = DataSupport.findBySQL("selsct * from Book where pages > ? and price < ?", "400", "20");
  ```

findBySQL() 方法返回的是一个 Cursor 对象，接下来还需要向之前一样一一取出才行

