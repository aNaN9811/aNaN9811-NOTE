# 第三章：软件也要拼脸蛋——UI 开发的点点滴滴

新建一个 UIWidgetTest



## 常用控件的使用方法

### TextView（显示文本信息）

主要用于在界面上显示一段文本信息

修改 activity_main.xml 中的代码

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    
    <TextView
        android:id="@+id/text_view"//给当前控件定义一个唯一标识符
        android:layout_width="match_parent"//指定了控件的宽度
        android:layout_height="wrap_content"//指定了控件的高度
        android:text="This is TextView" />
</LinearLayout>
```

Android 中所有的的控件都具有这两个属性，可选只有3中：match_parent、fill_parent 和 wrap_content，其中 match_parent 和 fill_parent 的意义相同，现在官方更加推荐使用 match_parent，match_parent 表示让当前控件的大小和父布局一样，也就是由父布局来决定当前控件的大小，wrap_content 表示让当前控件的大小能够刚好包含住里面的内容，也就是控件内容决定当前控件的大小，当然除了上述值，你也可以对控件的宽和高度指定一个固定的大小，但是这样做有时会在不同手机的屏幕的适配方面出现问题

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    
    <TextView
        android:id="@+id/text_view"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        //可以通过使用 android:gravity 来指定文字的对齐方式，可选值有 top、bottom、left、right、center等，可以用 “|” 来同时指定多个值，这里我们指定的 center，效果等同于 center_vertical | center_horizontal，表示文字在垂直和水平方向都居中对齐
        android:gravity="center"//指定文字的对齐方式
        android:text="This is TextView" />
</LinearLayout>
```

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:id="@+id/text_view"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:gravity="center"
        android:textSize="24sp"//指定文字的大小
        android:textColor="#00ff00"//指定文字的颜色
        android:text="This is TextView" />
</LinearLayout>
```





### Button（按钮）

在 activity_main.xml 中加入 Button

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

......

	<Button
        android:id="@+id/button"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Button"/>
</LinearLayout>
```

在布局文件里面设置的文字是 ”Button“，但最终显示结果却是 "BUTTON"，这是由于系统对 Button 中的所有英文字母自动进行大写转换，如果不想要这效果，可以使用下面配置来禁用这一默认特性

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

......
        
    <Button
        android:id="@+id/button"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Button"
        //禁用 Button 中的所有英文字母自动进行大写转化
        android:textAllCaps="false"/>
</LinearLayout>
```

接下来我们可以 MAinActivity 中为 Button 的点击事件注册一个监听器

```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button = (Button) findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener(){
           public void onClick(View v){
               //在此处添加逻辑
           } 
        });
    }
}
```

每当点击按钮式，就会执行监听器中的 onClick() 方法，我么你只需要在这个方法中加入待处理的逻辑就行了，如果不喜欢匿名内部类的方式来注册监听器，也可以使用实现接口的方式来进行注册

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener{

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button = (Button) findViewById(R.id.button);
        button.setOnClickListener(this);
    }
    @Override
    public void onClick(View v){
        switch (v.getId()){
            case R.id.button:
                //在此处添加逻辑
                break;
            default;
                break;
        }
    }
}
```





### EditText（输入框）

EditText 是程序用于和用户进行交互的另一个重要控件，它允许用户在控件例输入和编辑内容，并可以砸程序中对这些内容进行处理

修改 activity_main.xml 中的代码

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

   ......
        
    <EditText
        android:id="@+id/edit_text"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />
</LinearLayout>
```

总结：Android 控件的使用规律，用法基本上都很相似：给控件定义一个 id，在指定控件的宽度和高度，然后再适当加入一些控件特有的属性就差不多了

输入框里显示一些提示性的文字，然后一旦用户输入了任何内容，这些提示性的文字就会消失

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

   ......
        
    <EditText
        android:id="@+id/edit_text"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        //使用了 android:hint 属性指定了一段提示性的文本
        android:hint="Type something here"
        />
</LinearLayout>
```

随着输入的内容不断增多，EdiText 会被不断地拉长

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

   ......
        
    <EditText
        android:id="@+id/edit_text"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="Typr something here"
        //通过 android:maxLines 指定了 EditText 的最大行数为两行，这样单输入的内容超过两行是，文本就会向上滚动，而 EditText 则不会再继续拉伸
        android:maxLines="2"
        />
</LinearLayout>
```

结合使用 EditText 也 Button 来完成一些功能，修改 MainActivity 中的代码

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener{

    private EditText editText;
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button = (Button) findViewById(R.id.button);
        //通过 findCiewById() 方法得到 EditText 的实例
        editText = (EditText) findViewById(R.id.edit_text); 
        button.setOnClickListener(this);
    }
    @Override
    public void onClick(View v){
        switch (v.getId()){
            case R.id.button:
                //在按钮的点击事件里调用 EditText 的 getText() 方法获取到输入的内容，再调用 toString() 方法转换成字符串，最后还是老方法使用 Toast 将输入的内容显示出来
                String inputText = editText.getText().toString();
                Toast.makeText(MainActivity.this, inputText,
                        Toast.LENGTH_SHORT).show();
                break;
            default:
                break;
        }
    }
}
```





### ImageView（在界面上展示图片）

ImageView 是用于在界面上展示图片的一个控件，它可以让我们的程序界面变得更加丰富多彩

在 res 目录下创建一个 drawable-xhdpi 目录，然后把准备好的照片 img_1.png 和 img_2.png 放到该目录当中

修改 activity_main.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

......

    <ImageView
        android:id="@+id/image_view"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        //使用 android:src 属性给 ImageView 指定了一张图片
        android:src="@drawable/img_1"
        />
</LinearLayout>
```

修改 MainActivity 的代码

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener{

    private EditText editText;

    private ImageView imageView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button = (Button) findViewById(R.id.button);
        editText = (EditText) findViewById(R.id.edit_text);
        imageView = (ImageView) findViewById(R.id.image_view);
        button.setOnClickListener(this);
    }
    @Override
    public void onClick(View v){
        switch (v.getId()){
            case R.id.button:
                //在点击按钮事件里，通过调用 ImageView 的 setImageResource() 方法将显示的图片改成 img_2
                imageView.setImageResource(R.drawable.img_2);
                String inputText = editText.getText().toString();
                Toast.makeText(MainActivity.this, inputText,
                        Toast.LENGTH_SHORT).show();
                break;
            default:
                break;
        }
    }
}
```





### ProgressBar（显示一个进度条）

ProgressBar 用于在界面上显示一个进度条，表示我们的程序正在加载一些数据

修改 activity_main.xml 的代码

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

......

    <ProgressBar
        android:id="@+id/progress_bar"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />
</LinearLayout>
```

Android 控件的可见属性，所有的 Android 控件都有这个属性，可以通过 android:visibility 进行制定，可选值有3种：

- visible（表示控件是可见的，这个只是默认值，不指定 android:visibility 时，控件都是可见的）
- invisible（表示控件不可见的，但是它仍然占据着原来的位置和大小，可以理解成控件编程透明状态了） 
- gone（表示控件不仅不可见，而且不再占用任何屏幕空间）
- 此外还可以通过代码来设置控件的可见性，使用 setVisibililty() 方法，可以传入 View.VISIBLE、View.INVISIBLE 和 View.GONE 这三种值

修改 MAinActivity 中的代码

```JAVA
public class MainActivity extends AppCompatActivity implements View.OnClickListener{

    private EditText editText;

    private ImageView imageView;
    
    private ProgressBar progressBar;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button = (Button) findViewById(R.id.button);
        editText = (EditText) findViewById(R.id.edit_text);
        imageView = (ImageView) findViewById(R.id.image_view);
        progressBar = (ProgressBar) findViewById(R.id.progress_bar); 
        button.setOnClickListener(this);
    }
    @Override
    public void onClick(View v){
        switch (v.getId()){
            case R.id.button:
                //通过 getVisibility() 方法来判断 ProgressBar 是否可见，如果可见就将 ProgressBar 隐藏掉，如果不可见就将 ProgressBar 显示出来
                if(progressBar.getVisibility() == View.GONE){
                    progressBar.setVisibility(View.VISIBLE);
                }else{
                    progressBar.setVisibility(View.GONE);
                }
                break;
            default:
                break;
        }
    }
}
```

给 ProgressBar 指定不同的样式，修改 activity_main.xml 的代码

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

......

    <ProgressBar
        android:id="@+id/progress_bar"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        //通过 style 属性可以将它指定成水平进度条
        style="?android:attr/progressBarStyleHorizontal"
        //通过 android:max 属性给进度条设置一个最大值
        android:max="100"/>
</LinearLayout>
```

修改 MainActivity 中的代码

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener{
    
......
    
    @Override
    public void onClick(View v){
        switch (v.getId()){
            case R.id.button:
                //在代码中动态地更改进度条的进度
                int progress = progressBar.getProgress();
                progress = progress + 10;
                progressBar.setProgress(progress);
                break;
            default:
                break;
        }
    }
}

```





### AlertDialog（置顶于所有界面元素之上的对话框）

AlertDialog 可以在当前的界面弹出一个对话框，这个对话框是置顶于所有界面元素之上的，能够屏蔽掉其他控件的交互能力，因此 AlertDialog 一般都是用于提示一些非常重要的内容或者警告信息

修改 MAinActivity 中的代码

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener{

......
    
    @Override
    public void onClick(View v){
        switch (v.getId()){
            case R.id.button:
                //通过 AlertDialog.Builder 创建一个 AlertDialog 的实例，然后为这个对话框设置标题、内容、可否用 Back 键关闭对话框等属性
                AlertDialog.Builder dialog = new AlertDialog.Builder(MainActivity.this);
                dialog.setTitle("This is Dialog");
                dialog.setMessage("Something important.");
                dialog.setCancelable(false);
                //为对话框设置确定按钮的点击事件
                dialog.setPositiveButton("OK", new DialogInterface.OnClickListener(){
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                    }
                });
                //设置取消按钮的点击事件
                dialog.setNegativeButton("Cancel", new DialogInterface.OnClickListener(){
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                    }
                });
                //将对话框显示出来
                dialog.show();
                break;
            default:
                break;
        }
    }
}
```





### ProgressDialog（显示进度条的所有元素至上的对话框）

ProgressDialog 和 AlertDialog 有点类似，都可以在界面上弹出一个对话框，都能够屏蔽其他控件的交互能力，不同的是，ProgressDialog 会在对话框中显示一个进度条，一般用于表示当前操作比较耗时，让用户耐心的地等待

修改 MainActivity 中的代码

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener{

......

    @Override
    public void onClick(View v){
        switch (v.getId()){
            case R.id.button:
                //构建一个 ProgressDialog 对象
                ProgressDialog progressDialog = new ProgressDialog(MainActivity.this);
                //设置标题属性
                progressDialog.setTitle("This is progressDialog");
                //设置内容属性
                progressDialog.setMessage("Loading...");、
                //可否取消属性，如果传入 false 则表示 ProgressDialog 是不能通过 Back 键取消掉的，这时需要代码中做好控制，当数据加载完成后必须要调用 ProgressDialog 的 dismisss() 方法来关闭对话框，否则 ProgressDialog 将会一直存在
                progressDialog.setCancelable(true);
                //调用 show() 方法将 ProgresDialog 显示出来
                progressDialog.show();
                break;
            default:
                break;
        }
    }
}
```





### 详解四种基本布局

布局是一种可用于放置很多控件的容器，它可以按照一定的规律调整内部控件的位置，从而编写出精美的界面，当然布局的内部也可以放置布局，通过多层布局的嵌套就能够完成一些比较复杂的界面实现

新建一个 UILayoutTest





### 线性布局LinearLayout

LinearLayout 又称线性布局，这个布局会将他所包含的控件在线性方向上依次排列

修改 activity_main.xml 中的代码

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <Button
        android:id="@+id/button1"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Button 1"/>
    <Button
        android:id="@+id/button2"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Button 2"/>
    <Button
        android:id="@+id/button3"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Button 3"/>
</LinearLayout>
```

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    //将 android:orientation 属性值改成了 horizontal，这就意味着要让 LinearLayout 中的控件在水平方向上依次排列
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

......

</LinearLayout>
```

如果不指定 android:orientation 属性的值，默认的排列方式就是 horizontal

注意：如果 LinearLayout 的排列方式是 horizontal，内部的控件就绝对不能将宽度指定为 match_parent，因为这样的话单独一个控件就会将整个水平方向占满了，其他的控件就没有可放的位置。同样，如果 LinearLayout 的排列方向是 vertical，内部的控件就不能将高度指定为 match_parent

修改 activity_main.xml 中的代码

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <Button
        android:id="@+id/button1"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        //顶部
        android:layout_gravity="top"
        android:text="Button 1"/>
    <Button
        android:id="@+id/button2"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        //垂直居中
        android:layout_gravity="center_vertical"
        android:text="Button 2"/>
    <Button
        android:id="@+id/button3"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        //底部
        android:layout_gravity="bottom"
        android:text="Button 3"/>
</LinearLayout>
```

android:gravity 用于指定文字在控件中的对齐方式，而 android:layout_gravity 用于指定控件杂布局中的对齐方式

注意：LinearLayout 的排列方向是 horizontal 时，只有垂直方向上的对齐方式才会生效，因为此时水平方向上的长度是不固定的，每添加一个控件，水平方向上的长度都会改变，因而无法指定该方向上的对齐方式，同理，当 LinearLayout 的排列方向是 vertical 时，只有水平方向上的对齐方式才会生效

修改 activity_main.xml 中的代码

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <EditText
        android:id="@+id/input_message"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:hint="Type something"
        />
    <Button
        android:id="@+id/send"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:text="Send"
        />
</LinearLayout>
```

这里将 android:layout_weight 属性的值指定为1，这表示 EditText 和 Button 将杂水平方向上平分宽度，原理是，系统会先把 LinearLayout 下所有控件指定的 layout_weight 值相加，得到一个总值，然后每个控件所占大小的比例就是用该控件的 layout_weight 值除以刚才算出的总值

修改 activity_main.xml 中的代码

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <EditText
        android:id="@+id/input_message"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:hint="Type something"
        />
    <Button
        android:id="@+id/send"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Send"
        />
</LinearLayout>
```

这种方式编写的界面，不仅在各种屏幕的适配方面会非常好，而且看起来更加舒服





### 相对布局RelativiLayout

RelativiLayout 又称作相对布局，它可以通过相对定位的方式让控件出现在布局的任何位置

修改 activity_main.xml 中的代码

```java
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

	//让 Button1 和父对局的左上角对齐
    <Button
        android:id="@+id/button1"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentLeft="true"
        android:layout_alignParentTop="true"
        android:text="Button 1"
        />
    //让 Button2 和父布局的右上角对齐
    <Button
        android:id="@+id/button2"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentRight="true"
        android:layout_alignParentTop="true"
        android:text="Button 2"
        />
    //让 Button3 居中显示
    <Button
        android:id="@+id/button3"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_centerInParent="true"
        android:text="Button 3"
        />
    //让 Button4 和父布局左下角对齐
    <Button
        android:id="@+id/button4"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentBottom="true"
        android:layout_alignParentLeft="true"
        android:text="Button 4"
        />
    //让 Button5 和父布局的右下角对齐
    <Button
        android:id="@+id/button5"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentBottom="true"
        android:layout_alignParentRight="true"
        android:text="Button 5"
        />
</RelativeLayout>
```

修改 activity_main.xml 中的代码

```java
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <Button
        android:id="@+id/button3"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_centerInParent="true"
        android:text="Button 3"
        />
    <Button
        android:id="@+id/button1"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        //让一个控件位于另一个控件的上方，即 Button 3 的上方
        android:layout_above="@id/button3"
        //让一个控件位于另一个控件的左侧
        android:layout_toLeftOf="@id/button3"
        android:text="Button 1"
        />
    <Button
        android:id="@+id/button2"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_above="@id/button3"
        //让一个控件位于另一个控件的右侧
        android:layout_toRightOf="@id/button3"
        android:text="Button 2"
        />
    <Button
        android:id="@+id/button4"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        //让一个控件位于另一个控件的下方
        android:layout_below="@id/button3"
        android:layout_toLeftOf="@id/button3"
        android:text="Button 4"
        />
    <Button
        android:id="@+id/button5"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_below="@id/button3"
        android:layout_toRightOf="@id/button3"
        android:text="Button 5"
        />
</RelativeLayout>
```

注意：当一个控件去引用另一个控件的 id 时，该控件一定要定义在引用控件的后面，不然会出现找不到 id 的情况

RelativeLayout 中还有另外一组相对于控件进行定位的属性，android:layout_alignLeft 表示一个控件的左边缘和另一个控件的左边缘对齐，android:layout_alignRight 表示让一个控件的右边缘和另一个控件的右边缘对齐





### 帧布局FrameLayout

FrameLayout 又称作帧布局，这种布局没有方便的定位方式，所有的控件都会默认摆放在布局的左上角

修改 activity_main.xml 中的代码

```java
//FrameLayout 中放置了一个 TextView 和一个 ImageView
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:id="@+id/text_view"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="This is TextView"
        />
    //当前项目没有准备任何照片，所以这里 ImageView 直接使用了 @mipmap 来访问 ic_launcher 这张图
    <ImageView
        android:id="@+id/image_view"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:src="@mipmap/ic_launcher"
        />
</FrameLayout>
```

可以看到文字和图片都是位于布局的左上角，由于 ImageView 是在 TextView 之后添加的，因此图片压在了文字的上面

修改 activity_main.xml 中的代码

```java
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:id="@+id/text_view"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="left"
        android:text="This is TextView"
        />
    <ImageView
        android:id="@+id/image_view"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="right"
        android:src="@mipmap/ic_launcher"
        />
</FrameLayout>
```

除了默认效果之外，还可以使用 layout_gravity 属性来指定控件在布局中的对齐方式，这和 LinearLayout 中的用法相似





### 百分比布局

前面 3 种布局都是从 Android 1.0 版本中就开始支持了，其中只有 LinearLayout 支持使用 layout_weight 属性来实现按比例指定控件大小的功能，其他两种布局都不支持。比如说，如果想用 RelativeLayout 来实现让两个按钮平分布局宽度的效果，则是比较困难的

为此，Android 引入了一种全新的布局方式来解决此问题 —— 百分比布局。在这种布局中，我们可以不再使用 wrap_content、match_parent 等方式来指定控件的大小，而是允许直接指定控件在布局中所占的比例，这样就可以轻松实现平分布局甚至是任意比例分割布局的效果了

由于 LinearLayout 本身已经支持按比例指定控件的大小了，因此百分比布局只为 FrameLayout 和 RelativeLayout 进行了功能扩展功能，提供了 PercentFrameLayout 和 PercentRelativeLayout 这两个全新的布局

不同于其前3种布局，百分不布局属于新增布局，为了让新增布局在所有 Android 版本上都能使用，Android 团队将百分比布局定义在了 support 库当中，我们只需要在项目的 build.gradle 中添加百分比布局库的依赖，就能保证百分比布局在 Android 所有系统版本上的兼容性

打开 app/build.gradle，在 dependencies 闭包中添加

```java
dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', {
        exclude group: 'com.android.support', module: 'support-annotations'
    })
    compile 'com.android.support:appcompat-v7:24.2.1'
    compile 'com.android.support:percent:24.2.1'
    testCompile 'junit:junit:4.12'
}
```

需要注意的是，每当修改了任何 gradle 文件时，Android Studio 都会弹出一个一下提示：

Gradle files have changed since last project sync.A project sync may be necessary for the IDE for work porperly.             <u>Syne Now</u>

这个提示告诉我么你，gradle 文件上自上次同步之后又发生了变化，需要再次同步才能使项目正常工作，这里只需要点击 Sync Now 就可以了，然后 gradle 就会开始进行同步，把我们新添加的百分比布局库引入到项目当中

修改 activity_main.xml 中的代码

```java
//最外层使用了 PercentFrameLayout，由于百分比布局并不是内置在系统 SDK 当中的，所以需要把完整的包路径写出来，然后还必须定义一个 app 的命名空间，这样才能使用百分比布局的自定义属性
<android.support.percent.PercentFrameLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

//所用 app 前缀的属性就是因为刚才定义了 app 的命名空间，我们一直使用的 android 前缀的属性也是同样的道理
    <Button
        android:id="@+id/button1"
        android:text="Button 1"
        android:layout_gravity="left|top"
        //将各按钮的宽度指定为布局的50%
        app:layout_widthPercent="50%"
        //将各按钮的高度指定为布局的50%
        app:layout_heightPercent="50%"
        />
    <Button
        android:id="@+id/button2"
        android:text="Button 2"
        android:layout_gravity="right|top"
        app:layout_widthPercent="50%"
        app:layout_heightPercent="50%"
        />
    <Button
        android:id="@+id/button3"
        android:text="Button 3"
        android:layout_gravity="left|bottom"
        app:layout_widthPercent="50%"
        app:layout_heightPercent="50%"
        />
    <Button
        android:id="@+id/button4"
        android:text="Button 4"
        android:layout_gravity="right|bottom"
        app:layout_widthPercent="50%"
        app:layout_heightPercent="50%"
        />
</android.support.percent.PercentFrameLayout>
```

PercentFrameLayout 还是会继承 FrameLayout 的特性，即所有的控件默认都是摆放在布局的左上角，为了让这4个按钮不会重叠，这里还是借助了 layout_gravity 来分别将这4个按钮放置在布局的左上、右上、左下、右下4个位置

现在可以运行程序，但是老版本的 Android Studio 可能会在 activity_main.xml 中看到一些错误提示：

'layout_height' attribute should be defined <u>more...</u>（Ctrl+F1）

'layout_width' attribute should be defined <u>more...</u>（Ctrl+F1）

这是因为老版本的 Android Studio 中内置了布局的检查机制，认为每一个控件都应该通过 android:layout_width 和 android:layout_height 属性指定宽高才是合法的，而其实我们是通过 app:layout_widthPercent 和 app:layout_heightPercent 属性来指定宽高的，所以 Android Studio 没有检测到，不过这个错误提示并不影响程序的运行，直接忽略即可，最新的 Android Studio 已经修复了这个问题，因此可能看不到上述的错误提示了





## 创建自定义控件

![](E:\Android笔记\第三章笔记图片\微信图片_20181015213153.jpg)

可以看到，我们所用的所有控件都是直接或间接继承自 View 的，所用的所有布局都是直接或间接继承自 ViewGroup 的，View 是 Android 中最基本的一种 UI 控件，它可以在屏幕上绘制一块矩形区域，并能响应这块区域的各种事件，因此，我们使用的各种控件其实就是在 View 的基础之上有添加了各自特有的功能，而 ViewGroup 则是一种特殊的 View，它可以包含很多子 ViewGroup，是一个用于放置控件和布局的容器

当系统自带的控件并不能满足我们的需求时，我们可以利用上面的继承结构来创建自定义控件，下面是两种创建自定义控件的简单方法，先创建一个 UICustomViews 项目





### 引入布局

新建一个布局 title.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    //用于为布局或控件制定一个背景，可以使用颜色或图片来进行填充
    android:background="@drawable/title_bg">

    <Button
        android:id="@+id/title_back"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        //指定控件在上下左右方向上偏移的距离
        android:layout_margin="5dp"
        android:background="@drawable/back_bg"
        android:text="Back"
        android:textColor="#fff"
        />
    <TextView
        android:id="@+id/title_text"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:layout_weight="1"
        android:gravity="center"
        android:text="Title Text"
        android:textColor="#fff"
        android:textSize="24sp"
        />
    <Button
        android:id="@+id/title_edit"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:layout_margin="5dp"
        android:background="@drawable/edit_bg"
        android:text="Edit"
        android:textColor="#fff"
        />
</LinearLayout>
```

修改 activity_main.xml 中的代码

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

	//只需要通过一行 include  语句将标题栏布局引入进来就可以了
    <include layout="@layout/title" />
        
</LinearLayout>
```

最后别忘了在 MainActivity 中将系统自带的标题隐藏掉

```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        //调用 getSupportActionBar() 方法来获得 ActionBar 的实例，然后再调用 ActionBar 的 hide() 方法将标题隐藏起来
        ActionBar actionbar = getSupportActionBar();
        if(actionbar != null){
            actionbar.hide();
        }
    }
}
```

使用这种方式，不管有多少需要添加标题栏，只需要一行 include 语句就行了





### 创建自定义控件

为了避免每个活动中为这些布局功能都是相同的控件能够响应相同的事件而去单独编写一次事件的注册代码

新建一个 TitleLayout 类

```java
public class  TitleLayout extends LinearLayout {
    //重写了 LinearLayout 中带有两个参数的构造函数，在布局中引入 TitleLayout 控件就会调用这个函数
    public TitleLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
        //在构造函数中对标题栏布局进行动态加载
        //通过 LayoutInflater 的 from() 方法可以构建出一个 LayoutInflater 对象，然后调用 inflate() 方法就可以动态加载一个布局文件，inflate() 方法接受两个参数，第一个参数是要加载的布局文件的 id，这里我们传入 R.layout.title，第二个参数是给加载好的布局再添加一个父布局，这里我们想要指定为 TitleLayout，于是直接传入 this
        LayoutInflater.from(context).inflate(R.layout.title, this);
    }
}
```

现在已经创建好自定义控件，然后需要在布局文件中添加这个自定义控件，修改 activity_main.xml 中的代码

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

//添加自定义控件和添加普通控件的方式基本是一样的，只不过在添加自定义控件的时候，需要指明控件的完整类名，包名在这里是不可以省略
    <com.example.uilayouttest.TitleLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"/>
</LinearLayout>
```

为标题栏中的按钮注册点击事件，修改 TitleLayout 中的代码

```java
public class  TitleLayout extends LinearLayout {
    public TitleLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
        LayoutInflater.from(context).inflate(R.layout.title, this);
        //通过 findViewById() 方法得到按钮的实例
        Button titleBack = (Button) findViewById(R.id.title_back);
        Button titleEdit = (Button) findViewById(R.id.title_edit);
        //调用 setOnClickListener() 方法给两个按钮注册了点击事件，当点击返回按钮时销毁掉当前的活动，当点击编辑按钮时弹出一段文本
        titleBack.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                ((Activity)getContext()).finish();
            }
        });
        titleEdit.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                Toast.makeText(getContext(), "You clicked Edit button",
                        Toast.LENGTH_SHORT).show();
            }
        });
    }
}
```





### ListView

ListView 允许用户通过手指上下滑动的方式将屏幕外的数据滚动到屏幕内，同时屏幕上原有的数据则会滚动出屏幕





### ListView 的简单用法

新建一个 ListViewTest 项目，然后修改 activity_main.xml 中的代码

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <ListView
    	//为 ListView 指定一个 id
        android:id="@+id/list_view"
        //指定宽度都为 match_parent 这样 ListView 就占满了整个布局的空间
        android:layout_width="match_parent"
        android:layout_height="match_parent" />
</LinearLayout>
```

修改 MainActivity 中的代码

```java
public class MainActivity extends AppCompatActivity {

    private String[] data = {"Apple", "Banana", "Orange", "Watermelon",
        "Pear", "Grape", "Pineapple", "Strawberry", "Cherry", "Mango",
        "Apple", "Banana", "Orange", "Watermelon", "Pear", "Grape",
        "Pineapple", "Strawberry", "Cherry", "Mango"};
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        //数组中的数据无法直接传给 ListView，需要借助适配器来完成
        //Android 提供了很多适配器的实现类，ArrayAdapter 可以通过泛型指定要适配的数据类型，然后在构造函数中把要适配的数据传入，ArrayAdapter 有多个构造函数的重载，应根据实际情况选择合适的一种
        //这里将 ArrayAdapter 的泛型指定为 String，然后在 ArrayAdapter 的构造函数中依次传入当前上下文、ListView 子项布局的 id 以及要适配的数据
        //注意，这里使用了 android.R.layout.simple_list_item_1 作为 ListView 子项布局的 id，这是一个 Android 内置的布局文件，里面只有一个 TextView，可用于简单地显示一段文本
        ArrayAdapter<String> adapter = new ArrayAdapter<String>(
                MainActivity.this, android.R.layout.simple_list_item_1, data);
        ListView listView = (ListView) findViewById(R.id.list_view);
        //将构建好的适配器对象传递进去，这样 ListView 和数据之间的关联就建立了
        listView.setAdapter(adapter);
    }
}
```





### 定制 ListView 界面

显示一段文本的 ListView 内容太过单调，现在对 ListView 的界面进行定制，让它可以显示更加丰富的内容

新建类 Fruit

```java
public class Fruit {
    //name 表示水果的名字
    private String name;
    //iamgeId 表示水果对应图片的资源 id
    private int imageId;
    public Fruit(String name, int imageId){
        this.name = name;
        this.imageId = imageId;
    }
    public String getName(){
        return name;
    }
    public int getImageId(){
        return imageId;
    }
}
```

对 ListView 子项指定一个我们自定义的布局，在 layout 目录下新建 fruit_item.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content">

    //定义一个 ImageView 用于显示水果的图片
    <ImageView
        android:id="@+id/fruit_image"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" />
    
    //定义一个 TextView 用于显示水果的名字
    <TextView
        android:id="@+id/fruit_name"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        //让 TextView 垂直方向上居中显示
        android:layout_gravity="center_vertical"
        android:layout_marginLeft="10dp" />
</LinearLayout>
```

创建一个自定义的适配器，这个适配器继承自 ArrayAdapter，并将泛型指定为 Fruit 类，新建类 FruitAdapter

```java
//FruitAdapter 重写了父类的一组构造函数，用于将上下文、ListView 子项布局的 id 和数据都传递进来
public class FruitAdapter extends ArrayAdapter<Fruit>{
    private int resourceId;
    public FruitAdapter(Context context, int textViewResourceId, List<Fruit> objects){
        super(context, textViewResourceId, objects);
        resourceId = textViewResourceId;
    }
    //重写了 getView() 方法，这个方法在每个子项被滚动到屏幕内的时候会被调用
    @Override
    public View getView(int position, View convertView, ViewGroup parent){
        Fruit fruit = getItem(position);//获取当前项的 Fruit 实例
        //通过 getItem() 方法得到当前项的 Fruit 实例，然后使用 LayoutInflater 来作为这个子项加载我们传入的布局
        //LayoutInflater 的 inflate() 方法接收3个参数，第三个参数指定成 false，表示只让我们在父布局中声明的 layout 属性生效，但不会为这个 View 添加父布局，因为一旦 View 有了父布局之后，它就不能再添加到 ListView 中了
        View view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false);
        //调用 View 的 findViewById() 方法分别获取到 ImageView 和 TextView 的实例，并分别调用它们的 setImageResource() 和 setText() 方法来设置显示的图片和文字，最后将布局返回，这样自定义的适配器就完成了
        ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image);
        TextView fruitName = (TextView) view.findViewById(R.id.fruit_name);
        fruitImage.setImageResource(fruit.getImageId());
        fruitName.setText(fruit.getName());
        return view;
    }
}
```

修改 MainActivity 中的代码

```java
public class MainActivity extends AppCompatActivity {

    private List<Fruit> fruitList = new ArrayList<>();
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initFruits();
        //在 onCreate() 方法中创建了 FruitAdapter 对象，并将 FruitAdapter 作为适配器传递给 ListView
        FruitAdapter adapter = new FruitAdapter(MainActivity.this, R.layout.fruit_item, fruitList);
        ListView listView = (ListView) findViewById(R.id.list_view);
        listView.setAdapter(adapter);
    }
    //添加了一个 initFruit() 方法，用于初始化所有的水果数据
    private void initFruits(){
        //在 Fruit 类中的构造函数中将水果的名字和对应的图片 id 传入，然后把创建好的对象添加到水果列表中，另外我们使用了一个 for 循环将所有的水果都添加了两遍，这是因为如果只添加一边的话，数据量还不足以充满整个屏幕
        for(int i = 0; i < 2; i++){
            Fruit apple = new Fruit("Apple", R.drawable.apple_pic);
            fruitList.add(apple);
            Fruit banana = new Fruit("Banana", R.drawable.banana_pic);
            fruitList.add(banana);
            Fruit orange = new Fruit("Orange", R.drawable.orange_pic);
            fruitList.add(orange);
            Fruit watermelon = new Fruit("Watermelon", R.drawable.watermelon_pic);
            fruitList.add(watermelon);
            Fruit pear = new Fruit("Pear", R.drawable.pear_pic);
            fruitList.add(pear);
            Fruit grape = new Fruit("Grape", R.drawable.grape_pic);
            fruitList.add(grape);
            Fruit pineapple = new Fruit("Pineapple", R.drawable.pineapple_pic);
            fruitList.add(pineapple);
            Fruit strawberry = new Fruit("Strawberry", R.drawable.strawberry_pic);
            fruitList.add(strawberry);
            Fruit cherry = new Fruit("Cherry", R.drawable.cherry_pic);
            fruitList.add(cherry);
            Fruit mango = new Fruit("Mango", R.drawable.mango_pic);
            fruitList.add(mango);
        }
    }
}
```

定制 ListView 界面的任务就完成了，只要修改 fruit_item.xml 中的内容，就可以定制出各种复杂的界面





### 提升 ListView 的运行效率

在 FruitAdapter 的 getView() 方法中，每次都将布局重新加载了一遍，当 ListView 快速滚动的时候，这就会成为性能的瓶颈

getView() 方法中还有一个 convertView 参数，这个参数用于将之前加载好的布局进行缓存，以便之后可以进行重用

修改 FruitAdapter 中的代码

```java
public class FruitAdapter extends ArrayAdapter<Fruit>{
    private int resourceId;
    public FruitAdapter(Context context, int textViewResourceId, List<Fruit> objects){
        super(context, textViewResourceId, objects);
        resourceId = textViewResourceId;
    }
    @Override
    public View getView(int position, View convertView, ViewGroup parent){
        Fruit fruit = getItem(position);//获取当前项的 Fruit 实例
        //在 getView() 方法中进行了判断，如果 convertView 为 null，则使用 LayoutInflater 去加载布局，如果不为 null 则直接对 convertView 进行重用
        View view;
        if(convertView == null) {
            view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false);
        }else{
            view = convertView;
        }
        ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image);
        TextView fruitName = (TextView) view.findViewById(R.id.fruit_name);
        fruitImage.setImageResource(fruit.getImageId());
        fruitName.setText(fruit.getName());
        return view;
    }
}
```

现在已经不会再重复加载布局，但是每次在 getView() 方法还是会调用 View 的 findViewById() 方法来获取一次控件的实例，我们可以借助一个 ViewHolder 来对这部分性能进行优化

修改 FruitAdapter 中的代码

```java
public class FruitAdapter extends ArrayAdapter<Fruit>{
    private int resourceId;
    public FruitAdapter(Context context, int textViewResourceId, List<Fruit> objects){
        super(context, textViewResourceId, objects);
        resourceId = textViewResourceId;
    }
    @Override
    public View getView(int position, View convertView, ViewGroup parent){
        Fruit fruit = getItem(position);//获取当前项的 Fruit 实例
        View view;
        //新增一个内部类 ViewHolder，用于对控件的实例进行缓存
        ViewHolder viewHolder;
        //当 convertView 为 null 时，创建一个 ViewHolder 对象，并将控件的实例都存放在 ViewHolder 里，然后调用 View 的 setTag() 的方法，将 ViewHolder 对象存储在 View 中
        if(convertView == null) {
            view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false);
            viewHolder = new ViewHolder();
            viewHolder.fruitImage = (ImageView) view.findViewById(R.id.fruit_image);
            viewHolder.fruitName = (TextView) view.findViewById(R.id.fruit_name);
            view.setTag(viewHolder);//将 ViewHolder 存储在 View 中
        }else{
            //当 convertView 不为 null 时，调用 View 的 getTag() 方法，把 ViewHolder 重新取出
            view = convertView;
            viewHolder = (ViewHolder) view.getTag();//重新获取 ViewHolder
        }
        viewHolder.fruitImage.setImageResource(fruit.getImageId());
        viewHolder.fruitName.setText(fruit.getName());
        return view;
    }
    class ViewHolder{
        ImageView fruitImage;
        TextView fruitName;
    }
}
```

这样所有控件的实例都缓存在了 ViewHolder 里，就没有必要每次都通过 findViewById() 方法来获取控件的实例了





### ListView  的点击事件

修改 MAinActivity 中的代码

```java
public class MainActivity extends AppCompatActivity {

    private List<Fruit> fruitList = new ArrayList<>();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initFruits();
        FruitAdapter adapter = new FruitAdapter(MainActivity.this, R.layout.fruit_item, fruitList);
        ListView listView = (ListView) findViewById(R.id.list_view);
        listView.setAdapter(adapter);
        //使用 setOnItemClickListener() 方法为 ListView 注册了一个监听器，当用户点击了 LisView 中的任何一个子项时，就会回调 onItemClick() 方法，该方法中可以通过 position 参数判断出用户点击的是哪一子项，然后获取到相应的水果，并通过 Toast 将水果的名字显示出来
        listView.setOnItemClickListener(new AdapterView.OnItemClickListener(){
            @Override
            public void onItemClick(AdapterView<?> parent, View view,int position,long id){
                Fruit fruit = fruitList.get(position);
                Toast.makeText(MainActivity.this, fruit.getName(), Toast.LENGTH_SHORT).show();
            }
        });
    }
    
    ......
    
}
```





### 更强大的滚动控件——RecyclerView

ListView 如果不使用一些技巧来提升它的运行效率，那么 ListView 的性能就会非常差，还有 ListView 的拓展性能也不够好，它只能实现数据纵向的滚动效果，如果我们想要实现横向滚动的话，ListView 是做不到的

新建一个 RecyclerViewTest 项目





### RecyclerView 的基本用法

和百分比布局类似，RecyclerVeiw 也属于新增的控件，为了让 RecyclerView 在所有 Android 版本上都能使用，Android 采取相同的方式，将 RecyclerView 定义在 support 库当中，因此想用 RecyclerView 这个控件，首先需要在项目的 build.gradle 中添加相应的依赖库才行

打开 app/build.gradle 文件

```java
dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', {
        exclude group: 'com.android.support', module: 'support-annotations'
    })
    compile 'com.android.support:appcompat-v7:24.2.1'
    compile 'com.android.support:recyclerview-v7:24.2.1'
    testCompile 'junit:junit:4.12'
}
```

添加完后记得点击一下 Sync Now 来进行同步，修改 activity_main.xml 中的代码

```java
//在布局中加入 RecyclerView 控件
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

	//由于 RecyclerView 并不是内置在系统 SDK 当中的，所以需要把完整的包路径写出来
    <android.support.v7.widget.RecyclerView
    	//先为 RecyclerView 指定一个 id
        android:id="@+id/rercycler_view"
        //将宽度高度都设置为 match_parent，这样让 RecyclerView 占满了整个布局空间
        android:layout_width="match_parent"
        android:layout_height="match_parent" />
</LinearLayout>
```

把 ListViewTest 项目中的图片还有 Fruit 类和 fruit_item.xml 复制过来，接下来为 RecyclerView 准备一个适配器，新建 FruitAdapter 类

```java
//新建 FruitAdapter 类，让这个适配器继承自 RecyclerView.Adapter，并将泛型指定为 FruitAdapter.ViewHolder
public class FruitAdapter extends RecyclerView.Adapter<FruitAdapter.ViewHolder> {

    private List<Fruit> mFruitList;
	
    //定义一个内部类，继承自 RecyclerView
    static class ViewHolder extends RecyclerView.ViewHolder{
        ImageView fruitImage;
        TextView fruitName;
		//构造函数中传入一个 View 参数，这个参数通常是 RecyclerView 子项的最外层布局，那么就可以通过 findViewById() 方法来获取到布局中的 ImageView 和 TextView 的实例了
        public ViewHolder(View view){
            super(view);
            fruitImage = (ImageView) view.findViewById(R.id.fruit_image);
            fruitName = (TextView) view.findViewById(R.id.fruit_name);
        }
    }
    
    //把要展示的数据源传进来，并赋值给一个全局变量 mFruitList
    public FruitAdapter(List<Fruit> fruitList){
        mFruitList = fruitList;
    }

    //由于 FruitAdapter 是继承自 RecyclerView.Adapter 的，那么就必须重写 onCreateViewHolder()、onBindViewHolder() 和 getItemCount() 这3个方法
    
    //该方法适用于创建 ViewHolder 实例的，我们在这个方法中将 fruit_item 布局加载进来，然后创建一个 ViewHolder 实例，并把加载出来的布局传入到构造函数当中，最后将 ViewHolder 的实例返回
    @Override
    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fruit_item, parent, false);
        ViewHolder holder = new ViewHolder(view);
        return holder;
    }

    //该方法用于对 RecyclerView 子项的数据进行赋值，会在每个子项被滚动到屏幕内的时候执行，这里通过 position 参数得到当前项的 Fruit 实例，然后再将数据设置到 ViewHolder 的 ImageView 和 TextView 当中即可
    @Override
    public void onBindViewHolder(ViewHolder holder, int position) {
        Fruit fruit = mFruitList.get(position);
        holder.fruitImage.setImageResource(fruit.getImageId());
        holder.fruitName.setText(fruit.getName());
    }

    //该方法用于告诉 RecyclerView 一共有多少子项，直接返回数据的长度
    @Override
    public int getItemCount() {
        return mFruitList.size();
    }
}
```

修改 MAinActivity 中的代码

```java
public class MainActivity extends AppCompatActivity {

    private List<Fruit> fruitList = new ArrayList<>();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initFruits();
        //先获取到 RecyclerView 的实例
        RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view);
        //然后创建一个 LinearLayoutManager 对象，并将它设置到 RecyclerView 当中，LayoutManager 用于指定 RecyclerView 的布局方式，这里使用的 LinearLayoutManager 是线性布局的意思，可以实现和 ListView 类似的效果
        LinearLayoutManager layoutManager = new LinearLayoutManager(this);
        recyclerView.setLayoutManager(layoutManager);
        //接下来创建 FruitAdapter 的实例，并将水果数据传入到 FruitAdapter 的构造函数中
        FruitAdapter adapter = new FruitAdapter(fruitList);
        //最后调用 RecyclerView 的 setAdapter() 方法来完成适配器设置，这样 RecyclerView 和数据之间的关联就建立完成了
        recyclerView.setAdapter(adapter);
    }
    
    //使用一个同样的 initFruit() 方法，用于初始化所有的水果数据
    private void initFruits(){
        for(int i = 0; i < 2; i++){
            Fruit apple = new Fruit("Apple", R.drawable.apple_pic);
            fruitList.add(apple);
            Fruit banana = new Fruit("Banana", R.drawable.banana_pic);
            fruitList.add(banana);
            Fruit orange = new Fruit("Orange", R.drawable.orange_pic);
            fruitList.add(orange);
            Fruit watermelon = new Fruit("Watermelon", R.drawable.watermelon_pic);
            fruitList.add(watermelon);
            Fruit pear = new Fruit("Pear", R.drawable.pear_pic);
            fruitList.add(pear);
            Fruit grape = new Fruit("Grape", R.drawable.grape_pic);
            fruitList.add(grape);
            Fruit pineapple = new Fruit("Pineapple", R.drawable.pineapple_pic);
            fruitList.add(pineapple);
            Fruit strawberry = new Fruit("Strawberry", R.drawable.strawberry_pic);
            fruitList.add(strawberry);
            Fruit cherry = new Fruit("Cherry", R.drawable.cherry_pic);
            fruitList.add(cherry);
            Fruit mango = new Fruit("Mango", R.drawable.mango_pic);
            fruitList.add(mango);
        }
    }
}
```





### 实现横向滚动和瀑布流布局

对 fruit_item 布局进行修改

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    //将 LinearLayout 改成垂直方向排列
    android:orientation="vertical"
    //把宽度设为 100dp，这里将宽度指定为固定值是因为每种水果的文字长度不一致，如果用 wrap_content 的话，ReyclcerView 的子项就会有长有短，不美观；而如果使用 match_parent 的话就导致宽度过长，一个子项占满整个屏幕
    android:layout_width="100dp"
    android:layout_height="wrap_content">


	//将 ImageView 和 TextView 都设置成在布局中水平居中
    <ImageView
        android:id="@+id/fruit_image"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"/>

    <TextView
        android:id="@+id/fruit_name"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"
        //使用 layout_marginTop 属性让文字和图片之间保持一些距离
        android:layout_marginTop="10dp" />
</LinearLayout>
```

修改 MainActivity 中的代码

```java
public class MainActivity extends AppCompatActivity {

    private List<Fruit> fruitList = new ArrayList<>();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initFruits();
        RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view);
        LinearLayoutManager layoutManager = new LinearLayoutManager(this);
        //调用 LinearLayoutManager 的 setOrientation() 方法来设置布局的排列方向，默认是纵向排列的，传入 LinearLayoutManager.HROIZONTAL 表示让布局横行排列，这样 RecyclerView 就可以横向滚动了
        layoutManager.setOrientation(LinearLayoutManager.HORIZONTAL);
        recyclerView.setLayoutManager(layoutManager);
        FruitAdapter adapter = new FruitAdapter(fruitList);
        recyclerView.setAdapter(adapter);
    }
	...
}
```

ListView 的布局排列是由自身去管理的，而 RecyclerView 则将这个工作交给了 LayoutManager，LayoutManager 中定制了一套可扩展的布局排列接口，子类只要按照接口的规范来实现，就能定制出各种不同排列方式的布局了

除了 LinearLayoutManager 之外，RecyclerView 还给我们提供了 GridLayoutManager 和 StaggeredGridLayoutManager 这两种内置的布局排列方式，GridLayoutManager 可以用于实现网格布局，StaggeredGridLayoutManager 可以用于实现瀑布流布局

修改 fruit_item.xml 中的代码

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    //将 LinearLayout 的宽度由 100dp 改成了 match_parent，因为瀑布流布局的宽度应该是根据布局的列数来自动是配的，而不是一个固定值
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    //使用 layout_margin 属性来让自相之间互留一点间距，这样不至于所有子项都紧贴在一起
    android:layout_margin="5dp" >

    <ImageView
        android:id="@+id/fruit_image"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"/>

    <TextView
        android:id="@+id/fruit_name"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        //将 TextView 的对其属性改成了居左对齐，因为待会我们会将文字的长度变长，如果还是居中显示就会怪怪的
        android:layout_gravity="left"
        android:layout_marginTop="10dp" />
</LinearLayout>
```

瀑布流布局需要各个子项的高度不一致才能看出明显的效果，修改 MainActivity 中的代码

```java
public class MainActivity extends AppCompatActivity {

    private List<Fruit> fruitList = new ArrayList<>();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initFruits();
        RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view);
        //在 onCreate() 方法中创建了一个 StaggeredGridLayout 的实例，StaggeredGridLayout 的构造函数接受两个参数，第一个参数用于指定布局的列数，传入3表示会把布局分为3列；第二个参数用于指定布局的排列方向，传入 StaggeredGridLayout.VERTICAL 表示会让布局纵向排列
        StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager(3, StaggeredGridLayoutManager.VERTICAL);
        //最后把创建好的实例设置到 RecyclerView 中就可以了
        recyclerView.setLayoutManager(layoutManager);
        FruitAdapter adapter = new FruitAdapter(fruitList);
        recyclerView.setAdapter(adapter);
    }

    private void initFruits(){
        for(int i = 0; i < 2; i++){
            //子项中每个水果的名字都改成调用 getRandomLengthName() 这个方法来生成，这样就能保证各水果名字的长短差距比较大，子项的高度也就各不相同
            Fruit apple = new Fruit(getRandomLengthName("Apple"), R.drawable.apple_pic);
            fruitList.add(apple);
            Fruit banana = new Fruit(getRandomLengthName("Banana"), R.drawable.banana_pic);
            fruitList.add(banana);
            Fruit orange = new Fruit(getRandomLengthName("Orange"), R.drawable.orange_pic);
            fruitList.add(orange);
            Fruit watermelon = new Fruit(getRandomLengthName("Watermelon"), R.drawable.watermelon_pic);
            fruitList.add(watermelon);
            Fruit pear = new Fruit(getRandomLengthName("Pear"), R.drawable.pear_pic);
            fruitList.add(pear);
            Fruit grape = new Fruit(getRandomLengthName("Grape"), R.drawable.grape_pic);
            fruitList.add(grape);
            Fruit pineapple = new Fruit(getRandomLengthName("Pineapple"), R.drawable.pineapple_pic);
            fruitList.add(pineapple);
            Fruit strawberry = new Fruit(getRandomLengthName("Strawberry"), R.drawable.strawberry_pic);
            fruitList.add(strawberry);
            Fruit cherry = new Fruit(getRandomLengthName("Cherry"), R.drawable.cherry_pic);
            fruitList.add(cherry);
            Fruit mango = new Fruit(getRandomLengthName("Mango"), R.drawable.mango_pic);
            fruitList.add(mango);
        }
    }
    
    //该方法使用了 Random 对象来创造一个1~20之间的随机数，然后将参数中传入的字符串随机重复几遍
    private String getRandomLengthName(String name){
        Random random = new Random();
        int length = random.nextInt(20) + 1;
        StringBuilder builder = new StringBuilder();
        for(int i = 0; i < length; i++){
            builder.append(name);
        }
        return builder.toString();
    }
}
```





### RecyclerView 的点击事件

修改 FruitAdapter 中的代码

```java
public class FruitAdapter extends RecyclerView.Adapter<FruitAdapter.ViewHolder> {

    private List<Fruit> mFruitList;

    static class ViewHolder extends RecyclerView.ViewHolder{
        //在 ViewHolder 中添加了 fruitView 变量来保存子项最外层布局的实例
        View fruitView;
        ImageView fruitImage;
        TextView fruitName;

        public ViewHolder(View view){
            super(view);
            fruitView = view;
            fruitImage = (ImageView) view.findViewById(R.id.fruit_image);
            fruitName = (TextView) view.findViewById(R.id.fruit_name);
        }
    }

    //在 onCreateViewHolder() 方法中注册点击事件，这里分别为最外层布局和 ImageView 都注册了点击事件
    @Override
    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fruit_item, parent, false);
        //在两个点击事件中先获取了用户点击的 position，然后通过 position 拿到相应的 Fruit 实例，再使用Toast 分别弹出两种不同的内容以示区别
        final ViewHolder holder = new ViewHolder(view);
        holder.fruitView.setOnClickListener(new View.OnClickListener(){
            @Override
            public void onClick(View v){
                int position = holder.getAdapterPosition();
                Fruit fruit = mFruitList.get(position);
                Toast.makeText(v.getContext(), "you clicked view" + fruit.getName(), Toast.LENGTH_SHORT).show();
            }
        });
        holder.fruitImage.setOnClickListener(new View.OnClickListener(){
            @Override
            public void onClick(View v){
                int position = holder.getAdapterPosition();
                Fruit fruit = mFruitList.get(position);
                Toast.makeText(v.getContext(), "you clicked image" + fruit.getName(), Toast.LENGTH_SHORT).show();
            }
        });
        return holder;
    }

    ...
        
}
```

由于 TextView 并没有注册点击事件，因此点击文字这个事件会被最外层布局捕获到





### 制作 Nine-Patch 图片

Nine-Patch 图片是一种被特殊处理过的 png 图片，能够制定哪些区域可以被拉伸、哪些区域不可以

修改 activity_main.xml 中的代码

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:background="@drawable/message_left">
</LinearLayout>
```

在 Android sdk 目录下有一个 tools 文件夹，在这个文件夹中找到 draw9patch.bat 文件，我们就是用它来制作 Nine-Patch 图片

从 Android Studio 2.3 开始，不再提供单独的 draw9patch.bat 文件，这个功能直接被继承到了 Android Studio 当中。在 Android Studio 中对任意一张 png 图片右击 -> Create 9-patch file，即可穿件 Nine-Patch 图片，接下来的制作过程和使用 draw9patch.bat 文件来制作基本一致

上边框和左边框绘制的部分表示当图片需要拉伸时就拉伸黑点标记的区域

下边框和右边框绘制的部分表示内容会被放置的区域

使用鼠标在图片的边缘拖动就可以进行绘制，按住 shift 键拖动可进行擦除





### 编写精美的聊天界面

在 app/build.gradle 当中添加依赖库

```java
dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    androidTestImplementation('com.android.support.test.espresso:espresso-core:2.2.2', {
        exclude group: 'com.android.support', module: 'support-annotations'
    })
    implementation 'com.android.support:appcompat-v7:24.2.1'
    implementation 'com.android.support:recyclerview-v7:24.2.1'
    testImplementation 'junit:junit:4.12'
}
```

修改 activity_main.xml 中的代码

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="#d8e0e8">

	//在主页面中放置了一个 RecyclerView 用于显示聊天的消息内容
    <android.support.v7.widget.RecyclerView
        android:id="@+id/msg_recycler_view"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"/>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

		//放置了一个 EditText 用于输入消息
        <EditText
            android:id="@+id/input_text"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:hint="Tyoe something here"
            android:maxLines="2"/>

		//放置了一个 Button 用于发送消息
        <Button
            android:id="@+id/send"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Send"/>

    </LinearLayout>

</LinearLayout>
```

定义消息的实体类，新建 Msg

```java
public class Msg {
    //表示这是一条收到的消息
    public static final int TYPE_RECEIVED = 0;

    //表示这是一条发出的消息
    public static final int TYPE_SEND = 1;

    // content 表示消息的内容
    private String content;

    // type 表示消息的类型
    private int type;

    public Msg(String content, int type){
        this.content = content;
        this.type = type;
    }

    public String getContent(){
        return content;
    }

    public int getType(){
        return type;
    }
}
```

编写 RecyclerView 子项的布局，新建 msg_item.xml

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:padding="10dp">

	//收到的消息居左对齐
    <LinearLayout
        android:id="@+id/left_msg"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="left"
        android:background="@drawable/message_left">

        <TextView
            android:id="@+id/left_msg"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:layout_margin="10dp"
            android:textColor="#fff"/>

    </LinearLayout>

	//发出的消息居右对齐
    <LinearLayout
        android:id="@+id/right_layout"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="right"
        android:background="@drawable/message_right">
        
        <TextView
            android:id="@+id/right_msg"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:layout_margin="10dp"/>

    </LinearLayout>

</LinearLayout>
```

创建 RecyclerView 的适配器类，新建类 MsgAdapter

```java
public class MsgAdapter extends RecyclerView.Adapter<MsgAdapter.ViewHolder> {

    private List<Msg> mMsgList;

    static class ViewHolder extends RecyclerView.ViewHolder{

        LinearLayout leftLayout;

        LinearLayout rightLayout;

        TextView leftMsg;

        TextView rightMsg;

        public ViewHolder(View view){
            super(view);
            leftLayout = (LinearLayout) view.findViewById(R.id.left_layout);
            rightLayout = (LinearLayout) view.findViewById(R.id.right_layout);
            leftMsg = (TextView) view.findViewById(R.id.left_msg);
            rightMsg = (TextView) view.findViewById(R.id.right_msg);
        }
    }

    public MsgAdapter(List<Msg> msgList){
        mMsgList = msgList;
    }

    @Override
    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType){
        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.msg_item, parent,false);
        return new ViewHolder(view);
    }

    @Override
    public void onBindViewHolder(ViewHolder holder, int position){
        Msg msg = mMsgList.get(position);
        if(msg.getType() == Msg.TYPE_RECEIVED){
            //如果是收到的消息，则先是左边的消息布局，将右边的消息布局隐藏
            holder.leftLayout.setVisibility(View.VISIBLE);
            holder.rightLayout.setVisibility(View.GONE);
            holder.leftMsg.setText(msg.getContent());
        }else if(msg.getType() == Msg.TYPE_SEND){
            //如果是发出的消息，则显示右边的消息布局，将左边的消息布局隐藏
            holder.rightLayout.setVisibility(View.VISIBLE);
            holder.leftLayout.setVisibility(View.GONE);
            holder.rightMsg.setText(msg.getContent());
        }
    }

    @Override
    public int getItemCount(){
        return mMsgList.size();
    }
}
```

修改 MainActivity 中的代码

```java
public class MainActivity extends AppCompatActivity {

    private List<Msg> msgList = new ArrayList<>();

    private EditText inputText;

    private Button send;

    private RecyclerView msgRecyclerView;

    private MsgAdapter adapter;

    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initMsgs();//初始化消息数据
        inputText = (EditText) findViewById(R.id.input_text);
        send = (Button) findViewById(R.id.send);
        msgRecyclerView = (RecyclerView) findViewById(R.id.msg_recycler_view);
        LinearLayoutManager layoutManager = new LinearLayoutManager(this);
        msgRecyclerView.setLayoutManager(layoutManager);
        adapter = new MsgAdapter(msgList);
        msgRecyclerView.setAdapter(adapter);
        //在发送按钮的单机时间里获取了 EditText 中的内容，如果内容不为空字符串则创建出一个新的 Msg 对象，并把它添加到 msgList 列表中去
        send.setOnClickListener(new View.OnClickListener(){
            
            @Override
            public void onClick(View v){
                String content = inputText.getText().toString();
                if(!"".equals(content)){
                    Msg msg = new Msg(content, Msg.TYPE_SEND);
                    msgList.add(msg);
                    
                    //调用了适配器的 notifyItemInserted() 方法，用于通知列表有新的数据插入，这样新增的一条消息才能够在 RecyclerView 中显示
                    adapter.notifyItemInserted(msgList.size() - 1);//当有新消息时，刷新 RecyclerView 中的而显示
                    
                    //调用 scrollToPosion() 方法将显示的数据定位到最后一行，以保证一定可以看到最后发出的一条消息
                    msgRecyclerView.scrollToPosition(msgList.size() - 1);//将 RecyclerView 定位到最后一行
                    
                    inputText.setText("");//清空输入框中的内容
                }
            }
        });
    }
    // initMsgs() 方法中先初始化几条数据用于在 RecyclerView 中显示
    private void initMsgs(){
        Msg msg1 = new Msg("Hello guy.", Msg.TYPE_RECEIVED);
        msgList.add(msg1);
        Msg msg2 = new Msg("Hello. Who is that?", Msg.TYPE_SEND);
        msgList.add(msg2);
        Msg msg3 = new Msg("This is Tom. Nice talking to you.", Msg.TYPE_RECEIVED);
        msgList.add(msg3);
    }

}
```

