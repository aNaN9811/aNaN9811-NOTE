# 第十四章：进入实战——开发库欧天气



## 功能需求及技术可行性分析

- 可以罗列出全国所有的省、市、县
- 可以查看全国任意城市的天气信息
- 可以自由地切换城市，去查看其他城市的天气
- 提供手动更新以及后台自动更新天气的功能

获取每个城市的天气信息，我们使用和风天气来获取

获取全国省市县数据的问题，只需要访问：http://guolin.tech/api/china

服务器会返回一段 JSON 格式的数据，其中包含了中国所有省份名称以及省份 id

如想访问某个省内有哪些城市，只需要将省份的 id 添加到 url 地址的最后面就可以了：http://guolin.tech/api/china/6

以此类推，访问具体县和区的时候，只需在 url 后面继续再加上城市 id：http://guolin.tech/api/china/6/116

每个县或区都会有一个 weather_id，拿着这个 id 再去访问和风天气的接口，就可以获取到该地区具体的天气信息了



下面来看一下和风天气的接口是如何使用，首先注册一个自己的账号，注册地址：http://guolin.tech/api/weather/register，注册好之后使用这个账号登录，就能看到自己的 API Key

有了 API Key 再配合刚才的 weather_id 我们就能够后去任意城市的天气信息了

比如苏州的 weather_id 是 CN101190401，那么访问如下接口即可查看苏州的天气信息：

http://guolin.tech/api/weather?cityid=CN101190401&key=a10afa0f2b3e4f46b0049265441c4dd9

其中，cityid 部分填入的就是待查看城市的 weather_id，key 部分填入的就是我们申请到的 API Key，这样，服务器就会把苏州详细的天气信息以 JSON 格式返回给我们，接下来就是解析 JSON 的工作了



## Git 时间——将代码托管到 GitHub 上



## 创建数据库和表

创建 db 包用于存放数据库模型相关的代码，gson 包用于存放 GSON 模型相关的代码，service 包用于存放服务相关的代码，util 包用于存放工具相关的代码

第一阶段我们要做的是创建好数据库和表，这样从服务器获取到的数据才能够存储到本地，这里使用 LitePal 来管理库欧天气的数据库，首先添加依赖：

```java
dependencies {
    ...
    // LitePal 用于对数据库进行操作
    implementation 'org.litepal.android:core:1.4.1'
    // OkHttp 用于进行网络请求
    implementation 'com.squareup.okhttp3:okhttp:3.4.1'
    // GSON 用于解析 JSON 数据
    implementation 'com.google.code.gson:gson:2.7'
    // Glide 用于加载和展示图片
    implementation 'com.github.bumptech.glide:glide:3.7.0'
}
```

建立 3 张表：province、city、county，分别用于存放省、市、县的数据信息，对应 Province 、City 、County，在 db 包下新建一个 Province 类

```java
// LitePal 中的每一个实体类都是必须要继承自 DataSupport
public class Province extends DataSupport {
    
    private int id;
    
    //记录省的名字
    private String provinceName;
    
    //记录省的代号
    private int provinceCode;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getProvinceName() {
        return provinceName;
    }

    public void setProvinceName(String provinceName) {
        this.provinceName = provinceName;
    }

    public int getProvinceCode() {
        return provinceCode;
    }

    public void setProvinceCode(int provinceCode) {
        this.provinceCode = provinceCode;
    }
    
}
```

接着在 db 包下新建一个 City 类

```java
public class City extends DataSupport {
    
    private int id;
    
    //记录市的名字
    private String cityName;
    
    //记录市的代号
    private int cityCode;
    
    //记录当前市所属省的 id 值
    private int provinceId;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getCityName() {
        return cityName;
    }

    public void setCityName(String cityName) {
        this.cityName = cityName;
    }

    public int getCityCode() {
        return cityCode;
    }

    public void setCityCode(int cityCode) {
        this.cityCode = cityCode;
    }

    public int getProvinceId() {
        return provinceId;
    }

    public void setProvinceId(int provinceId) {
        this.provinceId = provinceId;
    }
    
}
```

在 db 包下继续新建一个 County 类

```java
public class County extends DataSupport {
    
    private int id;
    
    //记录县的名字
    private String countyName;
    
    //记录县所对应的天气 id
    private String weatherId;
    
    //记录当前县所属市的 id 值
    private int cityId;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getCountyName() {
        return countyName;
    }

    public void setCountyName(String countyName) {
        this.countyName = countyName;
    }

    public String getWeatherId() {
        return weatherId;
    }

    public void setWeatherId(String weatherId) {
        this.weatherId = weatherId;
    }

    public int getCityId() {
        return cityId;
    }

    public void setCityId(int cityId) {
        this.cityId = cityId;
    }
    
}
```

接下来需要配置 litepal.xml 文件，右击 app/src/main 目录 -> New -> Directory，创建一个 assets 目录，然后在 assets 目录下再新建一个 litepal.xml 

```java
<litepal>

	//将数据库名指定成 cool_weather
    <dbname value="cool_weather" />

    //数据版本指定成 1
    <version value="1" />

    //将 Province、City 和 County 这三个实体类添加到映射列表中
    <list>
        <mapping class="com.coolweather.android.db.Province" />
        <mapping class="com.coolweather.android.db.City" />
        <mapping class="com.coolweather.android.db.County" />
    </list>

</litepal>
```

最后配置一下 LitePalApplication，修改 AndroidManifest.xml

```java
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.coolweather.android">

    <application
        android:name="org.litepal.LitePalApplication"
        ...
    </application>

</manifest>
```

这样我们就将所有的配置都完成了，数据库和表会在首次执行任意数据库操作的时候自动创建

最后将现在所有新增的文件添加到 GitHub



## 遍历全国省市县数据

第二阶段，我们准备把遍历全国省市县的功能加入

由于全国所有省市县的数据都是从服务器端获取到的，因此这里和服务器的交互是必不可少的，所以我们在 util 包下新建一个 HttpUtil 类

```java
public class HttpUtil {

    //发起一条 HTTP 请求只需要调用 sendOkHttpRequest() 方法，传入请求地址，并注册一个回调来处理服务器响应就可以了
    public static void sendOkHttpRequest(String address, okhttp3.Callback callback) {
        OkHttpClient client = new OkHttpClient();
        Request request = new Request.Builder().url(address).build();
        client.newCall(request).enqueue(callback);
    }

}
```

由于服务器返回的省市县数据都是 JSON 格式的，所以我们最好再提供一个工具类来解析和处理这种数据，在 util 包下新建一个 Utility 类

```java
public class Utility {

    /**
     * 解析和处理服务器返回的省级数据
     */
    public static boolean handleProvinceResponse(String response) {
        if (!TextUtils.isEmpty(response)) {
            try {
                JSONArray allProvinces = new JSONArray(response);
                for (int i = 0; i < allProvinces.length(); i++) {
                    JSONObject provinceObject = allProvinces.getJSONObject(i);
                    Province province = new Province();
                    province.setProvinceName(provinceObject.getString("name"));
                    province.setProvinceCode(provinceObject.getInt("id"));
                    province.save();
                }
                return true;
            } catch (JSONException e) {
                e.printStackTrace();
            }
        }
        return false;
    }

    /**
     * 解析和处理服务器返回的市级数据
     */
    public static boolean handleCityResponse(String response, int provinceId) {
        if (!TextUtils.isEmpty(response)) {
            try {
                JSONArray allCities = new JSONArray(response);
                for (int i = 0; i < allCities.length(); i++) {
                    JSONObject cityObject = allCities.getJSONObject(i);
                    City city = new City();
                    city.setCityName(cityObject.getString("name"));
                    city.setCityCode(cityObject.getInt("id"));
                    city.setProvinceId(provinceId);
                    city.save();
                }
                return true;
            } catch (JSONException e) {
                e.printStackTrace();
            }
        }
        return false;
    }

    /**
     * 返回和处理服务器返回的县级数据
     */
    public static boolean handleCountyResponse(String response, int cityId) {
        if (!TextUtils.isEmpty(response)) {
            try {
                JSONArray allCounties = new JSONArray(response);
                for (int i = 0; i < allCounties.length(); i++) {
                    JSONObject countyObject = allCounties.getJSONObject(i);
                    County county = new County();
                    county.setCountyName(countyObject.getString("name"));
                    county.setWeatherId(countyObject.getString("weather_id"));
                    county.setCityId(cityId);
                    county.save();
                }
                return true;
            } catch (JSONException e) {
                e.printStackTrace();
            }
        }
        return false;
    }
    
}
```

使用了 handleProvinceResponse() 、handleCityResponse() 和 handleCountyResponse() 三个方法分别用于解析和处理服务器返回的省级、市级和县级数据，处理方式都是类似的，先使用 JSONArray 和 JSONObject 将数据解析出来，然后组装成实体类对象，再调用 save() 方法将数据存储到数据库当中

由于遍历全国省市县的功能我们在后面还会复用，因此就不写在活动里面，而是写在碎片里面，这样需要服用的时候直接在布局里面引用碎片就可以了。在 res/layout 中新建 choose_area.xml 

```java
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="#fff">

	//将头布局作为标题栏，将布局高度设为 actionBar 高度，背景色设置为 colorPrimary
    <RelativeLayout
        android:layout_width="match_parent"
        android:layout_height="?attr/actionBarSize"
        android:background="?attr/colorPrimary">

	    //头布局中放置一个 TextView 来显示标题内容
        <TextView
            android:id="@+id/title_text"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_centerInParent="true"
            android:textColor="#fff"
            android:textSize="20sp" />

        //头布局总放置一个 Button 来执行返回操作
        <Button
            android:id="@+id/back_button"
            android:layout_width="25dp"
            android:layout_height="25dp"
            android:layout_marginLeft="10dp"
            android:layout_alignParentLeft="true"
            android:layout_centerVertical="true"
            android:background="@drawable/ic_back"/>

    </RelativeLayout>

	//在头布局的下面定义一个 ListView，省市县的数据就将显示在这里，之所以使用 ListView，是因为它会自动给每个项之间添加一条分割线，而如果使用 RecyclerView 实现相同的功能会比较麻烦
    <ListView
        android:id="@+id/list_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />

</LinearLayout>
```

这里之所有要自己定义标题栏，是因为碎片中最好不要直接使用 ActionBar 和 Toolbar，不然在复用的时候可能会出现一些你不想看到的效果

接下来需要编写用于遍历省市县数据的碎片，新建 ChooseAreaFragment 继承自 Fragment

```java
public class ChooseAreaFragment extends Fragment {

    public static final int LEVEL_PROVINCE = 0;

    public static final int LEVEL_CITY = 1;

    public static final int LEVEL_COUNTY = 2;

    private ProgressDialog progressDialog;

    private TextView titleText;

    private Button backButton;

    private ListView listView;

    private ArrayAdapter<String> adapter;

    private List<String> dataList = new ArrayList<>();

    /**
     * 省列表
     */
    private List<Province> provinceList;

    /**
     * 市列表
     */
    private List<City> cityList;

    /**
     * 县列表
     */
    private List<County> countyList;

    /**
     * 选中的省份
     */
    private Province selectedProvince;

    /**
     * 选中的城市
     */
    private City selectedCity;

    /**
     * 当前选中的级别
     */
    private int currentLevel;

    // onCreateView() 方法中先是获取到了一些控件的实例，然后初始化了 ArrayAdapter，并将它设置为 ListView 的适配器
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.choose_area, container, false);
        titleText = view.findViewById(R.id.title_text);
        backButton = view.findViewById(R.id.back_button);
        listView = view.findViewById(R.id.list_view);
        adapter = new ArrayAdapter<>(getContext(), android.R.layout.simple_list_item_1, dataList);
        listView.setAdapter(adapter);
        return view;
    }

    //接着在 onActivityCreated() 方法中给 ListView 和 Button 设置了点击事件
    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        //当点击了某个省的时候会进入到 ListView 的 onItemClick() 方法中，这个时候会根据当前的级别来判断是去调用 queryCities() 方法还是 queryCounties() 方法，前者方法是去查询市级数据，后者方法是去查询县级数据，这两个方法的流程和 queryProvinces() 方法基本相同
        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
            @Override
            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                if (currentLevel == LEVEL_PROVINCE) {
                    selectedProvince = provinceList.get(position);
                    queryCities();
                } else if (currentLevel == LEVEL_CITY) {
                    selectedCity = cityList.get(position);
                    queryCounties();
                }
            }
        });
        //在返回按钮的点击事件里，会对当前 ListView 的列表进行判断，如果当前是县级列表，那么就返回到市级列表，依此类推，当返回到省级列表，返回按钮会自动隐藏，从而也就不需要再进一步处理
        backButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                if (currentLevel == LEVEL_COUNTY) {
                    queryCities();
                } else if (currentLevel == LEVEL_CITY) {
                    queryProvinces();
                }
            }
        });
        //在最后调用了 queryProvinces() 方法，从这里开始加载省级数据
        queryProvinces();
    }

    /**
     * 查询全国所有的省，优先从数据库查询，如果没有查询到再去服务器上查询
     */
    private void queryProvinces() {
        //将头布局的标题设置成中国，将返回按钮隐藏起来，因为省级刘表已经不能再返回了
        titleText.setText("中国");
        backButton.setVisibility(View.GONE);
        //然后调用 LitePal 的查询接口来从数据库中读取省级数据，如果读取到了就直接将数据显示在界面上，如果没有读取到，就组装出一个请求地址，然后调用 queryFromServer() 方法来从服务器上查询数据
        provinceList = DataSupport.findAll(Province.class);
        if (provinceList.size() > 0) {
            dataList.clear();
            for (Province province : provinceList) {
                dataList.add(province.getProvinceName());
            }
            adapter.notifyDataSetChanged();
            listView.setSelection(0);
            currentLevel = LEVEL_PROVINCE;
        } else {
            String address = "http://guolin.tech/api/china/";
            queryFromServer(address, "province");
        }
    }

    /**
     * 查询选中省内所有的市，优先从数据库查询，如果没有查询到再去服务器上查询
     */
    private void queryCities() {
        titleText.setText(selectedProvince.getProvinceName());
        backButton.setVisibility(View.VISIBLE);
        cityList = DataSupport.where("provinceid = ?", String.valueOf(selectedProvince.getId())).find(City.class);
        if (cityList.size() > 0) {
            dataList.clear();
            for (City city : cityList) {
                dataList.add(city.getCityName());
            }
            adapter.notifyDataSetChanged();
            listView.setSelection(0);
            currentLevel = LEVEL_CITY;
        } else {
            int provinceCode = selectedProvince.getProvinceCode();
            String address = "http://guolin.tech/api/china/" + provinceCode;
            queryFromServer(address, "city");
        }
    }

    /**
     * 查询选中市内所有的县，优先从数据库查询，如果没有查询到再去服务器上查询
     */
    private void queryCounties() {
        titleText.setText(selectedCity.getCityName());
        backButton.setVisibility(View.VISIBLE);
        countyList = DataSupport.where("cityid = ?", String.valueOf(selectedCity.getId())).find(County.class);
        if (countyList.size() > 0) {
            dataList.clear();
            for (County county : countyList) {
                dataList.add(county.getCountyName());
            }
            adapter.notifyDataSetChanged();
            listView.setSelection(0);
            currentLevel = LEVEL_COUNTY;
        } else {
            int provinceCode = selectedProvince.getProvinceCode();
            int cityCode = selectedCity.getCityCode();
            String address = "http://guolin.tech/api/china/" + provinceCode + "/" + cityCode;
            queryFromServer(address, "county");
        }
    }

    /**
     * 根据传入的地址和类型从服务器上查询省市县数据
     */
    private void queryFromServer(String address, final String type) {
        showProgressDialog();
        //调用 HttpUtil 的 sendOkHttpRequest() 方法来向服务器发送请求，响应的数据会回调到 onResponse() 方法中，然后我们在这里去调用 Utility 的 handleProvinceResponse() 方法来解析和处理服务器返回的数据，并存储到数据库中
        HttpUtil.sendOkHttpRequest(address, new Callback() {
            @Override
            public void onResponse(Call call, Response response) throws IOException {
                String responseText = response.body().string();
                boolean result = false;
                if ("province".equals(type)) {
                    result = Utility.handleProvinceResponse(responseText);
                } else if ("city".equals(type)) {
                    result = Utility.handleCityResponse(responseText, selectedProvince.getId());
                } else if ("county".equals(type)) {
                    result = Utility.handleCountyResponse(responseText, selectedCity.getId());
                }
                //在解析和处理完数据之后，再次调用 queryProvinces() 方法来重新加载省级数据，由于 queryProvinces() 方法牵扯到了 UI 操作，因此必须要在主线程中调用，这里借助了 runOnUiThread() 方法来实现从子线程切换到主线程。现在数据库中已经存在了数据，因此调用了 queryProvinces() 就会直接将数据显示到界面上了
                if (result) {
                    getActivity().runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            closeProgressDialog();
                            if ("province".equals(type)) {
                                queryProvinces();
                            } else if ("city".equals(type)) {
                                queryCities();
                            } else if ("county".equals(type)) {
                                queryCounties();
                            }
                        }
                    });
                }
            }

            @Override
            public void onFailure(Call call, IOException e) {
                //通过 runOnUiThread() 方法回到主线程处理逻辑
                getActivity().runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        closeProgressDialog();
                        Toast.makeText(getContext(), "加载失败", Toast.LENGTH_SHORT).show();
                    }
                });
            }
        });
    }

    /**
     * 显示进度对话框
     */
    private void showProgressDialog() {
        if (progressDialog == null) {
            progressDialog = new ProgressDialog(getActivity());
            progressDialog.setMessage("正在加载...");
            progressDialog.setCanceledOnTouchOutside(false);
        }
        progressDialog.show();
    }

    /**
     * 关闭进度对话框
     */
    private void closeProgressDialog() {
        if (progressDialog != null) {
            progressDialog.dismiss();
        }
    }

}
```

这样我们就把遍历省市县的功能完成了，可是碎片是不能直接显示在界面上的，因此我们还需要把它添加到活动里才行，修改 activity_main.xml

```java
//定义一个 FrameLayout
<FrameLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    
    <fragment
        android:id="@+id/choose_area_fragment"
        //将 ChooseAreaFragment 添加进来，并让它充满整个布局
        android:name="com.coolweather.android.ChooseAreaFragment"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />   
    
</FrameLayout>
```

另外我们刚才在碎片里已经自定义了一个标题栏，因此就不再需要原生的 ActionBar，修改 res/values/styles.xml

```java
<resources>

    <!-- Base application theme. -->
    <style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar">
        ...
    </style>

</resources>
```

修改 AndroidManifest.xml 声明程序所需要的权限

```JAVA
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.coolweather.android">

	//由于我们是通过网络接口来获取全国省市县数据的，因此必须要添加访问网络的权限
    <uses-permission android:name="android.permission.INTERNET" />

    ...

</manifest>
```

第二阶段工作也完成了，仍然把代码提交一下



## 显示天气信息

在第三阶段中，我们要开始查询天气，并且把天气信息显示出来。由于和风天气返回的 JSON 数据结构非常复杂，如果还是用 JSONObject 来解析就会很麻烦，这里借助 GSON 来对天气进行解析

### 定义 GSON 实体类

GSON 的用法很简单，解析数据只需要一行代码就能完成了，但前提是要先将数据对应的实体类创建好。由于和风天气返回的数据内容很多，我们不可能将所有的内容都利用起来，因此只筛选出一些比较重要的数据来进行解析

返回数据的大致形式：

```json
{
	"HeWeather" : [
        {
            "status" : "ok",
            "base" : {},
            "aqi" : {},
            "now" : {},
            "suggestion" : {},
            "daily_forecast" : []
        }
	]
}
```

其中，basic、aqi、now、suggestion 和 daily_forecast 的内部又都会有具体的内容，那么我们就可以将这 5 个部分定义成 5 个实体类，下面看看 basic 中的具体内容

```json
"basic" : {
	"city" : "苏州",
	"id" : "CN101190401",
	"update" : {
		"loc" : "2016-08-08 21:58"
	}
}
```

其中，city 表示城市名，id 表示城市对应的天气 id，update 中的 loc 表示天气的更新时间，我们按照此结构就可以在 gson 包下建立一个 Basic 类

```java
public class Basic {

    //由于 JSON 中的一些字段可能不太适合直接作为 Java 字段来命名，因此这里使用了 @SerializedName 注解的方式来让 JSON 字段和 Java 字段之间建立映射关系
    @SerializedName("city")
    public String cityName;

    @SerializedName("id")
    public String weatherId;

    public Update update;

    public class Update {

        @SerializedName("loc")
        public String updateTime;

    }
    
}
```

其余的几个实体类也是类似的

AQI 类

```java
public class AQI {

    public AQICity city;

    public class AQICity {

        public String aqi;

        public String pm25;

    }
    
}
```

Now 类

```java
public class Now {
    
    @SerializedName("tmp")
    public String temperature;
    
    @SerializedName("cond")
    public More more;
    
    public class More {
        
        @SerializedName("txt")
        public String info;
        
    }
    
}
```

Suggestion 类

```java
public class Suggestion {

    @SerializedName("comf")
    public Comfort comfort;

    @SerializedName("cw")
    public CarWash carWash;

    public Sport sport;

    public class Comfort {

        @SerializedName("txt")
        public String info;

    }

    public class CarWash {

        @SerializedName("txt")
        public String info;

    }

    public class Sport {

        @SerializedName("txt")
        public String info;

    }
    
}
```

由于 daily_forecast 中包含的是一个数据，数组中的每一项都代表着未来一天的天气信息，针对这种情况，我们只需要定义出单日天气的实体类就可以了，然后在声明实体类引用的时候使用集合类型来进行声明。Forecast 类

```java
public class Forecast {
    
    public String date;
    
    @SerializedName("tmp")
    public Temperature temperature;
    
    @SerializedName("cond")
    public More more;
    
    public class Temperature {
        
        public String max;
        
        public String min;
        
    }
    
    public class More {
        
        @SerializedName("txt_d")
        public String info;
        
    }
    
}
```

接下来还需要再创建一个总的实体类来引用刚刚创建的各个实体类

```java
public class Weather {
    
    public String status;
    
    public Basic basic;
    
    public AQI aqi;
    
    public Now now;
    
    public Suggestion suggestion;
    
    @SerializedName("daily_forecast")
    public List<Forecast> forecast;
    
}
```

在 Weather 类中，我们对 Basic 、AQI 、Now、Suggestion 和 Forecast 类进行了引用，其中由于 daily_forecast 中包含的是一个数组，因此这里使用了 List 集合来引用 Forecast 类。另外，返回的天气数据中还包含一项 status 数据，成功返回 ok，失败则会返回具体的原因，那么这里也需要添加一个对应的 status 字段

### 编写天气界面

首先创建一个用于显示天气信息的活动，右击 com.coolweather.android 包 -> New -> Activity -> Empty Activity，创建一个 WeatherActivity

由于所有的天气信息都将在同一个界面上显示，因此 activity_weather.xml 会是一个很长的布局，为了让里面的代码不至于混乱不堪，这里使用引入布局技术，即将界面的不同部分写在不同的布局文件里，再通过引入布局的方式集成到 activity_weather.xml 中，这样整个布局文件就会显得非常工整

右击 res/layout -> New -> Layout resource file，新建一个 title.xml 作为头布局

```java
<RelativeLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="?attr/actionBarSize">

    <TextView
        android:id="@+id/title_city"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_centerInParent="true"
        android:textColor="#fff"
        android:textSize="20sp" />

    <TextView
        android:id="@+id/title_update_time"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginRight="10dp"
        android:layout_alignParentRight="true"
        android:layout_centerVertical="true"
        android:textColor="#fff"
        android:textSize="16sp" />

</RelativeLayout>
```

头布局中放置了两个 TextView，一个居中显示城市名， 一个居右更新时间

然后创建一个 now.xml 作为当前天气信息的布局

```java
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_margin="15dp" >

    <TextView
        android:id="@+id/degree_text"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="end"
        android:textColor="#fff"
        android:textSize="60sp" />

    <TextView
        android:id="@+id/weather_info_text"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="end"
        android:textColor="#fff"
        android:textSize="20sp" />
    
</LinearLayout>
```

当前天气信息的布局也放置了两个 TextView，一个用于显示当前气温，一个用于显示天气概况

然后新建 forecast.xml 作为未来几天天气信息的布局

```java
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:layout_margin="15dp"
    android:background="#8000" >

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginLeft="15dp"
        android:layout_marginTop="15dp"
        android:text="预报"
        android:textColor="#fff"
        android:textSize="20sp" />

    <LinearLayout
        android:id="@+id/forecast_layout"
        android:orientation="vertical"
        android:layout_width="match_parent"
        android:layout_height="wrap_content">
    </LinearLayout>
    
</LinearLayout>
```

这里最外层使用 LinearLayout 定义了一个半透明的背景，然后使用了 TextView 定义了一个用于显示未来几天天气信息的布局，不过这个布局中并没有放入任何内容，因为这是根据服务器返回的数据在代码中动态添加的

定义一个未来天气信息的子项布局，创建 forecast_item.xml

```java
<LinearLayout 
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_margin="15dp" >
    
    <TextView
        android:id="@+id/data_text"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_gravity="center_vertical"
        android:layout_weight="2"
        android:textColor="#fff" />
    
    <TextView
        android:id="@+id/info_text"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_gravity="center_vertical"
        android:layout_weight="1"
        android:gravity="center"
        android:textColor="#fff" />
    
    <TextView
        android:id="@+id/max_text"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:layout_weight="1"
        android:gravity="right"
        android:textColor="#fff" />

    <TextView
        android:id="@+id/min_text"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:layout_weight="1"
        android:gravity="right"
        android:textColor="#fff" />
    
</LinearLayout>
```

子项布局中放置了 4 个 TextView，一个用于显示天气预报日期，一个用于显示天气概况，另外两个用于显示当天的最高温度和最低温度

然后新建 aqi.xml 作为空气质量信息的布局

```java
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_margin="15dp"
    android:background="#8000" >

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginLeft="15dp"
        android:layout_marginTop="15dp"
        android:text="空气质量"
        android:textColor="#fff"
        android:textSize="20sp" />

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_margin="15dp" >

        <RelativeLayout
            android:layout_width="0dp"
            android:layout_height="match_parent"
            android:layout_weight="1">

            <LinearLayout
                android:orientation="vertical"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_centerInParent="true">

                <TextView
                    android:id="@+id/aqi_text"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_gravity="center"
                    android:textColor="#fff"
                    android:textSize="40sp" />

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_gravity="center"
                    android:text="ÄQI指数"
                    android:textColor="#fff" />

            </LinearLayout>

        </RelativeLayout>

        <RelativeLayout
            android:layout_width="0dp"
            android:layout_height="match_parent"
            android:layout_weight="1" >

            <LinearLayout
                android:orientation="vertical"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_centerInParent="true" >

                <TextView
                    android:id="@+id/pm25_text"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:textColor="#fff"
                    android:textSize="40sp" />

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_gravity="center"
                    android:text="PM2.5指数"
                    android:textColor="#fff" />

            </LinearLayout>

        </RelativeLayout>
        
    </LinearLayout>

</LinearLayout>
```

使用 LinearLayout 定义了一个半透明的背景，然后使用 TextView 定义了一个标题，接下来使用 LinearLayout 和 RelativiLayout 嵌套的方式实现一个左右平分并且居中对齐的布局，分别用于显示 AQI 指数和 PM 2.5 指数

然后新建 suggestion.xml 作为生活建议信息的布局

```java
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_margin="15dp"
    android:background="#8000" >

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginLeft="15dp"
        android:layout_marginTop="15dp"
        android:text="生活建议"
        android:textColor="#fff"
        android:textSize="20sp" />

    <TextView
        android:id="@+id/comfort_text"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_margin="15dp"
        android:textColor="#fff" />

    <TextView
        android:id="@+id/car_wash_text"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_margin="15dp"
        android:textColor="#fff" />

    <TextView
        android:id="@+id/sport_text"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_margin="15dp"
        android:textColor="#fff" />

</LinearLayout>
```

这里同样是先定义了一个半透明的背景和一个标题，然后下面使用三个 TextView 分别用于显示舒适度、洗车指数和运动建议的相关数据

这样我们就把天气界面上每个部分的布局文件都编写好了，接下来的工作就是将它们引入到 activity_weather.xml 

```java
<FrameLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@color/colorPrimary">

    <ScrollView
        android:id="@+id/weather_layout"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:scrollbars="none"
        android:overScrollMode="never">

        <LinearLayout
            android:orientation="vertical"
            android:layout_width="match_parent"
            android:layout_height="wrap_content">

            <include layout="@layout/title" />

            <include layout="@layout/now" />

            <include layout="@layout/forecast" />

            <include layout="@layout/aqi" />

            <include layout="@layout/suggestion" />

        </LinearLayout>

    </ScrollView>

</FrameLayout>
```

首先最外层布局使用了一个 FrameLayout，并将它的背景色设置成 colorPrimary，然后在 FrameLayout 中嵌套一个 ScrollView，这是因为天气界面中的内容比较多，使用 ScrollView 可以允许我们通过滚动的方式查看屏幕外的内容

由于 ScrollView 的内部只允许存在一个直接子布局，因此这里有嵌套了一个垂直方向的 LinearLayout，然后在 LinearLayout 中将刚才定义的所有布局逐个引入

### 将天气显示到界面上

首先需要在 Utility 类中添加一个用于解析天气 JSON 数据的方法

```java
public class Utility {

   	...

    /**
     * 将返回的 JSON 数据解析成 Weather 实体类
     */
    // handleWeatherReqponse() 方法首先通过 JSONObject 和 JSONArray 将天气数据中的主题内容解析出来
    public static Weather handleWeatherReqponse(String response) {
        try {
            JSONObject jsonObject = new JSONObject(response);
            JSONArray jsonArray = jsonObject.getJSONArray("HeWeather");
            String weatherContent = jsonArray.getJSONObject(0).toString()；
            //由于我们之前已经按照上面所述的数据格式定义过相应的 GSON 实体类，因此只需要通过调用 fromJson() 方法就能直接将 JSON 数据转换成 Weather 对象
            return new Gson().fromJson(weatherContent, Weather.class);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

}
```

接下来的工作就是如何在活动中去请求天气数据，以及将数据展示到界面上，修改 WeatherActivity

```java
public class WeatherActivity extends AppCompatActivity {

    private ScrollView weatherLayout;

    private TextView titleCity;

    private TextView titleUpdateTime;

    private TextView degreeText;

    private TextView weatherInfoText;

    private LinearLayout forecastLayout;

    private TextView aqiText;

    private TextView pm25Text;

    private TextView comfortText;

    private TextView carWashText;

    private TextView sportText;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_weather);
        //初始化各控件
        weatherLayout = findViewById(R.id.weather_layout);
        titleCity = findViewById(R.id.title_city);
        titleUpdateTime = findViewById(R.id.title_update_time);
        degreeText = findViewById(R.id.degree_text);
        weatherInfoText = findViewById(R.id.weather_info_text);
        forecastLayout = findViewById(R.id.forecast_layout);
        aqiText = findViewById(R.id.aqi_text);
        pm25Text = findViewById(R.id.pm25_text);
        comfortText = findViewById(R.id.comfort_text);
        carWashText = findViewById(R.id.car_wash_text);
        sportText = findViewById(R.id.sport_text);
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);
        String weatherString = prefs.getString("weather", null);
        if (weatherString != null) {
            //有缓存时直接解析天气数据
            Weather weather = Utility.handleWeatherReqponse(weatherString);
            showWeatherInfo(weather);
        } else {
            //无缓存时去服务器查询天气
            //从 Intent 中取出天气 id，并调用 requestWeather() 方法来从服务器请求天气数据，注意，请求数据的时候先将 ScrollView 进行隐藏，不然空数据的界面看上去会很奇怪
            String weatherId = getIntent().getStringExtra("weather_id");
            weatherLayout.setVisibility(View.INVISIBLE);
            requestWeather(weatherId);
        }
    }

    /**
     * 根据天气 id 请求城市天气信息
     */
    public void requestWeather(final String weatherId) {
        //使用参数中传入的天气 id 和我们之前申请好的 APIKey 拼装出一个接口地址，接着调用 HttpUtil.sendOkHttpRequest() 方法来向该地址发出请求，服务器会将相应城市的天气信息以 JSON 格式返回
        String weatherUrl = "http://guolin.tech/api/weather?cityid=" + weatherId + "&key=a10afa0f2b3e4f46b0049265441c4dd9";
        HttpUtil.sendOkHttpRequest(weatherUrl, new Callback() {

            //在 onResponse() 回调中先调用 Utility.handleWeatherReqponse() 方法将返回的 JSON 数据转换成 Weather 对象，再将当前线程切换到主线程
            @Override
            public void onResponse(Call call, Response response) throws IOException {
                final String responseText = response.body().string();
                final Weather weather = Utility.handleWeatherReqponse(responseText);
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        //然后进行判断，如果服务器返回的 status 状态是 ok，就说明请求天气成功了，此时将返回的数据缓存到 SharedPreferences 中，并调用 showWeatherInfo() 方法来进行内容展示
                        if (weather != null && "ok".equals(weather.status)) {
                            SharedPreferences.Editor editor = PreferenceManager.getDefaultSharedPreferences(WeatherActivity.this).edit();
                            editor.putString("weather", responseText);
                            editor.apply();
                            showWeatherInfo(weather);
                        } else {
                            Toast.makeText(WeatherActivity.this, "获取天气信息失败", Toast.LENGTH_SHORT).show();
                        }
                    }
                });
            }

            @Override
            public void onFailure(Call call, IOException e) {
                e.printStackTrace();
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        Toast.makeText(WeatherActivity.this, "获取天气信息失败", Toast.LENGTH_SHORT).show();
                    }
                });
            }
        });
    }

    /**
     * 处理并展示 Weather 实体类中的数据
     */
    //从 weather 对象中获取数据，然后显示到相应的控件上
    private void showWeatherInfo(Weather weather) {
        String cityName = weather.basic.cityName;
        String updateTime = weather.basic.update.updateTime.split(" ")[1];
        String degree = weather.now.temperature + "℃";
        String weatherInfo = weather.now.more.info;
        titleCity.setText(cityName);
        titleUpdateTime.setText(updateTime);
        degreeText.setText(degree);
        weatherInfoText.setText(weatherInfo);
        forecastLayout.removeAllViews();
        //在未来几天天气预报的部分我们使用一个 for 循环来处理每天的天气信息，在循环中动态加载 forecast_item.xml 布局并设置相应的数据，然后添加到父布局当中
        for (Forecast forecast : weather.forecastList) {
            View view = LayoutInflater.from(this).inflate(R.layout.forecast_item, forecastLayout, false);
            TextView dateText = view.findViewById(R.id.date_text);
            TextView infoText = view.findViewById(R.id.info_text);
            TextView maxText = view.findViewById(R.id.max_text);
            TextView minText = view.findViewById(R.id.min_text);
            dateText.setText(forecast.date);
            infoText.setText(forecast.more.info);
            maxText.setText(forecast.temperature.max);
            minText.setText(forecast.temperature.min);
            forecastLayout.addView(view);
        }
        if (weather.aqi != null) {
            aqiText.setText(weather.aqi.city.aqi);
            pm25Text.setText(weather.aqi.city.pm25);
        }
        String comfort = "舒适度：" + weather.suggestion.comfort.info;
        String carWash = "洗车指数：" + weather.suggestion.carWash.info;
        String sport = "运动建议：" + weather.suggestion.sport.info;
        comfortText.setText(comfort);
        carWashText.setText(carWash);
        sportText.setText(sport);
        //最后将 ScrollView 重新变成可见
        weatherLayout.setVisibility(View.VISIBLE);
    }

}
```

处理完 WeatherActivity 中的逻辑，接下来我们要做的就是如何从省市县列表界面跳转到天气界面，修改 ChooseAreaFragment

```java
public class ChooseAreaFragment extends Fragment {
	
    ...

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
            @Override
            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                if (currentLevel == LEVEL_PROVINCE) {
                    selectedProvince = provinceList.get(position);
                    queryCities();
                } else if (currentLevel == LEVEL_CITY) {
                    selectedCity = cityList.get(position);
                    queryCounties();
                } else if (currentLevel == LEVEL_COUNTY) {
                    //在 onItemClick() 添加了一个 if 判断，如果当前级别是 LEVEL_COUNTY，就启动 WeatherActivity，并把当前选中县的天气 id 传递进去
                    String weatherId = countyList.get(position).getWeatherId();
                    Intent intent = new Intent(getActivity(), WeatherActivity.class);
                    intent.putExtra("weather_id", weatherId);
                    startActivity(intent);
                    getActivity().finish();
                }
            }
        });
       ...
    }
	...

}
```

另外，我们还需要在 MainActivity 中加入一个缓存数据的判断才行，修改 MainActivity

```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        //在 onCreate() 方法的一开始先从 SharedPreferences 文件中读取缓存数据，如果不为 null 就说明之前已经请求过天气数据了，那么就没必要让用户再次选择城市，而是直接跳转到 WeatherActivity 即可
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);
        if (prefs.getString("weather", null) != null) {
            Intent intent = new Intent(this, WeatherActivity.class);
            startActivity(intent);
            finish();
        }
    }
}
```



### 获取必应每日一图

固定的背景色不太美观，为了解决界面一成不变，我们获取必应的每日一图的接口：http://guolin.tech/api/bing_pic 访问这个接口，服务器会返回今日的必应背景图连接，然后我们再使用 Glide 去加载这张图片就可以了

修改 activity_main.xml

```java
<FrameLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@color/colorPrimary">

	//在 FrameLayout 中添加一个 ImageView，并且将它的宽和高设置成 match_parent。由于 FrameLayout 默认情况下会将控件都放置在左上角，因此 ScrollView 会完全覆盖住 ImageView，从而 ImageView 也就会成为背景图片 
    <ImageView
        android:id="@+id/bing_pic_img"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:scaleType="centerCrop" />
            
        ...

</FrameLayout>
```

修改 WeatherActivity

```java
public class WeatherActivity extends AppCompatActivity {

	...

    private ImageView bingPicImg;

     //首先在 onCreate() 方法中获取了新增控件 ImageView 的实例，然后尝试从 SharedPreferences 中读取缓存的背景图片，如果有缓存的话就直接使用 Glide 来加载这张图片，如果没有的话就调用 loadBingPic() 方法去请求今日的必应背景图
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_weather);
        //初始化各控件
        bingPicImg = findViewById(R.id.bing_pic_img);
       ...
        String bingPic = prefs.getString("bing_pic", null);
        if (bingPic != null) {
            Glide.with(this)
                    .load(bingPic)
                    .into(bingPicImg);
        } else {
            loadBingPic();
        }
    }

    /**
     * 根据天气 id 请求城市天气信息
     */
    public void requestWeather(final String weatherId) {
		...
        //需注意在 requestWeather() 方法的最后也需要调用一下 loadBingPic() 方法，这样在每次请求天气信息的时候同时也会刷新背景图片
        loadBingPic();
    }

    /**
     * 加载必应每日一图
     */
    private void loadBingPic() {
        String requestBingPic = "http://guolin.tech/api/bing_pic";
        //先是调用 HttpUtil.sendOkHttpRequest() 方法获取到必应背景图的连接，然后将这个链接缓存到 SharedPreferences 当中，再将当前线程切换到主线程，最后使用 Glide 来加载这张图片就可以了
        HttpUtil.sendOkHttpRequest(requestBingPic, new Callback() {
            @Override
            public void onResponse(Call call, Response response) throws IOException {
                final String bingPic = response.body().string();
                SharedPreferences.Editor editor = PreferenceManager.getDefaultSharedPreferences(WeatherActivity.this).edit();
                editor.putString("bing_pic", bingPic);
                editor.apply();
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        Glide.with(WeatherActivity.this)
                                .load(bingPic)
                                .into(bingPicImg);
                    }
                });
            }
            @Override
            public void onFailure(Call call, IOException e) {
                e.printStackTrace();
            }
        });
    }
	
    ...

}
```

运行后，你发现背景图并没有和状态栏融合到一起，如果像第十二章第七小节一样借助 Design Support 库，然后嵌套 CoordinatorLayout 、AppBarLayout 、CollapsingToolbarLayout 等布局是过于麻烦，这里用一种更简单的方法，修改 WeatherActivity

```java
public class WeatherActivity extends AppCompatActivity {
	...
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        //由于这个功能是 Android 5.0 及以上的系统才支持的，因此我们先在代码中做了一个系统版本号的判断，只有当版本号大于或等于 21，也就是 5.0 及以上系统时才会执行后面的代码
        if (Build.VERSION.SDK_INT >= 21) {
            //接着调用了 getWindow().getDecorView() 拿到当前活动的 DecorView，再调用它的 setSystemUiVisibility() 方法来改变系统 UI 的显示，在这里传入 View.SYSTEM_UI_FLAG_FULLSCREEN 和 View.SYSTEM_UI_FLAG_LAYOUT_STABLE 就表示活动的布局会显示在状态栏上面，最后调用一下 setStatusBarColor() 方法将状态栏设置成透明色
            View decorView = getWindow().getDecorView();
            decorView.setSystemUiVisibility(SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE);
            getWindow().setStatusBarColor(Color.TRANSPARENT);
        }
	...
    }
	...
}
```

仅仅这些代码就可以实现让背景图和状态栏融合到一起的效果，不过运行下程序你会发现有些问题，天气界面的头布局几乎和系统状态栏紧贴在一起了，这是由于系统状态栏已经成为了我们布局的一部分，因此没有单独为它留出空间，当然这个问题也很好解决，借助 android:fitsSystemWindows 属性就可以了，修改 activity_weather.xml

```java
<FrameLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@color/colorPrimary">
	
    ...
        
    <ScrollView
        android:id="@+id/weather_layout"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:scrollbars="none"
        android:overScrollMode="never">

        <LinearLayout
            android:orientation="vertical"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            //将 android:fitsSystemWindows 这个属性设置成 true 就表示会为系统状态栏留出空间
            android:fitsSystemWindows="true" >
			...
        </LinearLayout>

    </ScrollView>

</FrameLayout>
```

第三阶段的工作也都完成了，提交一下代码



## 手动更新天气和切换城市

### 手动更新天气

由于我们在上一节中对天气信息进行了缓存，目前每次展示的都是缓存中的数据，我们采用下拉刷新的方式来触发更新事件，修改 activity_weather.xml

```java
<FrameLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@color/colorPrimary">

 	...
    <android.support.v4.widget.SwipeRefreshLayout
        android:id="@+id/swipe_refresh"
        android:layout_width="match_parent"
        android:layout_height="match_parent">
		
       	...

    </android.support.v4.widget.SwipeRefreshLayout>

</FrameLayout>
```

在 ScrollView 的外面嵌套了一层 SwipeRefreshLayout，这样 ScrollView 就自动拥有下拉刷新功能了

然后修改 WeatherActivity

```java
public class WeatherActivity extends AppCompatActivity {

	...

    public SwipeRefreshLayout swipeRefresh;

    private String mWeatherId;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ...
        //获取实例，然后调用 setColorSchemeResources() 方法来设置下拉刷新进度条的颜色，这里我们使用主题中的 colorPrimary 作为进度条的颜色
        swipeRefresh = findViewById(R.id.swipe_refresh);
        swipeRefresh.setColorSchemeResources(R.color.colorPrimary);
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);
        String weatherString = prefs.getString("weather", null);
        if (weatherString != null) {
            //有缓存时直接解析天气数据
            Weather weather = Utility.handleWeatherReqponse(weatherString);
            //定义一个变量 mWeatherId 用于记录城市的天气 id
            mWeatherId = weather.basic.weatherId;
            showWeatherInfo(weather);
        } else {
            //无缓存时去服务器查询天气
            mWeatherId = getIntent().getStringExtra("weather_id");
            weatherLayout.setVisibility(View.INVISIBLE);
            requestWeather(mWeatherId);
        }
        //然后调用 setOnRefreshListener 方法来设置一个下拉刷新的监听器，当触发了下拉刷新操作的时候，就会回调这个监听器的 onRefresh() 方法，我们在这里去调用 requestWeather() 方法请求天气信息就可以了
        swipeRefresh.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() {
            @Override
            public void onRefresh() {
                requestWeather(mWeatherId);
            }
        });
        String bingPic = prefs.getString("bing_pic", null);
        if (bingPic != null) {
            Glide.with(this)
                    .load(bingPic)
                    .into(bingPicImg);
        } else {
            loadBingPic();
        }
    }

    /**
     * 根据天气 id 请求城市天气信息
     */
    public void requestWeather(final String weatherId) {
        String weatherUrl = "http://guolin.tech/api/weather?cityid=" + weatherId + "&key=a10afa0f2b3e4f46b0049265441c4dd9";
        HttpUtil.sendOkHttpRequest(weatherUrl, new Callback() {
            @Override
            public void onResponse(Call call, Response response) throws IOException {
                final String responseText = response.body().string();
                final Weather weather = Utility.handleWeatherReqponse(responseText);
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        if (weather != null && "ok".equals(weather.status)) {
                            SharedPreferences.Editor editor = PreferenceManager.getDefaultSharedPreferences(WeatherActivity.this).edit();
                            editor.putString("weather", responseText);
                            editor.apply();
                            //
                            mWeatherId = weather.basic.weatherId;
                            showWeatherInfo(weather);
                        } else {
                            Toast.makeText(WeatherActivity.this, "获取天气信息失败", Toast.LENGTH_SHORT).show();
                        }
                        //请求结束后还需要调用 SwipeRefreshLayout 的 setRefreshing 方法并传入 false，用于表示刷新事件结束，并隐藏刷新进度条
                        swipeRefresh.setRefreshing(false);
                    }
                });
            }
            @Override
            public void onFailure(Call call, IOException e) {
                e.printStackTrace();
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        Toast.makeText(WeatherActivity.this, "获取天气信息失败", Toast.LENGTH_SHORT).show();
                        //
                        swipeRefresh.setRefreshing(false);
                    }
                });
            }
        });
        loadBingPic();
    }

	...

}
```

### 切换城市

复用遍历全国省市县数据的碎片，将碎片放在滑动菜单中

首先在头布局中加入一个切换城市的按钮，修改 title.xml

```java
<RelativeLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="?attr/actionBarSize">
    
    //添加一个 Button 作为切换城市的按钮，并且让它居左显示
    <Button
        android:id="@+id/nav_button"
        android:layout_width="30dp"
        android:layout_height="30dp"
        android:layout_marginLeft="10dp"
        android:layout_alignParentLeft="true"
        android:layout_centerVertical="true"
        android:background="@drawable/ic_home" />

        ...
            
</RelativeLayout>
```

接着修改 activity_weather.xml

```java
<FrameLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@color/colorPrimary">

    <ImageView
        android:id="@+id/bing_pic_img"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:scaleType="centerCrop" />

    <android.support.v4.widget.DrawerLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <android.support.v4.widget.SwipeRefreshLayout
            android:id="@+id/swipe_refresh"
            android:layout_width="match_parent"
            android:layout_height="match_parent">
    
           ...
    
        <fragment
            android:id="@+id/choose_area_fragment"
            android:name="com.coolweather.android.ChooseAreaFragment"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:layout_gravity="start"/>

    </android.support.v4.widget.DrawerLayout>
    
</FrameLayout>
```

在 SwipeRefreshLayout 的外面嵌套了一层 DrawerLayout。DrawerLayout 中的第一个子控件用于作为主屏幕中显示的内容，第二个子控件用于作为滑动菜单中显示的内容，因此这里我们在第二个子控件的位置添加了用于遍历省市县数据的碎片

接下来需要在 WeatherActivity 中加入滑动菜单的逻辑处理，修改 WeatherActivity

```java
public class WeatherActivity extends AppCompatActivity {

	...

    public DrawerLayout drawerLayout;

    private Button navButton;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ...
        //在 onCreate() 方法中获取到新增的 DrawerLayout 和 Button 实例
        drawerLayout = findViewById(R.id.drawer_layout);
        navButton = findViewById(R.id.nav_button);
        ...
        //然后在 Button 点击事件中调用 DrawerLayout 的 openDrawer() 方法来打开滑动菜单就可以了
        navButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                drawerLayout.openDrawer(GravityCompat.START);
            }
        }); 
    }

    ...

}
```

不过这仅仅是打开了滑动菜单而已，我们还需要处理切换城市后的逻辑，这个工作就必须要在 ChooseAreaFragment 中进行了，因为之前选中了某个城市后是跳转到 WeatherActivity 的，而现在由于我们本来就是在 WeatherActivity 当中的，因此并不需要跳转，只是去请求新选择城市的天气信息就可以了

很显然这里需要根据 ChooseAreaFragment 的不同状态来进行不同的逻辑处理，修改 ChooseAreaFragment

```java
public class ChooseAreaFragment extends Fragment {

    ...
    
    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
            @Override
            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                if (currentLevel == LEVEL_PROVINCE) {
                    selectedProvince = provinceList.get(position);
                    queryCities();
                } else if (currentLevel == LEVEL_CITY) {
                    selectedCity = cityList.get(position);
                    queryCounties();
                } else if (currentLevel == LEVEL_COUNTY) {
                    String weatherId = countyList.get(position).getWeatherId();
                    //这里使用了一个 Java 小技巧，instanceof 关键字可以用来判断一个对象是否属于某个类的实例。我们在碎片中调用 getActivity() 方法，然后配合 instanceof 关键字，就能轻松判断出该碎片是在 MainActivity 中还是在 WeatherActivity 中，如果是在 MainActivity 中，那么逻辑不变，如果是在 WeatherActivity 中，那么关闭滑动菜单，显示下拉刷新进度条，然后请求新城市的天气信息
                    if (getActivity() instanceof MainActivity) {
                        Intent intent = new Intent(getActivity(), WeatherActivity.class);
                        intent.putExtra("weather_id", weatherId);
                        startActivity(intent);
                        getActivity().finish();
                    } else if (getActivity() instanceof WeatherActivity) {
                        WeatherActivity activity = (WeatherActivity) getActivity();
                        activity.drawerLayout.closeDrawers();
                        activity.swipeRefresh.setRefreshing(true);
                        activity.requestWeather(weatherId);
                    }
                }
            }
        });
       ...
    }

    ...
    
}
```

这样第四阶段的开发任务也完成了，不要忘记提交代码



## 后台自动更新天气

在第五阶段我们准备加入后台自动更新天气的功能，这样就可以尽可能地保证用户每次打开软件时看到的都是最新的天气信息

要实现上述功能，就需要创建一个长期在后台运行的定时任务，首先在 service 包下新建一个服务，右击 com.coolweather.android.service -> New -> Service -> Service，创建一个 AutoUpdateService 并将 Exported 和 Enable 这两个属性都勾中，修改 AutoUpdateService

```java
public class AutoUpdateService extends Service {

    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    //在 onStartCommand() 方法中先是调用了 updateWeather() 方法来更新天气，然后调用 updateBingPic() 方法来更新背景图片。将更新后的数据直接存储到 SharedPreferences 文件中就可以了，因为打开 WeatherActivity 的时候都会优先从 SharedPreferences 缓存中读取数据
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        updateWeather();
        updateBingPic();
        //之后就是我们学习过的创建定时任务了，我们这里将时间设置为 8 小时，8 小时候 AutoUpdateService 的 onStartCommand() 方法就会重新执行，这样就实现后台定时刷新的功能了
        AlarmManager manager = (AlarmManager) getSystemService(ALARM_SERVICE);
        int anHour = 8 * 60 * 60 * 1000;//这是 8 小时的毫秒数
        long triggerAtTime = SystemClock.elapsedRealtime() + anHour;
        Intent i = new Intent(this, AutoUpdateService.class);
        PendingIntent pi = PendingIntent.getService(this, 0, i, 0);
        manager.cancel(pi);
        manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtTime, pi);
        return super.onStartCommand(intent, flags, startId);
    }

    /**
     * 更新天气信息
     */
    private void updateWeather() {
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);
        String weatherString = prefs.getString("weather", null);
        if (weatherString != null) {
            //有缓存时直接解析天气数据
            Weather weather = Utility.handleWeatherReqponse(weatherString);
            String weatherId = weather.basic.weatherId;
            String weatherUrl = "http://guolin.tech/api/weather?cityid=" + weatherId + "&key=a10afa0f2b3e4f46b0049265441c4dd9";
            HttpUtil.sendOkHttpRequest(weatherUrl, new Callback() {
                @Override
                public void onResponse(Call call, Response response) throws IOException {
                    String responseText = response.body().string();
                    Weather weather = Utility.handleWeatherReqponse(responseText);
                    if (weather != null && "ok".equals(weather.status)) {
                        SharedPreferences.Editor editor = PreferenceManager.getDefaultSharedPreferences(AutoUpdateService.this).edit();
                        editor.putString();
                        editor.apply();
                    }
                }
                @Override
                public void onFailure(Call call, IOException e) {
                    e.printStackTrace();
                }

            });
        }
    }

    /**
     * 更新必应每日一图
     */
    private void updateBingPic() {
        String requestBinigPic = "http://guolin.tech/api/bing_pic";
        HttpUtil.sendOkHttpRequest(requestBinigPic, new Callback() {
            @Override
            public void onResponse(Call call, Response response) throws IOException {
                String bingPic = response.body().string();
                SharedPreferences.Editor editor = PreferenceManager.getDefaultSharedPreferences(AutoUpdateService.this).edit();
                editor.putString("bing_pic", bingPic);
                editor.apply();
            }
            @Override
            public void onFailure(Call call, IOException e) {
                e.printStackTrace();
            }
        });
    }
    
}
```

不过我们还需要在代码中去激活 AutoUpdateService 这个服务才行，修改 WeatherActivity

```java
public class WeatherActivity extends AppCompatActivity {
	
    ...

    /**
     * 处理并展示 Weather 实体类中的数据
     */
    private void showWeatherInfo(Weather weather) {
        ...
        weatherLayout.setVisibility(View.VISIBLE);
        //在 showWeatherInfo() 方法最后加入启动 AutoUpdateService 这个服务的代码，这样只要一旦选中了某个城市并成功更新天气之后，AutoUpdateService 就会一直在后台运行，并保证每 8 小时更新一次天气
        Intent intent = new Intent(this, AutoUpdateService.class);
        startService(intent);
    }

}
```

再提交一下代码



## 修改图标和名称

理论上，我们应该给这个图标提供几种不同分辨率的版本，然后分别放入到相应分辨率的 mipmap 目录下，这里简单起见，都是用了同一张图。修改 AndroidManifestx.xml

```java
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.coolweather.android">

    <uses-permission android:name="android.permission.INTERNET" />

    <application
        android:name="org.litepal.LitePalApplication"
        android:allowBackup="true"
        //这里将 <application> 标签的 android:icon 属性指定成 @mipmap/logo 就可以修改程序图标了
        android:icon="@mipmap/logo"
        ...
    </application>

</manifest>
```

接下来我们还需要修改一下程序的名称，将它修改成酷欧天气即可，打开 res/values/string.xml，其中 app_name 对应的就是程序名称

```java
<resources>
    <string name="app_name">酷欧天气</string>
</resources>
```

提交代码