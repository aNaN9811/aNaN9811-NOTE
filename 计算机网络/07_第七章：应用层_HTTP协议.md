# HTTP协议



## 概况

超文本传输协议（HyperText Transfer Protocol）HTTP

HTTP由两个程序实现：一个客户程序，一个服务程序

两个程序通过交换HTTP报文进行会话，HTTP就是定义了报文的结构以及两个程序间报文交换的方式



## Web

Web页面（Web page）（也叫文档）是由对象组成的。一个对象只是一个文件。例如一个HTML文件。

HTML基本文件通过对象的URL地址引用页面中的其他对象

每个URL地址 = 存放对象的服务器主机名 + 对象的路径名

HTTP使用TCP作为支撑运输的协议

当HTTP客户与服务建立连接，客户进程通过套接字接口访问TCP，即通过套接字接口发送HTTP请求或接收HTTP响应的报文。当向套接字接口发送HTTP请求，客户就脱离了控制，TCP就接管了控制

注意：服务器没有存储客户的状态信息，而只是向客户发送被请求的文件



## 非持续连接和持续连接



### 非持续连接

每个连接处理一个请求-响应事务，即一个TCP连接处理一个请求后断开

1. HTTP客户进程在**80端口号**发起一个到**服务器域名地址**的**TCP连接**。在客户和服务器上**分别有一个套接字与连接相关联**
2. HTTP客户经它的**套接字发送一个HTTP请求报文**。请求报文中包含了**路径名**
3. HTTP服务器进程**经它的套接字接收到请求报文**，**从其存储器检索出路径名的对象**，**在一个HTTP响应报文中封装该对象**，并**通过它的套接字想客户发送响应报文**
4. **HTTP服务器进程通知TCP断开改TCP连接**（**但直到TCP确认客户已经完整地接收到响应报文为止，它才会实际中断连续**）
5. **HTTP接收客户响应报文，TCP连接关闭**
6. **对对象的每个引用对象重复前4个步骤**

HTTP 是一个无状态协议

HTTP 与客户如何解释一个对象没有关系，HTTP 规范仅定义了在 HTTP 客户程序与服务程序之间的通信协议

缺点：

- 必须为每一个请求的对象建立和维护一个新的连接（对于每个连接，在客户和服务器都要分配TCP缓冲区和保持TCP的变量，这个Web服务器带来了严重的负担）
- 每一个对象经受两倍的RTT交付时延（一个RTT用于创建TCP链接，另一个用于请求和接收一个对象）



### 持续连接

每个连接可以处理多个请求-响应事务，即多个事务同时在一个TCP连接中处理，也就是可以用单个持续 TCP 连接进行传送（一个HTML基本文件上还有10个图形），更有同一台服务器的多个 Web 页面在从该服务器发送给一个客户时，可以在单个持续的 TCP 连接上进行。HTTP1.1默认使用持续连接，一般来说，如果一条链接经过一定时间间隔仍未被使用，HTTP服务器就关闭该链接





## HTTP报文格式

HTTP 报文有两种：请求报文和响应报文



### HTTP 请求报文

报文是普通的 ASCII 文本书写的，每行由一个回车和换行符结束，最后一行后再加一个回车换行符

![](E:\计算机网络\笔记用图\请求报文.jpg)

方法字段有：GET、POST、HEAD、PUT 和 DELETE

首部行提供的信息时 Web 代理高速缓存所要求的

User - agent：指明用户代理，即向服务器发送请求的浏览器类型

![](E:\计算机网络\笔记用图\HTTP请求报文的通用格式.jpg)

在首部行的空行（回车和换行）后有一个**实体体**，使用 GET 方法时，实体体为空，而使用 POST 方法时才使用该实体体

POST：当用户提交表单是，HTTP 客户常常使用 POST 方法，如果方法字段的值为 POST，那么实体体中包含的就是用户在表单字段中的输入值

HTML 表单也经常使用 GET 方法，并在（表单字段中）所请求的 URL 中包括输入的数据

HEAD：当服务器收到一个使用 HEAD 方法的请求时，将会用一个 HTTP 报文进行响应，但是并不返回请求对象，应用程序开发者常用 HEAD 方法进行调试跟踪

PUT：该方法常与 Web 发行工具联合使用，它允许用户上传对象到指定的 Web 服务器上指定的路径（目录），PUT 方法也被那些需要想 Web 服务器上传对象的应用程序使用

DELETE：该方法允许用户或者应用程序删除 Web 服务器上的对象



#### GET 和 POST 方法区别

POST和GET都是向服务器提交数据，并且都会从服务器获取数据

区别：

- GET 在所请求的扩展 URL 中包括输入的数据，POST 则将表单字段中的数据包含在了实体体中
- GET 参数长度受限于 URL 长度，POST 无限制
- GET 产生一个 TCP 数据段（GET 客户端把 head 和 data 一同发送出去，服务器响应200），POST 产生两个 TCP 数据段（POST 客户端先发送 head，服务端响应 100 continue，接着再发送 data，服务器响应200，因为需要两步，所以会更耗时一点）

注意：

- GET与POST都有自己的语义，不能随便混用
- 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点
- 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次

建议：

- GET 方式的安全性较 POST 方式要差些，包含机密信息的话，建议用 POST 数据提交方式
- 在做数据查询时，建议用 GET 方式；而在做数据添加、修改或删除时，建议用 POST 方式



### HTTP 响应报文

![](E:\计算机网络\笔记用图\响应报文.jpg)

![](E:\计算机网络\笔记用图\HTTP响应报文的通用格式.jpg)

HTTP 规范中定义了许许多多的首部行，这些首部行可以被浏览器、Web 服务器和 Web 缓存服务器插入

# HTTPS 工作流程

数据通信仍然是HTTP，但利用**SSL/TLS加密数据包**。

1. 用户在浏览器发起 HTTPS 请求，默认使用服务端的 443 端口进行连接（HTTPS 需要使用一套 **CA数字证书**，证书内会附带一个**公钥Pub**，与之对应的**私钥Private**保留在服务端不公开）
2. 服务端收到请求，返回配置好的**包含公钥Pub的证书**给客户端
3. 客户端收到**证书**，校验其合法性，主要包括是否在有效期内、证书的域名与请求的域名是否匹配，上一级的证书是否有效（递归判断，直到判断到系统内置或浏览器配置好的根证书），如果不通过，显示 HTTPS 的警告信息，如果通过则继续
4. 客户端生成一个用于加密使用的**随机Key**，并用证书内的**公钥Pub**进行加密，发送给服务端
5. 服务端收到**随机Key**的密文，使用与**公钥Pub**配对的**私钥Private**进行解密，得到客户端真正想发送的**随机Key**
6. 服务端使用客户端发送过来的**随机Key**对要传输的 HTTP 数据进行对称加密，将密文返回给客户端
7. 客户端使用**随机Key**对称解密密文，得到 HTTP 数据明文
8. 后续 HTTPS 请求使用之前交换好的**随机Key**进行对称解密